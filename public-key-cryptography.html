<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>10 Public key cryptography | A Minimal Book Example</title>
  <meta name="description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="10 Public key cryptography | A Minimal Book Example" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="10 Public key cryptography | A Minimal Book Example" />
  
  <meta name="twitter:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"/>
<link rel="next" href="concrete-candidates-for-public-key-crypto.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">A Minimal Book Example</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="mathematical-background.html"><a href="mathematical-background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a>
<ul>
<li class="chapter" data-level="1.1" data-path="mathematical-background.html"><a href="mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>1.1</b> A quick overview of mathematical prerequisites</a></li>
<li class="chapter" data-level="1.2" data-path="mathematical-background.html"><a href="mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>1.2</b> Mathematical Proofs</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="mathematical-background.html"><a href="mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>1.2.1</b> Example: The existence of infinitely many primes.</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="mathematical-background.html"><a href="mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>1.3</b> Probability and Sample spaces</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="mathematical-background.html"><a href="mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>1.3.1</b> Random variables</a></li>
<li class="chapter" data-level="1.3.2" data-path="mathematical-background.html"><a href="mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>1.3.2</b> Distributions over strings</a></li>
<li class="chapter" data-level="1.3.3" data-path="mathematical-background.html"><a href="mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>1.3.3</b> More general sample spaces.</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="mathematical-background.html"><a href="mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>1.4</b> Correlations and independence</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="mathematical-background.html"><a href="mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>1.4.1</b> Independent random variables</a></li>
<li class="chapter" data-level="1.4.2" data-path="mathematical-background.html"><a href="mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>1.4.2</b> Collections of independent random variables.</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="mathematical-background.html"><a href="mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>1.5</b> Concentration and tail bounds</a>
<ul>
<li class="chapter" data-level="1.5.1" data-path="mathematical-background.html"><a href="mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>1.5.1</b> Chebyshev’s Inequality</a></li>
<li class="chapter" data-level="1.5.2" data-path="mathematical-background.html"><a href="mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>1.5.2</b> The Chernoff bound</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
<li class="chapter" data-level="1.7" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>1.7</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a>
<ul>
<li class="chapter" data-level="2.1" data-path="introduction.html"><a href="introduction.html#some-history"><i class="fa fa-check"></i><b>2.1</b> Some history</a></li>
<li class="chapter" data-level="2.2" data-path="introduction.html"><a href="introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>2.2</b> Defining encryptions</a></li>
<li class="chapter" data-level="2.3" data-path="introduction.html"><a href="introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>2.3</b> Defining security of encryption</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="introduction.html"><a href="introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>2.3.1</b> Generating randomness in actual cryptographic systems</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="introduction.html"><a href="introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>2.4</b> Defining the secrecy requirement.</a></li>
<li class="chapter" data-level="2.5" data-path="introduction.html"><a href="introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>2.5</b> Perfect Secrecy</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="introduction.html"><a href="introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>2.5.1</b> Achieving perfect secrecy</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="introduction.html"><a href="introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>2.6</b> Necessity of long keys</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="introduction.html"><a href="introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>2.6.1</b> Amplifying success probability</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="introduction.html"><a href="introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="computational-security.html"><a href="computational-security.html"><i class="fa fa-check"></i><b>3</b> Computational Security</a>
<ul>
<li class="chapter" data-level="3.0.1" data-path="computational-security.html"><a href="computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>3.0.1</b> Proof by reduction</a></li>
<li class="chapter" data-level="3.1" data-path="computational-security.html"><a href="computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>3.1</b> The asymptotic approach</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="computational-security.html"><a href="computational-security.html#countoperation"><i class="fa fa-check"></i><b>3.1.1</b> Counting number of operations.</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="computational-security.html"><a href="computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>3.2</b> Our first conjecture</a></li>
<li class="chapter" data-level="3.3" data-path="computational-security.html"><a href="computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>3.3</b> Why care about the cipher conjecture?</a></li>
<li class="chapter" data-level="3.4" data-path="computational-security.html"><a href="computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>3.4</b> Prelude: Computational Indistinguishability</a></li>
<li class="chapter" data-level="3.5" data-path="computational-security.html"><a href="computational-security.html#the-length-extension-theorem-or-stream-ciphers"><i class="fa fa-check"></i><b>3.5</b> The Length Extension Theorem or Stream Ciphers</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="computational-security.html"><a href="computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>3.5.1</b> Appendix: The computational model</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pseudorandomness.html"><a href="pseudorandomness.html"><i class="fa fa-check"></i><b>4</b> Pseudorandomness</a>
<ul>
<li class="chapter" data-level="4.0.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#unpredictability-an-alternative-approach-for-proving-the-length-extension-theorem"><i class="fa fa-check"></i><b>4.0.1</b> Unpredictability: an alternative approach for proving the length extension theorem</a></li>
<li class="chapter" data-level="4.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#stream-ciphers"><i class="fa fa-check"></i><b>4.1</b> Stream ciphers</a></li>
<li class="chapter" data-level="4.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>4.2</b> What do pseudorandom generators actually look like?</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>4.2.1</b> Attempt 0: The counter generator</a></li>
<li class="chapter" data-level="4.2.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>4.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li>
<li class="chapter" data-level="4.2.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>4.2.3</b> From insecurity to security</a></li>
<li class="chapter" data-level="4.2.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>4.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#successful-examples"><i class="fa fa-check"></i><b>4.3</b> Successful examples</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>4.3.1</b> Case Study 1: Subset Sum Generator</a></li>
<li class="chapter" data-level="4.3.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-2-rc4"><i class="fa fa-check"></i><b>4.3.2</b> Case Study 2: RC4</a></li>
<li class="chapter" data-level="4.3.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-3-blum-blum-and-shub"><i class="fa fa-check"></i><b>4.3.3</b> Case Study 3: Blum, Blum and Shub</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>4.4</b> Non-constructive existence of pseudorandom generators</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions</a>
<ul>
<li class="chapter" data-level="5.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>5.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>5.1.1</b> How do pseudorandom functions help in the login problem?</a></li>
<li class="chapter" data-level="5.1.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#modifying-input-and-output-lengths-of-prfs"><i class="fa fa-check"></i><b>5.1.2</b> Modifying input and output lengths of PRFs</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>5.2</b> Message Authentication Codes</a></li>
<li class="chapter" data-level="5.3" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>5.3</b> MACs from PRFs</a></li>
<li class="chapter" data-level="5.4" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#arbitrary-input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>5.4</b> Arbitrary input length extension for MACs and PRFs</a></li>
<li class="chapter" data-level="5.5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>5.5</b> Aside: natural proofs</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><i class="fa fa-check"></i><b>6</b> Pseudorandom functions from pseudorandom generators and CPA security</a>
<ul>
<li class="chapter" data-level="6.1" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>6.1</b> Securely encrypting many messages - chosen plaintext security</a></li>
<li class="chapter" data-level="6.2" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>6.2</b> Pseudorandom permutations / block ciphers</a></li>
<li class="chapter" data-level="6.3" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#encryption-modes"><i class="fa fa-check"></i><b>6.3</b> Encryption modes</a></li>
<li class="chapter" data-level="6.4" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>6.4</b> Optional, Aside: Broadcast Encryption</a></li>
<li class="chapter" data-level="6.5" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#reading-comprehension-exercises"><i class="fa fa-check"></i><b>6.5</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html"><i class="fa fa-check"></i><b>7</b> Chosen Ciphertext Security</a>
<ul>
<li class="chapter" data-level="7.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#short-recap"><i class="fa fa-check"></i><b>7.1</b> Short recap</a></li>
<li class="chapter" data-level="7.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#going-beyond-cpa"><i class="fa fa-check"></i><b>7.2</b> Going beyond CPA</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#example-the-wired-equivalence-privacy-wep"><i class="fa fa-check"></i><b>7.2.1</b> Example: The Wired Equivalence Privacy (WEP)</a></li>
<li class="chapter" data-level="7.2.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>7.2.2</b> Chosen ciphertext security</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>7.3</b> Constructing CCA secure encryption</a></li>
<li class="chapter" data-level="7.4" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>7.4</b> (Simplified) GCM encryption</a></li>
<li class="chapter" data-level="7.5" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>7.5</b> Padding, chopping, and their pitfalls: the “buffer overflow” of cryptography</a></li>
<li class="chapter" data-level="7.6" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>7.6</b> Chosen ciphertext attack as implementing metaphors</a></li>
<li class="chapter" data-level="7.7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#reading-comprehension-exercises-1"><i class="fa fa-check"></i><b>7.7</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="hash-functions-random-oracles-and-bitcoin.html"><a href="hash-functions-random-oracles-and-bitcoin.html"><i class="fa fa-check"></i><b>8</b> Hash Functions, Random Oracles, and Bitcoin</a></li>
<li class="chapter" data-level="9" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><i class="fa fa-check"></i><b>9</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a>
<ul>
<li class="chapter" data-level="9.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#keys-from-passwords"><i class="fa fa-check"></i><b>9.1</b> Keys from passwords</a></li>
<li class="chapter" data-level="9.2" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>9.2</b> Merkle trees and verifying storage.</a></li>
<li class="chapter" data-level="9.3" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>9.3</b> Proofs of Retrievability</a></li>
<li class="chapter" data-level="9.4" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#entropy-extraction"><i class="fa fa-check"></i><b>9.4</b> Entropy extraction</a>
<ul>
<li class="chapter" data-level="9.4.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>9.4.1</b> Forward and backward secrecy</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a>
<ul>
<li class="chapter" data-level="10.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li>
<li class="chapter" data-level="10.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a>
<ul>
<li class="chapter" data-level="10.3.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li>
<li class="chapter" data-level="10.3.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li>
<li class="chapter" data-level="10.3.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li>
<li class="chapter" data-level="10.3.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li>
<li class="chapter" data-level="10.3.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li>
<li class="chapter" data-level="10.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li>
<li class="chapter" data-level="10.6" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a>
<ul>
<li class="chapter" data-level="10.6.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a>
<ul>
<li class="chapter" data-level="11.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a>
<ul>
<li class="chapter" data-level="11.1.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li>
<li class="chapter" data-level="11.1.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li>
<li class="chapter" data-level="11.1.3" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li>
<li class="chapter" data-level="11.1.4" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li>
<li class="chapter" data-level="11.1.5" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.6" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.7" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li>
</ul></li>
<li class="chapter" data-level="11.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#extending-to-more-than-one-hardcore-bit"><i class="fa fa-check"></i><b>11.2.1</b> Extending to more than one hardcore bit</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a>
<ul>
<li class="chapter" data-level="12.0.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li>
<li class="chapter" data-level="12.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li>
<li class="chapter" data-level="12.2" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li>
<li class="chapter" data-level="12.3" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li>
<li class="chapter" data-level="12.4" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li>
<li class="chapter" data-level="12.5" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li>
<li class="chapter" data-level="12.6" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html"><i class="fa fa-check"></i><b>13</b> Establishing secure connections over insecure channels</a>
<ul>
<li class="chapter" data-level="13.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>13.1</b> Cryptography’s obsession with adjectives.</a></li>
<li class="chapter" data-level="13.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>13.2</b> Basic Key Exchange protocol</a></li>
<li class="chapter" data-level="13.3" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>13.3</b> Authenticated key exchange</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>13.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>13.4</b> Chosen ciphertext attack security for public key cryptography</a></li>
<li class="chapter" data-level="13.5" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>13.5</b> CCA secure public key encryption in the Random Oracle Model</a>
<ul>
<li class="chapter" data-level="13.5.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.1</b> Defining secure authenticated key exchange</a></li>
<li class="chapter" data-level="13.5.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.2</b> The compiler approach for authenticated key exchange</a></li>
</ul></li>
<li class="chapter" data-level="13.6" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>13.6</b> Password authenticated key exchange.</a></li>
<li class="chapter" data-level="13.7" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>13.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li>
<li class="chapter" data-level="13.8" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>13.8</b> Heartbleed and logjam attacks</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html"><i class="fa fa-check"></i><b>14</b> Zero knowledge proofs</a>
<ul>
<li class="chapter" data-level="14.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>14.1</b> Applications for zero knowledge proofs.</a>
<ul>
<li class="chapter" data-level="14.1.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#nuclear-disarmament"><i class="fa fa-check"></i><b>14.1.1</b> Nuclear disarmament</a></li>
<li class="chapter" data-level="14.1.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#voting"><i class="fa fa-check"></i><b>14.1.2</b> Voting</a></li>
<li class="chapter" data-level="14.1.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#more-applications"><i class="fa fa-check"></i><b>14.1.3</b> More applications</a></li>
</ul></li>
<li class="chapter" data-level="14.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>14.2</b> Defining and constructing zero knowledge proofs</a></li>
<li class="chapter" data-level="14.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>14.3</b> Defining zero knowledge</a></li>
<li class="chapter" data-level="14.4" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>14.4</b> Zero knowledge proof for Hamiltonicity.</a>
<ul>
<li class="chapter" data-level="14.4.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#why-is-this-interesting"><i class="fa fa-check"></i><b>14.4.1</b> Why is this interesting?</a></li>
</ul></li>
<li class="chapter" data-level="14.5" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>14.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a>
<ul>
<li class="chapter" data-level="14.5.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>14.5.1</b> “Bonus features” of zero knowledge</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="chapfheone.html"><a href="chapfheone.html"><i class="fa fa-check"></i><b>15</b> Fully homomorphic encryption: Introduction and bootstrapping</a>
<ul>
<li class="chapter" data-level="15.1" data-path="chapfheone.html"><a href="chapfheone.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>15.1</b> Defining fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.1.1" data-path="chapfheone.html"><a href="chapfheone.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>15.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="chapfheone.html"><a href="chapfheone.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>15.2</b> Example: An XOR homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.2.1" data-path="chapfheone.html"><a href="chapfheone.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>15.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="chapfheone.html"><a href="chapfheone.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>15.3</b> From linear homomorphism to full homomorphism</a></li>
<li class="chapter" data-level="15.4" data-path="chapfheone.html"><a href="chapfheone.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>15.4</b> Bootstrapping: Fully Homomorphic “escape velocity”</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="chapfheone.html"><a href="chapfheone.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>15.4.1</b> Radioactive legos analogy</a></li>
<li class="chapter" data-level="15.4.2" data-path="chapfheone.html"><a href="chapfheone.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>15.4.2</b> Proving the bootstrapping theorem</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="chapfhetwo.html"><a href="chapfhetwo.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Construction</a>
<ul>
<li class="chapter" data-level="16.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>16.1</b> Prelude: from vectors to matrices</a></li>
<li class="chapter" data-level="16.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Real world partially homomorphic encryption</a></li>
<li class="chapter" data-level="16.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>16.3</b> Noise management via encoding</a></li>
<li class="chapter" data-level="16.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#putting-it-all-together"><i class="fa fa-check"></i><b>16.4</b> Putting it all together</a></li>
<li class="chapter" data-level="16.5" data-path="chapfhetwo.html"><a href="chapfhetwo.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>16.5</b> Analysis of our scheme</a>
<ul>
<li class="chapter" data-level="16.5.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#correctness"><i class="fa fa-check"></i><b>16.5.1</b> Correctness</a></li>
<li class="chapter" data-level="16.5.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#cpa-security"><i class="fa fa-check"></i><b>16.5.2</b> CPA Security</a></li>
<li class="chapter" data-level="16.5.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#homomorphism"><i class="fa fa-check"></i><b>16.5.3</b> Homomorphism</a></li>
<li class="chapter" data-level="16.5.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>16.5.4</b> Shallow decryption circuit</a></li>
</ul></li>
<li class="chapter" data-level="16.6" data-path="chapfhetwo.html"><a href="chapfhetwo.html#advanced-topics"><i class="fa fa-check"></i><b>16.6</b> Advanced topics:</a>
<ul>
<li class="chapter" data-level="16.6.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#fully-homomorphic-encryption-for-approximate-computation-over-the-real-numbers-ckks"><i class="fa fa-check"></i><b>16.6.1</b> Fully homomorphic encryption for approximate computation over the real numbers: CKKS</a></li>
<li class="chapter" data-level="16.6.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#bandwidth-efficient-fully-homomorphic-encryption-gh"><i class="fa fa-check"></i><b>16.6.2</b> Bandwidth efficient fully homomorphic encryption GH</a></li>
<li class="chapter" data-level="16.6.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#using-fully-homomorphic-encryption-to-achieve-private-information-retrieval."><i class="fa fa-check"></i><b>16.6.3</b> Using fully homomorphic encryption to achieve private information retrieval.</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="sfeonechap.html"><a href="sfeonechap.html"><i class="fa fa-check"></i><b>17</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a>
<ul>
<li class="chapter" data-level="17.1" data-path="sfeonechap.html"><a href="sfeonechap.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>17.1</b> Ideal vs. Real Model Security.</a></li>
<li class="chapter" data-level="17.2" data-path="sfeonechap.html"><a href="sfeonechap.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>17.2</b> Formally defining secure multiparty computation</a>
<ul>
<li class="chapter" data-level="17.2.1" data-path="sfeonechap.html"><a href="sfeonechap.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>17.2.1</b> First attempt: a slightly “too ideal” definition</a></li>
<li class="chapter" data-level="17.2.2" data-path="sfeonechap.html"><a href="sfeonechap.html#allowing-for-aborts"><i class="fa fa-check"></i><b>17.2.2</b> Allowing for aborts</a></li>
<li class="chapter" data-level="17.2.3" data-path="sfeonechap.html"><a href="sfeonechap.html#some-comments"><i class="fa fa-check"></i><b>17.2.3</b> Some comments:</a></li>
</ul></li>
<li class="chapter" data-level="17.3" data-path="sfeonechap.html"><a href="sfeonechap.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>17.3</b> Example: Second price auction using bitcoin</a>
<ul>
<li class="chapter" data-level="17.3.1" data-path="sfeonechap.html"><a href="sfeonechap.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>17.3.1</b> Another example: distributed and threshold cryptography</a></li>
</ul></li>
<li class="chapter" data-level="17.4" data-path="sfeonechap.html"><a href="sfeonechap.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>17.4</b> Proving the fundamental theorem:</a></li>
<li class="chapter" data-level="17.5" data-path="sfeonechap.html"><a href="sfeonechap.html#hbctomalred"><i class="fa fa-check"></i><b>17.5</b> Malicious to honest but curious reduction</a>
<ul>
<li class="chapter" data-level="17.5.1" data-path="sfeonechap.html"><a href="sfeonechap.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>17.5.1</b> Handling probabilistic strategies:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="sfetwochap.html"><a href="sfetwochap.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a>
<ul>
<li class="chapter" data-level="18.1" data-path="sfetwochap.html"><a href="sfetwochap.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li>
<li class="chapter" data-level="18.2" data-path="sfetwochap.html"><a href="sfetwochap.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.2</b> Achieving circuit privacy in a fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="18.2.1" data-path="sfetwochap.html"><a href="sfetwochap.html#bottom-line-a-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>18.2.1</b> Bottom line: A two party secure computation protocol</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="sfetwochap.html"><a href="sfetwochap.html#beyond-two-parties"><i class="fa fa-check"></i><b>18.3</b> Beyond two parties</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html"><i class="fa fa-check"></i><b>19</b> Quantum computing and cryptography I</a>
<ul>
<li class="chapter" data-level="19.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>19.1</b> The double slit experiment</a></li>
<li class="chapter" data-level="19.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-amplitudes"><i class="fa fa-check"></i><b>19.2</b> Quantum amplitudes</a>
<ul>
<li class="chapter" data-level="19.2.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>19.2.1</b> Quantum computing and computation - an executive summary.</a></li>
</ul></li>
<li class="chapter" data-level="19.3" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-101"><i class="fa fa-check"></i><b>19.3</b> Quantum 101</a>
<ul>
<li class="chapter" data-level="19.3.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>19.3.1</b> Physically realizing quantum computation</a></li>
<li class="chapter" data-level="19.3.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bra-ket-notation"><i class="fa fa-check"></i><b>19.3.2</b> Bra-ket notation</a></li>
</ul></li>
<li class="chapter" data-level="19.4" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bells-inequality"><i class="fa fa-check"></i><b>19.4</b> Bell’s Inequality</a></li>
<li class="chapter" data-level="19.5" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#analysis-of-bells-inequality"><i class="fa fa-check"></i><b>19.5</b> Analysis of Bell’s Inequality</a></li>
<li class="chapter" data-level="19.6" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#grovers-algorithm"><i class="fa fa-check"></i><b>19.6</b> Grover’s Algorithm</a></li>
</ul></li>
<li class="chapter" data-level="20" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography II</a>
<ul>
<li class="chapter" data-level="20.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>20.1</b> From order finding to factoring and discrete log</a></li>
<li class="chapter" data-level="20.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>20.2</b> Finding periods of a function: Simon’s Algorithm</a></li>
<li class="chapter" data-level="20.3" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-simon-to-shor"><i class="fa fa-check"></i><b>20.3</b> From Simon to Shor</a>
<ul>
<li class="chapter" data-level="20.3.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#the-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.1</b> The Fourier transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
<li class="chapter" data-level="20.3.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.2</b> Quantum Fourier Transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.4" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#shor鈥檚-order-finding-algorithm."><i class="fa fa-check"></i><b>20.4</b> Shor鈥檚 Order-Finding Algorithm.</a>
<ul>
<li class="chapter" data-level="20.4.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>20.4.1</b> Analysis: the case that <span class="math inline">\(r|m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.5" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>20.5</b> Rational approximation of real numbers</a>
<ul>
<li class="chapter" data-level="20.5.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-cryptography"><i class="fa fa-check"></i><b>20.5.1</b> Quantum cryptography</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="21" data-path="software-obfuscation.html"><a href="software-obfuscation.html"><i class="fa fa-check"></i><b>21</b> Software Obfuscation</a>
<ul>
<li class="chapter" data-level="21.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>21.1</b> Witness encryption</a></li>
<li class="chapter" data-level="21.2" data-path="software-obfuscation.html"><a href="software-obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>21.2</b> Deniable encryption</a></li>
<li class="chapter" data-level="21.3" data-path="software-obfuscation.html"><a href="software-obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>21.3</b> Functional encryption</a></li>
<li class="chapter" data-level="21.4" data-path="software-obfuscation.html"><a href="software-obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>21.4</b> The software patch problem</a></li>
<li class="chapter" data-level="21.5" data-path="software-obfuscation.html"><a href="software-obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>21.5</b> Software obfuscation</a></li>
<li class="chapter" data-level="21.6" data-path="software-obfuscation.html"><a href="software-obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>21.6</b> Applications of obfuscation</a></li>
<li class="chapter" data-level="21.7" data-path="software-obfuscation.html"><a href="software-obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>21.7</b> Impossibility of obfuscation</a>
<ul>
<li class="chapter" data-level="21.7.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>21.7.1</b> Proof of impossibility of VBB obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="21.8" data-path="software-obfuscation.html"><a href="software-obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>21.8</b> Indistinguishability obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html"><i class="fa fa-check"></i><b>22</b> More obfuscation, exotic encryptions</a>
<ul>
<li class="chapter" data-level="22.1" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>22.1</b> Slower, weaker, less securer</a></li>
<li class="chapter" data-level="22.2" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>22.2</b> How to get IBE from pairing based assumptions.</a></li>
<li class="chapter" data-level="22.3" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>22.3</b> Beyond pairing based cryptography</a></li>
</ul></li>
<li class="chapter" data-level="23" data-path="anonymous-communication.html"><a href="anonymous-communication.html"><i class="fa fa-check"></i><b>23</b> Anonymous communication</a>
<ul>
<li class="chapter" data-level="23.1" data-path="anonymous-communication.html"><a href="anonymous-communication.html#steganography"><i class="fa fa-check"></i><b>23.1</b> Steganography</a></li>
<li class="chapter" data-level="23.2" data-path="anonymous-communication.html"><a href="anonymous-communication.html#anonymous-routing"><i class="fa fa-check"></i><b>23.2</b> Anonymous routing</a></li>
<li class="chapter" data-level="23.3" data-path="anonymous-communication.html"><a href="anonymous-communication.html#tor"><i class="fa fa-check"></i><b>23.3</b> Tor</a></li>
<li class="chapter" data-level="23.4" data-path="anonymous-communication.html"><a href="anonymous-communication.html#telex"><i class="fa fa-check"></i><b>23.4</b> Telex</a></li>
<li class="chapter" data-level="23.5" data-path="anonymous-communication.html"><a href="anonymous-communication.html#riposte"><i class="fa fa-check"></i><b>23.5</b> Riposte</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html"><i class="fa fa-check"></i><b>24</b> Ethical, moral, and policy dimensions to cryptography</a>
<ul>
<li class="chapter" data-level="24.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>24.1</b> Reading prior to lecture:</a></li>
<li class="chapter" data-level="24.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#case-studies."><i class="fa fa-check"></i><b>24.2</b> Case studies.</a>
<ul>
<li class="chapter" data-level="24.2.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#the-snowden-revelations"><i class="fa fa-check"></i><b>24.2.1</b> The Snowden revelations</a></li>
<li class="chapter" data-level="24.2.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>24.2.2</b> FBI vs Apple case</a></li>
<li class="chapter" data-level="24.2.3" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>24.2.3</b> Juniper backdoor case and the OPM break-in</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="25" data-path="course-recap.html"><a href="course-recap.html"><i class="fa fa-check"></i><b>25</b> Course recap</a>
<ul>
<li class="chapter" data-level="25.1" data-path="course-recap.html"><a href="course-recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>25.1</b> Some things we did not cover</a></li>
<li class="chapter" data-level="25.2" data-path="course-recap.html"><a href="course-recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>25.2</b> What I hope you learned</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">A Minimal Book Example</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="public-key-cryptography" class="section level1 hasAnchor" number="10">
<h1><span class="header-section-number">10</span> Public key cryptography<a href="public-key-cryptography.html#public-key-cryptography" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>People have been dreaming about heavier-than-air flight since at least the days of Leonardo Da Vinci (not to mention Icarus from Greek mythology).
Jules Verne wrote with rather insightful details about going to the moon in 1865.
But, as far as I know, no one had considered the possibility of communicating securely without first exchanging a shared secret key until about 50 years ago. This is surprising given the thousands of years people have been using secret writing! However, in the late 1960’s and early 1970’s, several people started to question this “common wisdom”.</p>
<p>Perhaps the most surprising of these visionaries was an undergraduate student at Berkeley named Ralph Merkle. In the fall of 1974, he wrote a <a href="http://www.merkle.com/1974/">project proposal</a> for his computer security course that while</p>
<blockquote>
<p><em>“it might seem intuitively obvious that if two people have never had the opportunity to prearrange an encryption method, then they will be unable to communicate securely over an insecure channel… I believe it is false”.</em></p>
</blockquote>
<p>Merkle also felt it is important to add <em>“No. I am not joking.”</em>.
The project proposal was rejected by his professor as “not good enough”. Merkle later submitted a paper to the communication of the ACM, where he apologized for the lack of references since he was unable to find any mention of the problem in the scientific literature, and the only source where he saw the problem even <em>raised</em> was in a science fiction story.
The paper was rejected with the comment that <em>“Experience shows that it is extremely dangerous to transmit key information in the clear.”</em>
Merkle showed that one can design a protocol where Alice and Bob can use <span class="math inline">\(T\)</span> invocations of a hash function to exchange a key, but an adversary (in the random oracle model, though he of course didn’t use this name) would need roughly <span class="math inline">\(T^2\)</span> invocations to break it. He conjectured that it may be possible to obtain such protocols where breaking is <em>exponentially harder</em> than using them but could not think of any concrete way to doing so.</p>
<div class="float" id="merklefig">
<img src="../figure/merkle-proposal.png" alt="Ralph Merkle’s Berkeley CS 244 project proposal for developing public key cryptography" />
<div class="figcaption">Ralph Merkle’s Berkeley CS 244 project proposal for developing public key cryptography</div>
</div>
<p>We only found out much later that in the late 1960’s, a few years before Merkle, James Ellis of the British Intelligence agency GCHQ was <a href="http://cryptome.org/jya/ellisdoc.htm">having similar thoughts</a>.
His curiosity was spurred by an old World War II manuscript from Bell labs that suggested the following way that two people could communicate securely over a phone line. Alice would inject noise to the line, Bob would relay his messages, and then Alice would subtract the noise to get the signal. The idea is that an adversary over the line sees only the sum of Alice’s and Bob’s signals and doesn’t know what came from what. This got James Ellis thinking whether it would be possible to achieve something like that digitally. As he later recollected, in 1970 he realized that in principle this should be possible. He could think of an hypothetical black box <span class="math inline">\(B\)</span> that on input a “handle” <span class="math inline">\(\alpha\)</span> and plaintext <span class="math inline">\(p\)</span> would give a “ciphertext” <span class="math inline">\(c\)</span>. There would be a secret key <span class="math inline">\(\beta\)</span> corresponding to <span class="math inline">\(\alpha\)</span> such that feeding <span class="math inline">\(\beta\)</span> and <span class="math inline">\(c\)</span> to the box would recover <span class="math inline">\(p\)</span>. However, Ellis had no idea how to actually instantiate this box. He and others kept giving this question as a puzzle to bright new recruits until one of them, Clifford Cocks, came up in 1973 with a candidate solution loosely based on the factoring problem; in 1974 another GCHQ recruit, Malcolm Williamson, came up with a solution using modular exponentiation.</p>
<p>But among all those thinking of public key cryptography, probably the people who saw the furthest were two researchers at Stanford, Whit Diffie and Martin Hellman. They realized that with the advent of electronic communication, cryptography would find new applications beyond the military domain of spies and submarines. And they understood that in this new world of many users and point to point communication, cryptography would need to scale up. They envisioned an object which we now call “trapdoor permutation” though they called it “one way trapdoor function” or sometimes simply “public key encryption”. This is a collection of permutations <span class="math inline">\(\{ p_k \}\)</span> where <span class="math inline">\(p_k\)</span> is a permutation over (say) <span class="math inline">\(\{0,1\}^{|k|}\)</span>, and the map <span class="math inline">\((x,k)\mapsto p_k(x)\)</span> is efficiently computable <em>but</em> the reverse map <span class="math inline">\((k,y) \mapsto p_k^{-1}(y)\)</span> is computationally hard. Yet, there is also some secret key <span class="math inline">\(s(k)\)</span> (i.e., the “trapdoor”) such that using <span class="math inline">\(s(k)\)</span> it is possible to efficiently compute <span class="math inline">\(p^{-1}_k\)</span>. Their idea was that using such a trapdoor permutation, Alice who knows <span class="math inline">\(s(k)\)</span> would be able to publish <span class="math inline">\(k\)</span> on some public file such that everyone who wants to send her a message <span class="math inline">\(x\)</span> could do so by computing <span class="math inline">\(p_k(x)\)</span>. (While today we know, due to the work of Goldwasser and Micali, that such a deterministic encryption is not a good idea, at the time Diffie and Hellman had amazing intuitions but didn’t really have proper definitions of security.)
But they didn’t stop there. They realized that protecting the <em>integrity</em> of communication is no less important than protecting its <em>secrecy</em>. Thus, they imagined that Alice could “run encryption in reverse” in order to certify or <em>sign</em> messages. That is, given some message <span class="math inline">\(m\)</span>, Alice would send the value <span class="math inline">\(x=p_k^{-1}(h(m))\)</span> (for a hash function <span class="math inline">\(h\)</span>) as a way to certify that she endorses <span class="math inline">\(m\)</span>, and every person who knows <span class="math inline">\(k\)</span> could verify this by checking that <span class="math inline">\(p_k(x)=h(m)\)</span>.</p>
<p>At this point, Diffie and Hellman were in a position similar to past physicists, who predicted that a certain particle should exist but had no experimental verification. Luckily they <a href="http://cr.yp.to/bib/1988/diffie.pdf">met Ralph Merkle</a>. His ideas about a probabilistic <em>key exchange protocol</em>, together with a suggestion from their Stanford colleague <a href="https://profiles.stanford.edu/john-gill">John Gill</a>, inspired them to come up with what today is known as the <em>Diffie-Hellman Key Exchange</em> (unbeknownst to them, a similar protocol was found two years earlier at GCHQ by Malcolm Williamson). They published their paper <a href="https://www-ee.stanford.edu/~hellman/publications/24.pdf">“New Directions in Cryptography”</a> in 1976, and it is considered to have brought about the birth of modern cryptography. However, they still didn’t find their elusive trapdoor function.
This was done the next year by Rivest, Shamir and Adleman who came up with the RSA trapdoor function, which through the framework of Diffie and Hellman yielded not just encryption but also signatures (this was essentially the same function discovered earlier by Clifford Cocks at GCHQ, though as far as I can tell Cocks, Ellis and Williamson did not realize the application to digital signatures).
From this point on began a flurry of advances in cryptography which hasn’t really died down till this day.</p>
<div class="float" id="johngillfig">
<img src="../figure/john-gill.png" class="margin" alt="John T. Gill III. Gill proposed to Diffie and Hellman to use modular exponentiation as a one-way function, which (together with Merkle’s ideas) enabled what’s known today as the Diffie-Hellman Key Exchange protocol." />
<div class="figcaption">John T. Gill III. Gill proposed to Diffie and Hellman to use modular exponentiation as a one-way function, which (together with Merkle’s ideas) enabled what’s known today as the <em>Diffie-Hellman Key Exchange</em> protocol.</div>
</div>
<div id="private-key-crypto-recap" class="section level2 hasAnchor" number="10.1">
<h2><span class="header-section-number">10.1</span> Private key crypto recap<a href="public-key-cryptography.html#private-key-crypto-recap" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Before we embark on the wonderful journey to <em>public key</em> cryptography, let’s briefly look back and see what we learned about <em>private key cryptography</em>.
This material is mostly covered in Chapters 1 to 9 of the Katz Lindell (KL) book and Part I (Chapters 1-9) of the Boneh Shoup (BS) book.
Now would be a good time for you to read the corresponding proofs in one or both of these books. It is often helpful to see the same proof presented in a slightly different way.
Below is a review of some of the various reductions we saw in class, with pointers to the corresponding sections in the Katz-Lindell (2nd ed) and Boneh-Shoup books. These are also covered in <a href="https://web.engr.oregonstate.edu/~rosulekm/crypto/">Rosulek’s book</a>.</p>
<ul>
<li>Pseudorandom generators (PRG) length extension (from <span class="math inline">\(n+1\)</span> output PRG to <span class="math inline">\(poly(n)\)</span> output PRG): KL 7.4.2, BS 3.4.2</li>
<li>PRG’s to pseudorandom functions (PRF’s): KL 7.5, BS 4.6</li>
<li>PRF’s to Chosen Plaintext Attack (CPA) secure encryption: KL 3.5.2, BS 5.5</li>
<li>PRF’s to secure Message Authentication Codes (MAC’s): KL 4.3, BS 6.3</li>
<li>MAC’s + CPA secure encryption to chosen ciphertext attack (CCA) secure encryption: BS 4.5.4, BS 9.4</li>
<li>Pseudorandom permutation (PRP’s) to CPA secure encryption / block cipher modes: KL 3.5.2, KL 3.6.2, BS 4.1, 4.4, 5.4</li>
<li>Hash function applications: fingerprinting, Merkle trees, passwords: KL 5.6, BS Chapter 8</li>
<li>Coin tossing over the phone: we saw a construction in class that used a <em>commitment scheme</em> built out of a pseudorandom generator. This is shown in BS 3.12, KL 5.6.5 shows an alternative construction using random oracles.</li>
<li>PRP’s from PRF’s: we only sketched the construction which can be found in KL 7.6 or BS 4.5</li>
</ul>
<p>One major point we did <em>not</em> talk about in this course was <em>one way functions</em>. The definition of a one way function is quite simple:</p>
<blockquote>
<h1 id="owfdef" class="definition" title="One Way Functions"></h1>
<p>A function <span class="math inline">\(f:\{0,1\}^*\rightarrow\{0,1\}^*\)</span> is a <em>one way function</em> if it is efficiently computable and for every <span class="math inline">\(n\)</span> and a <span class="math inline">\(poly(n)\)</span> time adversary <span class="math inline">\(A\)</span>,
the probability over <span class="math inline">\(x\leftarrow_R\{0,1\}^n\)</span> that <span class="math inline">\(A(f(x))\)</span> outputs <span class="math inline">\(x&#39;\)</span> such that <span class="math inline">\(f(x&#39;)=f(x)\)</span> is negligible.</p>
</blockquote>
<p>The “OWF conjecture” is the conjecture that one way functions exist. It turns out to be a necessary and sufficient condition for much of private key cryptography.
That is, the following theorem is known (by combining works of many people):</p>
<div class="theorem" title="One way functions and private key cryptography">
<p><span id="thm:privkeydef" class="theorem"><strong>Theorem 10.1  </strong></span>The following are equivalent:</p>
<ul>
<li><p>One way functions exist</p></li>
<li><p>Pseudorandom generators (with non-trivial stretch) exist</p></li>
<li><p>Pseudorandom functions exist</p></li>
<li><p>CPA secure private key encryptions exist</p></li>
<li><p>CCA secure private key encryptions exist</p></li>
<li><p>Message Authentication Codes exist</p></li>
<li><p>Commitment schemes exist</p></li>
</ul>
</div>
<p>The key result in the proof of this theorem is the result of Hastad, Impagliazzo, Levin and Luby that if one way functions exist then pseudorandom generators exist.
If you are interested in finding out more, see Chapter 7 in <a href="https://people.seas.harvard.edu/~salil/pseudorandomness/">Vadhan’s pseudorandomness monograph</a>.
Sections 7.2-7.4 in the KL book also cover a special case of this theorem for the case that the one way function is a <em>permutation</em> on <span class="math inline">\(\{0,1\}^n\)</span> for every <span class="math inline">\(n\)</span>.
This proof has been considerably simplified and quantitatively improved in works of Haitner, Holenstein, Reingold, Vadhan, Wee and Zheng. See <a href="http://people.seas.harvard.edu/~salil/research/CompEnt-abs.html">this talk of Salil Vadhan</a> for more on this. See also <a href="http://www.cs.princeton.edu/courses/archive/spring08/cos598D/scribe3.pdf">these lecture notes</a> from a Princeton seminar I gave on this topic (though the proof has been simplified since then by the above works).</p>
<blockquote>
<h1 id="privkeyattacks" class="remark" title="Cryptanalytic attacks on private key cryptosystems"></h1>
<p>Another topic we did not discuss in depth is attacks on private key cryptosystems.
These attacks often work by “opening the black box” and looking at the internal operation of block ciphers or hash functions.
We then assign variables to various internal registers, and look to find collections of inputs that would satisfy some non-trivial relation between those variables. This is a rather vague description, but you can read KL Section 6.2.6 on <em>linear</em> and <em>differential</em> cryptanalysis and BS Sections 3.7-3.9 and 4.3 for more information. See also <a href="http://www.cs.tau.ac.il/~tromer/SKC2006/">this course of Adi Shamir</a>, and the courses of Dunkelman on analyzing <a href="https://www.cs.haifa.ac.il/~orrd/BlockCipherSeminar/">block ciphers</a> and <a href="https://www.cs.haifa.ac.il/~orrd/HashFuncSeminar/">hash functions</a>. There is also the fascinating area of <em>side channel</em> attacks on both public and private key crypto, see <a href="http://www.cs.tau.ac.il/~tromer/istvr1516.html">this course of Tromer</a>.</p>
</blockquote>
<blockquote>
<h1 id="signaturesrem" class="remark" title="Digital Signatures"></h1>
<p>We will discuss in this lecture <em>Digital signatures</em>, which are the public key analog of message authentication codes.
Surprisingly, despite being a “public key” object, it is possible to base digital signatures on one-way functions (this is obtained using ideas of Lamport, Merkle, Goldwasser-Goldreich-Micali, Naor-Yung, and Rompel).
However these constructions are not very efficient (and this may be inherent), and so in practice people use digital signatures that are built using similar techniques to those used for public key encryption.</p>
</blockquote>
</div>
<div id="public-key-encryptions-definition" class="section level2 hasAnchor" number="10.2">
<h2><span class="header-section-number">10.2</span> Public Key Encryptions: Definition<a href="public-key-cryptography.html#public-key-encryptions-definition" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We now discuss how we define security for public key encryption. As mentioned above,
it took quite a while for cryptographers to arrive at the “right” definition,
but in the interest of time we will skip ahead to what by now is the standard basic notion (see also <a href="" class="ref">PKCfig</a>):</p>
<div class="float" id="PKCfig">
<img src="../figure/pkenccartoon.png" class="margin" alt="In a public key encryption, the receiver Bob generates a pair of keys (e,d). The encryption key e is used for encryption, and the decryption key is used for decryption. We call it a public key system since the security of the scheme does not rely on the adversary Eve not knowing the encryption key. Hence, Bob can publicize the key e to a great many potential receivers and still ensure confidentiality of the messages he receives." />
<div class="figcaption">In a public key encryption, the receiver Bob generates a <em>pair</em> of keys <span class="math inline">\((e,d)\)</span>. The <em>encryption key</em> <span class="math inline">\(e\)</span> is used for encryption, and the <em>decryption key</em> is used for decryption. We call it a public key system since the security of the scheme does not rely on the adversary Eve not knowing the encryption key. Hence, Bob can publicize the key <span class="math inline">\(e\)</span> to a great many potential receivers and still ensure confidentiality of the messages he receives.</div>
</div>
<div class="definition" title="Valid public key encryption">
<p><span id="def:pubkeydef" class="definition"><strong>Definition 10.1  </strong></span>A triple of efficient algorithms <span class="math inline">\((G,E,D)\)</span> is a <em>public key encryption scheme</em> of length function <span class="math inline">\(\ell:\N \rightarrow \N\)</span> if it satisfies
the following:</p>
<ul>
<li><p><span class="math inline">\(G\)</span> is a probabilistic algorithm known as the <em>key generation algorithm</em> that on input <span class="math inline">\(1^n\)</span> outputs a distribution over pair of keys <span class="math inline">\((e,d)\)</span>.<br />
</p></li>
<li><p><span class="math inline">\(E\)</span> is the <em>encryption algorithm</em> that takes a pair of inputs <span class="math inline">\(e,m\)</span> with <span class="math inline">\(m\in \{0,1\}^{\ell(n)}\)</span> and outputs <span class="math inline">\(c=E_e(m)\)</span>.<br />
</p></li>
<li><p><span class="math inline">\(D\)</span> is the <em>decryption algorithm</em> that takes a pair of inputs <span class="math inline">\(d,c\)</span> and outputs <span class="math inline">\(m&#39;=D_d(c)\)</span>.<br />
</p></li>
<li><p>For every <span class="math inline">\(m\in\{0,1\}^{\ell(n)}\)</span>, with probability <span class="math inline">\(1-negl(n)\)</span> over the choice of <span class="math inline">\((e,d)\)</span> output from <span class="math inline">\(G(1^n)\)</span> and the coins of <span class="math inline">\(E\)</span>,<span class="math inline">\(D\)</span>, <span class="math inline">\(D_d(E_e(m))=m\)</span>.<br />
</p></li>
</ul>
</div>
<p><a href="" class="ref">pubkeydef</a> just refers to the <em>validity</em> of a public-key encryption scheme, namely the condition that we can encrypt and decrypt using the keys <span class="math inline">\(e\)</span> and <span class="math inline">\(d\)</span> respectively, but not to its security. The standard definition of security for public-key encryption is CPA security:</p>
<div class="definition" title="CPA security for public-key encryption">
<p><span id="def:cpasecpubkeydef" class="definition"><strong>Definition 10.2  </strong></span>We say that <span class="math inline">\((G,E,D)\)</span> is <em>CPA secure</em> if every efficient adversary <span class="math inline">\(A\)</span> wins the following game with probability at most <span class="math inline">\(1/2+negl(n)\)</span>:</p>
<ul>
<li><p><span class="math inline">\((e,d) \leftarrow_R G(1^n)\)</span></p></li>
<li><p><span class="math inline">\(A\)</span> is given <span class="math inline">\(e\)</span> and outputs a pair of messages <span class="math inline">\(m_0,m_1 \in \{0,1\}^n\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> is given <span class="math inline">\(c=E_e(m_b)\)</span> for <span class="math inline">\(b\leftarrow_R\{0,1\}\)</span>.</p></li>
<li><p><span class="math inline">\(A\)</span> outputs <span class="math inline">\(b&#39;\in\{0,1\}\)</span> and <em>wins</em> if <span class="math inline">\(b&#39;=b\)</span>.</p></li>
</ul>
</div>
<blockquote>
<h1 id="section-48" class="pause"></h1>
<p>Despite it being a “chosen plaintext attack”, we don’t explicitly give <span class="math inline">\(A\)</span> access to the encryption oracle in the public key setting.
Make sure you understand why giving it such access would not give it more power.</p>
</blockquote>
<p>One metaphor for a public key encryption is a “self-locking lock” where you don’t need the key to <em>lock it</em> (but rather you simply push the shackle until it clicks and lock), but you do need the key to <em>unlock</em> it. So, if Alice generates <span class="math inline">\((e,d)=G(1^n)\)</span>, then <span class="math inline">\(e\)</span> serves as the “lock” that can be used to <em>encrypt</em> messages for Alice while only <span class="math inline">\(d\)</span> can be used to <em>decrypt</em> the messages. Another way to think about it is that <span class="math inline">\(e\)</span> is a “hobbled key” that can be used for only some of the functions of <span class="math inline">\(d\)</span>.</p>
<div id="the-obfuscation-paradigm" class="section level3 hasAnchor" number="10.2.1">
<h3><span class="header-section-number">10.2.1</span> The obfuscation paradigm<a href="public-key-cryptography.html#the-obfuscation-paradigm" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Why would someone imagine that such a magical object could exist?
The writing of both James Ellis as well as Diffie and Hellman suggests that their thought process was roughly as follows.
You imagine a “magic black box” <span class="math inline">\(B\)</span> such that if all parties have access to <span class="math inline">\(B\)</span> then we could get a public key encryption scheme.
Now if public key encryption was impossible it would mean that for every possible program <span class="math inline">\(P\)</span> that computes the functionality of <span class="math inline">\(B\)</span>, if we distribute the code of <span class="math inline">\(P\)</span> to all parties, then we don’t get a secure encryption scheme. That means that <em>no matter what program <span class="math inline">\(P\)</span> the adversary gets</em>, she will always be able to get some information out of that code that helps break the encryption, even though she wouldn’t have been able to break it if <span class="math inline">\(P\)</span> was a black box.
Now, intuitively understanding arbitrary code is a very hard problem, so Diffie and Hellman imagined that it might be possible to take this ideal <span class="math inline">\(B\)</span> and compile it to some sufficiently low level assembly language so that it would behave as a “virtual black box”.</p>
<p>In particular, if you took, say, the encoding procedure <span class="math inline">\(m \mapsto p_k(m)\)</span> of a block cipher with a particular key <span class="math inline">\(k\)</span> and ran it through an optimizing compiler, you might hope that while it would be possible to perform this map using the resulting executable, it will be hard to extract <span class="math inline">\(k\)</span> from it. Hence, you could treat this code as a “public key”.
This suggests the following approach for getting an encryption scheme:</p>
<div class="quote">
<p><strong>“Obfuscation based public key encryption”:</strong> (Thought experiment - not an actual construction)</p>
<p><strong>Ingredients:</strong></p>
<p><em>(i)</em> A pseudorandom permutation collection <span class="math inline">\(\{ p_k \}_{k\in \{0,1\}^*}\)</span> where for every <span class="math inline">\(k\in \{0,1\}^n\)</span>, <span class="math inline">\(p_k:\{0,1\}^n \rightarrow \{0,1\}^n\)</span></p>
<p><em>(ii)</em> An “obfuscating compiler” polynomial-time computable <span class="math inline">\(O:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> such that for every circuit <span class="math inline">\(C\)</span>, <span class="math inline">\(O(C)\)</span> is a circuit that computes the same function as <span class="math inline">\(C\)</span>.</p>
<p><strong>Operation:</strong></p>
<ul>
<li><p><em>Key Generation:</em> The private key is <span class="math inline">\(k \leftarrow_R \{0,1\}^n\)</span>, the public key is <span class="math inline">\(E=O(C_k)\)</span> where <span class="math inline">\(C_k\)</span> is the circuit that maps <span class="math inline">\(x\in \{0,1\}^n\)</span> to <span class="math inline">\(p_k(x)\)</span>.</p></li>
<li><p><em>Encryption:</em> To encrypt <span class="math inline">\(m\in \{0,1\}^n\)</span> with public key <span class="math inline">\(E\)</span>, choose <span class="math inline">\(IV \leftarrow_R \{0,1\}^n\)</span> and output <span class="math inline">\((IV, E(x \oplus IV))\)</span>.</p></li>
<li><p><em>Decryption:</em> To decrypt <span class="math inline">\((IV,y)\)</span> with key <span class="math inline">\(k\)</span>, output <span class="math inline">\(IV \oplus p_k^{-1}(y)\)</span>.</p></li>
</ul>
</div>
<p>Diffie and Hellman couldn’t really find a way to make this work, but it convinced them this notion of public key is not <em>inherently impossible</em>.
This concept of compiling a program into a functionally equivalent but “inscrutable” form is known as <em>software obfuscation</em>.
It had turned out to be quite a tricky object to both define formally and achieve, but it serves as very good intuition for what can be achieved, even if, as with the random oracle, this intuition can sometimes be too optimistic. (Indeed, if software obfuscation was possible then we could obtain a “random oracle like”
hash function by taking the code of a function <span class="math inline">\(f_k\)</span> chosen from a PRF family and compiling it through an obfuscating compiler.)</p>
<p>We will not formally define obfuscators yet, but on an intuitive level it would be a compiler that takes a program <span class="math inline">\(P\)</span> and maps into a program <span class="math inline">\(P&#39;\)</span> such that:</p>
<ul>
<li><span class="math inline">\(P&#39;\)</span> is not much slower/bigger than <span class="math inline">\(P\)</span> (e.g., as a Boolean circuit it would be at most polynomially larger).</li>
<li><span class="math inline">\(P&#39;\)</span> is functionally equivalent to <span class="math inline">\(P\)</span>, i.e., <span class="math inline">\(P&#39;(x)=P(x)\)</span> for every input <span class="math inline">\(x\)</span>.<a href="#fn57" class="footnote-ref" id="fnref57"><sup>57</sup></a></li>
<li><span class="math inline">\(P&#39;\)</span> is “inscrutable” in the sense that seeing the code of <span class="math inline">\(P&#39;\)</span> is not more informative than getting <em>black box access</em> to <span class="math inline">\(P\)</span>.</li>
</ul>
<p>Let me stress again that there is no known construction of obfuscators achieving something similar to this definition.
In fact, the most natural formalization of this definition is <a href="https://www.boazbarak.org/Papers/obfuscate.pdf">impossible</a> to achieve (as we might see later in this course).
Only very recently (exciting!) progress was finally made towards obfuscators-like notions strong enough to achieve these and other applications, and there are some significant caveats, see <a href="https://eprint.iacr.org/2016/210">my survey on this topic</a> and a more recent <a href="https://www.quantamagazine.org/computer-scientists-achieve-crown-jewel-of-cryptography-20201110/">Quanta article</a>.</p>
<p>However, when trying to stretch your imagination to consider the amazing possibilities that could be achieved in cryptography, it is not a bad heuristic to first ask yourself what could be possible if only everyone involved had access to a magic black box.
It certainly worked well for Diffie and Hellman.</p>
</div>
</div>
<div id="some-concrete-candidates" class="section level2 hasAnchor" number="10.3">
<h2><span class="header-section-number">10.3</span> Some concrete candidates:<a href="public-key-cryptography.html#some-concrete-candidates" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We would have loved to prove a theorem of the form:</p>
<blockquote>
<p><strong>“Theorem”:</strong> If the PRG conjecture is true, then there exists a CPA-secure public key encryption.</p>
</blockquote>
<p>This would have meant that we do not need to assume anything more than the already minimal notion of pseudorandom generators (or equivalently, one way functions) to obtain public key cryptography.
Unfortunately, no such result is known (and this may be <a href="https://www.cs.virginia.edu/~mohammad/files/papers/MerkleFull.pdf">inherent</a>).
The kind of results we know have the following form:</p>
<blockquote>
<p><strong>Theorem:</strong> If problem <span class="math inline">\(X\)</span> is hard, then there exists a CPA-secure public key encryption.</p>
</blockquote>
<p>Here, <span class="math inline">\(X\)</span> is some problem that people have tried to solve and couldn’t.
Thus, we have various <em>candidates</em> for public key encryption, and we fervently hope that at least one of them is actually secure.
The <a href="https://eprint.iacr.org/2017/365.pdf">dirty little secret</a> of cryptography is that we actually don’t have that many candidates.
We really have only two well studied families.<a href="#fn58" class="footnote-ref" id="fnref58"><sup>58</sup></a>
One is the “group theoretic” family that relies on the difficulty of the discrete logarithm (over modular arithmetic or elliptic curves) or the integer factoring problem.
The other is the “coding/lattice theoretic” family that relies on the difficulty of solving noisy linear equations or related problems such as finding
short vectors in a <em>lattice</em> and solving instances of the “knapsack” problem.
Moreover, problems from the first family are known to be <em>efficiently solvable</em> in a computational model known as “quantum computing”.
If large scale physical devices that simulate this model, known as <em>quantum computers</em>, exist, then they could break all cryptosystems relying on these problems, and we’ll be down to only having a <em>single</em> family of candidate public key encryption schemes.</p>
<p>We will start by describing cryptosystems based on the first family (which was discovered before the other and was more widely implemented), and talk about the second family in future lectures.</p>
<div id="diffie-hellman-encryption-aka-el-gamal" class="section level3 hasAnchor" number="10.3.1">
<h3><span class="header-section-number">10.3.1</span> Diffie-Hellman Encryption (aka El-Gamal)<a href="public-key-cryptography.html#diffie-hellman-encryption-aka-el-gamal" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The Diffie-Hellman public key system is built on the presumed difficulty of the <em>discrete logarithm problem</em>:</p>
<p>For any number <span class="math inline">\(p\)</span>, let <span class="math inline">\(\mathbb{Z}_p\)</span> be the set of numbers <span class="math inline">\(\{0,\ldots,p-1\}\)</span> where addition and multiplication are done modulo <span class="math inline">\(p\)</span>.
We will think of numbers <span class="math inline">\(p\)</span> that are of magnitude roughly <span class="math inline">\(2^n\)</span>, so they can be described with about <span class="math inline">\(n\)</span> bits.
We can clearly multiply and add such numbers modulo <span class="math inline">\(p\)</span> in <span class="math inline">\(poly(n)\)</span> time.
If <span class="math inline">\(g\in \mathbb{Z}_p\)</span> and <span class="math inline">\(a\)</span> is any natural number, we can define <span class="math inline">\(g^a\)</span> to be simply <span class="math inline">\(g\cdot g \cdots g\)</span> (<span class="math inline">\(a\)</span> times).
A priori one might think that it would take <span class="math inline">\(a\cdot poly(n)\)</span> time to compute <span class="math inline">\(g^a\)</span>, which might be exponential if <span class="math inline">\(a\)</span> itself is roughly <span class="math inline">\(2^n\)</span>.
However, we can compute this in <span class="math inline">\(poly((\log a) \cdot n)\)</span> time using the <em>repeated squaring trick</em>. The idea is that if <span class="math inline">\(a=2^{\ell}\)</span>, then we can compute <span class="math inline">\(g^a\)</span> in <span class="math inline">\(\ell\)</span> by squaring <span class="math inline">\(g\)</span> <span class="math inline">\(\ell\)</span> times, and a general <span class="math inline">\(a\)</span> can be decomposed into powers of two using the binary representation.</p>
<p>The <em>discrete logarithm</em> problem is the problem of computing, given <span class="math inline">\(g,h \in \mathbb{Z}_p\)</span>, a number <span class="math inline">\(a\)</span> such that <span class="math inline">\(g^a=h\)</span>.
If such a solution <span class="math inline">\(a\)</span> exists then there is always also a solution of size at most <span class="math inline">\(p\)</span> (can you see why?) and so the solution can be represented using <span class="math inline">\(n\)</span> bits.
However, currently the best-known algorithm for computing the discrete logarithm runs in time roughly <span class="math inline">\(2^{n^{1/3}}\)</span>, which is currently prohibitively expensive when <span class="math inline">\(p\)</span> is a prime of length about <span class="math inline">\(2048\)</span> bits.<a href="#fn59" class="footnote-ref" id="fnref59"><sup>59</sup></a></p>
<p>John Gill suggested to Diffie and Hellman that modular exponentiation can be a good source for the kind of “easy-to-compute but hard-to-invert” functions they were looking for. Diffie and Hellman based a public key encryption scheme as follows:</p>
<ul>
<li>The <em>key generation algorithm</em>, on input <span class="math inline">\(n\)</span>, samples a prime number <span class="math inline">\(p\)</span> of <span class="math inline">\(n\)</span> bits description (i.e., between <span class="math inline">\(2^{n-1}\)</span> to <span class="math inline">\(2^n\)</span>), a number <span class="math inline">\(g\leftarrow_R \mathbb{Z}_p\)</span> and <span class="math inline">\(a \leftarrow_R \{0,\ldots,p-1\}\)</span>. We also sample a hash function <span class="math inline">\(H:\{0,1\}^n\rightarrow\{0,1\}^\ell\)</span>. The public key <span class="math inline">\(e\)</span> is <span class="math inline">\((p,g,g^a,H)\)</span>, while the secret key <span class="math inline">\(d\)</span> is <span class="math inline">\(a\)</span>.<a href="#fn60" class="footnote-ref" id="fnref60"><sup>60</sup></a></li>
</ul>
<ul>
<li><p>The <em>encryption algorithm</em>, on input a message <span class="math inline">\(m \in \{0,1\}^\ell\)</span> and a public key <span class="math inline">\(e=(p,g,h,H)\)</span>, will choose a random <span class="math inline">\(b\leftarrow_R \{0,\ldots,p-1\}\)</span> and output <span class="math inline">\((g^b,H(h^b)\oplus m)\)</span>.</p></li>
<li><p>The <em>decryption algorithm</em>, on input a ciphertext <span class="math inline">\((f,y)\)</span> and the secret key, will output <span class="math inline">\(H(f^a) \oplus y\)</span>.</p></li>
</ul>
<p>The correctness of the decryption algorithm follows from the fact that <span class="math inline">\((g^a)^b = (g^b)^a = g^{ab}\)</span> and hence <span class="math inline">\(H(h^b)\)</span> computed by the encryption algorithm is the same as the value <span class="math inline">\(H(f^a)\)</span> computed by the decryption algorithm. A simple relation between the discrete logarithm and the Diffie-Hellman system is the following:</p>
<blockquote>
<h1 id="dhinseclem" class="lemma"></h1>
<p>If there is a polynomial time algorithm for the discrete logarithm problem, then the Diffie-Hellman system is <em>insecure</em>.</p>
</blockquote>
<blockquote>
<h1 id="section-49" class="proof"></h1>
<p>Using a discrete logarithm algorithm, we can compute the private key <span class="math inline">\(a\)</span> from the parameters <span class="math inline">\(p,g,g^a\)</span> present in the public key, and clearly once we know the private key we can decrypt any message of our choice.</p>
</blockquote>
<p>Unfortunately, no such result is known in the other direction. However, we can prove that this protocol is secure in the random-oracle model, under the assumption that the task of computing <span class="math inline">\(g^{ab}\)</span> from <span class="math inline">\(g^a\)</span> and <span class="math inline">\(g^b\)</span> (which is now known as the <em>Diffie-Hellman problem</em>) is hard.</p>
<blockquote>
<p><strong>Computational Diffie-Hellman Assumption:</strong> Let <span class="math inline">\(\mathbb{G}\)</span> be a group whose elements can be described in <span class="math inline">\(n\)</span> bits, with an associative and commutative multiplication operation that can be computed in <span class="math inline">\(poly(n)\)</span> time. The <em>Computational Diffie-Hellman (CDH)</em> assumption holds with respect to the group <span class="math inline">\(\mathbb{G}\)</span> if for every generator (see below) <span class="math inline">\(g\)</span> of <span class="math inline">\(\mathbb{G}\)</span> and efficient algorithm <span class="math inline">\(A\)</span>, the probability that on input <span class="math inline">\(g,g^a,g^b\)</span>, <span class="math inline">\(A\)</span> outputs the element <span class="math inline">\(g^{ab}\)</span> is negligible as a function of <span class="math inline">\(n\)</span>.<a href="#fn61" class="footnote-ref" id="fnref61"><sup>61</sup></a></p>
</blockquote>
<p>In particular we can make the following conjecture:</p>
<blockquote>
<p><strong>Computational Diffie-Hellman Conjecture for mod prime groups:</strong> For a random <span class="math inline">\(n\)</span>-bit prime and random <span class="math inline">\(g \in \mathbb{Z}_p\)</span>, the CDH holds with respect to the group <span class="math inline">\(\mathbb{G} = \{ g^a \mod p \;| a\in \mathbb{Z} \}\)</span>.</p>
</blockquote>
<p>That is, for every polynomial <span class="math inline">\(q:\N \rightarrow \N\)</span>, if <span class="math inline">\(n\)</span> is large enough, then with probability at least <span class="math inline">\(1-1/q(n)\)</span> over the choice of a uniform prime <span class="math inline">\(p\in [2^n]\)</span> and <span class="math inline">\(g\in \mathbb{Z}_p\)</span>, for every circuit <span class="math inline">\(A\)</span> of size at most <span class="math inline">\(q(n)\)</span>, the probability that <span class="math inline">\(A(g,p,g^a,g^b)\)</span> outputs <span class="math inline">\(h\)</span> such that <span class="math inline">\(g^{ab} = h \mod p\)</span> is at most <span class="math inline">\(1/q(n)\)</span> where the probability is taken over <span class="math inline">\(a,b\)</span> chosen at random in <span class="math inline">\(\mathbb{Z}_p\)</span>. (In practice people often take <span class="math inline">\(g\)</span> to be a generator of a group significantly smaller in size than <span class="math inline">\(p\)</span>, which enables <span class="math inline">\(a,b\)</span> to be smaller numbers and hence multiplication to be more efficient; we ignore this optimization in our discussions.)</p>
<blockquote>
<h1 id="section-50" class="pause"></h1>
<p>Please take your time to re-read the following conjecture until you are sure you understand what it means. Victor Shoup’s excellent and online available book <a href="http://www.shoup.net/ntb/">A Computational Introduction to Number Theory and Algebra</a> has an in depth treatment of groups, generators, and the discrete log and Diffie-Hellman problem. See also Chapters 10.4 and 10.5 in the Boneh-Shoup book, and Chapters 8.3 and 11.4 in the Katz-Lindell book. There are also solved group theory exercises at the end of this chapter.</p>
</blockquote>
<blockquote>
<h1 id="DHROMthm" class="theorem" title="Diffie-Hellman security in Random Oracle Model"></h1>
<p>Suppose that the Computational Diffie-Hellman Conjecture for mod prime groups is true. Then, the Diffie-Hellman public key encryption is CPA secure in the random oracle model.</p>
</blockquote>
<div class="proof" data-ref="DHROMthm">
<p><span id="unlabeled-div-25" class="proof"><em>Proof</em>. </span>For CPA security we need to prove that (for fixed <span class="math inline">\(\mathbb{G}\)</span> of size <span class="math inline">\(p\)</span> and random oracle <span class="math inline">\(H\)</span>) the following two distributions are computationally indistinguishable for every two strings <span class="math inline">\(m,m&#39; \in \{0,1\}^\ell\)</span>:</p>
<ul>
<li><p><span class="math inline">\((g^a,g^b,H(g^{ab})\oplus m)\)</span> for <span class="math inline">\(a,b\)</span> chosen uniformly and independently in <span class="math inline">\(\mathbb{Z}_{p}\)</span>.</p></li>
<li><p><span class="math inline">\((g^a,g^b,H(g^{ab})\oplus m&#39;)\)</span> for <span class="math inline">\(a,b\)</span> chosen uniformly and independently in <span class="math inline">\(\mathbb{Z}_{p}\)</span>.</p></li>
</ul>
<p>(can you see why this implies CPA security? you should pause here and verify this!)</p>
<p>We make the following claim:</p>
<p><strong>CLAIM:</strong> For a fixed <span class="math inline">\(\mathbb{G}\)</span> of size <span class="math inline">\(p\)</span>, generator <span class="math inline">\(g\)</span> for <span class="math inline">\(\mathbb{G}\)</span>, and given random oracle <span class="math inline">\(H\)</span>, if there is a size <span class="math inline">\(T\)</span> distinguisher <span class="math inline">\(A\)</span> with <span class="math inline">\(\epsilon\)</span> advantage between the distribution <span class="math inline">\((g^a,g^b,H(g^{ab}))\)</span> and the distribution <span class="math inline">\((g^a,g^b,U_\ell)\)</span> (where <span class="math inline">\(a,b\)</span> are chosen uniformly and independently in <span class="math inline">\(\mathbb{Z}_{p}\)</span>), then there is a size <span class="math inline">\(poly(T)\)</span> algorithm <span class="math inline">\(A&#39;\)</span> to solve the Diffie-Hellman problem with respect to <span class="math inline">\(\mathbb{G},g\)</span> with success at least <span class="math inline">\(\epsilon\)</span>. That is, for random <span class="math inline">\(a,b \in \mathbb{Z}_p\)</span>, <span class="math inline">\(A&#39;(g,g^a,g^b)=g^{ab}\)</span> with probability at least <span class="math inline">\(\epsilon/(2T)\)</span>.</p>
<p><strong>Proof of claim:</strong> The proof is simple. We claim that under the assumptions above, <span class="math inline">\(A\)</span> makes the query <span class="math inline">\(g^{ab}\)</span> to its oracle <span class="math inline">\(H\)</span> with probability at least <span class="math inline">\(\epsilon/2\)</span> since otherwise, by the “lazy evaluation” paradigm, we can assume that <span class="math inline">\(H(g^{ab})\)</span> is chosen independently at random after <span class="math inline">\(A\)</span>’s attack is completed and hence (conditioned on the adversary not making that query), the value <span class="math inline">\(H(g^{ab})\)</span> is indistinguishable from a uniform output.
Therefore, on input <span class="math inline">\(g,g^a,g^b\)</span>, <span class="math inline">\(A&#39;\)</span> can simulate <span class="math inline">\(A\)</span> and simply output one of the at most <span class="math inline">\(T\)</span> queries that <span class="math inline">\(A\)</span> makes to <span class="math inline">\(H\)</span> at random and will be successful with probability at least <span class="math inline">\(\epsilon/(2T)\)</span>.</p>
<p>Now given the claim, we can complete the proof of security via the following hybrids. Define the following “hybrid” distributions (where in all cases <span class="math inline">\(a,b\)</span> are chosen uniformly and independently in <span class="math inline">\(\mathbb{Z}_{p}\)</span>):</p>
<ul>
<li><p><span class="math inline">\(H_0\)</span>: <span class="math inline">\((g^a,g^b,H(g^{ab}) \oplus m)\)</span></p></li>
<li><p><span class="math inline">\(H_1\)</span>: <span class="math inline">\((g^a,g^b,U_\ell \oplus m)\)</span></p></li>
<li><p><span class="math inline">\(H_2\)</span>: <span class="math inline">\((g^a,g^b,U_\ell \oplus m&#39;)\)</span></p></li>
<li><p><span class="math inline">\(H_3\)</span>: <span class="math inline">\((g^a,g^b,H(g^{ab}) \oplus m&#39;)\)</span></p></li>
</ul>
<p>The claim implies that <span class="math inline">\(H_0 \approx H_1\)</span>. Indeed otherwise we could transform a distinguisher <span class="math inline">\(T\)</span> between <span class="math inline">\(H_0\)</span> and <span class="math inline">\(H_1\)</span> to a distinguisher <span class="math inline">\(T&#39;\)</span>, violating the claim by letting <span class="math inline">\(T&#39;(h,h&#39;,z) = T(h,h&#39;,z \oplus m)\)</span>.</p>
<p>The distributions <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span> are <em>identical</em> by the same argument as the security of the one time pad (since <span class="math inline">\(U_\ell \oplus m\)</span> is identical to <span class="math inline">\(U_\ell\)</span>).</p>
<p>The distributions <span class="math inline">\(H_2\)</span> and <span class="math inline">\(H_3\)</span> are computationally indistinguishable by the same argument that <span class="math inline">\(H_0 \approx H_1\)</span>.</p>
<p>Together these imply that <span class="math inline">\(H_0 \approx H_3\)</span> which yields the CPA security of the scheme.</p>
</div>
<div class="remark" title="Decisional Diffie Hellman">
<p><span id="ddhrem" class="remark"><em>Remark</em>. </span>One can get security results for this protocol without a random oracle if we assume a stronger variant known as the <em>Decisional Diffie-Hellman (DDH)</em> assumption: for a random <span class="math inline">\(a,b, u \in \mathbb{Z}_p\)</span> (prime <span class="math inline">\(p\)</span>), the triple <span class="math inline">\((g^a, g^b, g^{ab})\approx (g^a, g^b, g^u)\)</span>. This implies CDH (can you see why?). DDH also restricts our focus to groups of prime order. In particular, DDH does not hold in even-order groups. For example, DDH does not hold in <span class="math inline">\(\mathbb{Z}^{\*}_p=\{1,2\ldots p-1\}\)</span> (with group operation multiplication mod <span class="math inline">\(p\)</span>) since half of its elements are quadratic residues <em>and</em> it is efficient to test if an element is a quadratic residue using Fermat鈥檚 little theorem (can you see why? See Exercise 10.7). However, DDH holds in subgroups of <span class="math inline">\(\mathbb{Z}^{\*}_p\)</span> of prime order. If <span class="math inline">\(p\)</span> is a safe prime (i.e. <span class="math inline">\(p=2q+1\)</span> for a prime <span class="math inline">\(q\)</span>), then we can instead use the subgroup of quadratic residues, which has prime order <span class="math inline">\(q\)</span>. See Boneh-Shoup 10.4.1 for more details on the underlying groups for CDH and DDH.</p>
</div>
<blockquote>
<h1 id="curverem" class="remark" title="Elliptic curve cryptography"></h1>
<p>As mentioned, the Diffie-Hellman systems can be run with many variants of Abelian groups. Of course, for some of those groups the discrete logarithm problem might be easy, and so they would be inappropriate to use for this system. One variant that has been proposed is <a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic curve cryptography</a>. This is a group consisting of points of the form <span class="math inline">\((x,y,z)\in \mathbb{Z}_p^3\)</span> that satisfy a certain equation, where multiplication can be defined in a certain way. The main advantage of elliptic curve cryptography is that the best known algorithms run in time <span class="math inline">\(2^{\approx n}\)</span> as opposed to <span class="math inline">\(2^{\approx n^{1/3}}\)</span>, which allows for much shorter keys. Unfortunately, elliptic curve cryptography is just as susceptible to quantum algorithms as the discrete logarithm problem over <span class="math inline">\(\mathbb{Z}_p\)</span>.</p>
</blockquote>
<blockquote>
<h1 id="DHKErem" class="remark" title="Encryption vs Key Exchange and ElGamal"></h1>
<p>In most of the cryptography literature the protocol above is called the <em>Diffie-Hellman Key Exchange</em> protocol, and when considered as a public key system it is sometimes known as <em>ElGamal encryption</em>.<a href="#fn62" class="footnote-ref" id="fnref62"><sup>62</sup></a>
The reason for this mostly stems from the early confusion on what the right security definitions are.
Diffie and Hellman thought of encryption as a <em>deterministic</em> process and so they called their scheme a “key exchange protocol”.
The work of Goldwasser and Micali showed that encryption must be probabilistic for security.
Also, because of efficiency considerations, these days public key encryption is mostly used as a mechanism to exchange a key for a private key encryption that is then used for the bulk of the communication.
Together this means that there is not much point in distinguishing between a two-message key exchange algorithm and a public key encryption.</p>
</blockquote>
</div>
<div id="sampling-random-primes" class="section level3 hasAnchor" number="10.3.2">
<h3><span class="header-section-number">10.3.2</span> Sampling random primes<a href="public-key-cryptography.html#sampling-random-primes" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To sample a random <span class="math inline">\(n\)</span> bit prime, one can sample a random number <span class="math inline">\(0 \leq p &lt; 2^n\)</span> and then test if <span class="math inline">\(p\)</span> is prime.
If it is not prime, then we can sample a new random number again.
To make this work we need to show two properties:</p>
<p><em>Efficient testing:</em> That there is a <span class="math inline">\(poly(n)\)</span> time algorithm to test whether an <span class="math inline">\(n\)</span> bit number is a prime. It turns out that there are such <a href="https://en.wikipedia.org/wiki/Primality_test">known algorithms</a>. <em>Randomized</em> algorithm have been known since the 1970’s. Moreover in a 2002 breakthrough, <a href="https://goo.gl/nycWFA">Manindra Agrawal, Neeraj Kayal, and Nitin Saxena</a> (a professor and two undergraduate students from the Indian Institute of Technology Kanpur) came up with the first deterministic polynomial time algorithm for testing primality.</p>
<p><em>Prime density:</em> That the probability that a random <span class="math inline">\(n\)</span> bit number is prime is at least <span class="math inline">\(1/poly(n)\)</span>. This probability is in fact <span class="math inline">\(1/\ln(2^n)=\Omega(1/n)\)</span> by the <a href="https://goo.gl/ChrXJY">Prime Number Theorem</a>. However, for the sake of completeness, we sketch below a simple argument showing the probability is at least <span class="math inline">\(\Omega(1/n^2)\)</span>.</p>
<blockquote>
<h1 id="primedensitylem" class="lemma"></h1>
<p>The number of primes between <span class="math inline">\(1\)</span> and <span class="math inline">\(N\)</span> is <span class="math inline">\(\Omega(N/\log N)\)</span>.</p>
</blockquote>
<div class="proof" data-ref="primedensitylem">
<p><span id="unlabeled-div-26" class="proof"><em>Proof</em>. </span>Recall that the <em>least common multiple (LCM)</em> of two or more <span class="math inline">\(a_1,\ldots,a_t\)</span> is the smallest number that is a multiple of all of the <span class="math inline">\(a_i\)</span>’s.
One way to compute the LCM of <span class="math inline">\(a_1,\ldots,a_t\)</span> is to take the prime factorizations of all the <span class="math inline">\(a_i\)</span>’s, and then the LCM is the product of all the primes that appear in these factorizations, each taken to the corresponding highest power that appears in the factorization.
Let <span class="math inline">\(k\)</span> be the number of primes between <span class="math inline">\(1\)</span> and <span class="math inline">\(N\)</span>.
The lemma will follow from the following two claims:</p>
<p><strong>CLAIM 1:</strong> <span class="math inline">\(LCM(1,\ldots,N) \leq N^k\)</span>.</p>
<p><strong>CLAIM 2:</strong> If <span class="math inline">\(N\)</span> is odd, then <span class="math inline">\(LCM(1,\ldots,N) \geq 2^{N-1}\)</span>.</p>
<p>The two claims immediately imply the result, since they imply that <span class="math inline">\(2^{N-1} \leq N^k\)</span>, and taking logs we get that <span class="math inline">\(N-1 \leq k \log N\)</span> or <span class="math inline">\(k \geq (N-1)/\log N\)</span>.
(We can assume that <span class="math inline">\(N\)</span> is odd without of loss of generality, since changing from <span class="math inline">\(N\)</span> to <span class="math inline">\(N+1\)</span> can change the number of primes by at most one.)
Thus, all that is left is to prove the two claims.</p>
<p><strong>Proof of CLAIM 1:</strong> Let <span class="math inline">\(p_1,\ldots,p_k\)</span> be all the prime numbers between <span class="math inline">\(1\)</span> and <span class="math inline">\(N\)</span>, and let <span class="math inline">\(e_i\)</span> be the largest integer such that <span class="math inline">\(p_i^{e_i} \leq N\)</span> and <span class="math inline">\(L = p_1^{e_1} \cdots p_k^{e_k}\)</span>. Since <span class="math inline">\(L\)</span> is the product of <span class="math inline">\(k\)</span> terms, each of size at most <span class="math inline">\(N\)</span>, <span class="math inline">\(L \leq N^k\)</span>. But we claim that every number <span class="math inline">\(1 \leq a \leq N\)</span> divides <span class="math inline">\(L\)</span>. Indeed, every prime <span class="math inline">\(p\)</span> in the prime factorization of <span class="math inline">\(a\)</span> is one of the <span class="math inline">\(p_i\)</span>’s, and since <span class="math inline">\(a \leq N\)</span>, the power in which <span class="math inline">\(p\)</span> appears in <span class="math inline">\(a\)</span> is at most <span class="math inline">\(e_i\)</span>. By the definition of the least common multiple, this means that <span class="math inline">\(LCM(1,\ldots,N) \leq L\)</span>. QED (CLAIM 1)</p>
<p><strong>Proof of CLAIM 2:</strong> Consider the integral <span class="math inline">\(I=\int_0^1 x^{(N-1)/2}(1-x)^{(N-1)/2} dx\)</span>.
This is clearly some positive number and so <span class="math inline">\(I&gt;0\)</span>.
On one hand, for every <span class="math inline">\(x\)</span> between zero and one, <span class="math inline">\(x(1-x) \leq 1/4\)</span> and hence <span class="math inline">\(I\)</span> is at most <span class="math inline">\(4^{-(N-1)/2}=2^{-N+1}\)</span>.
On the other hand, the polynomial <span class="math inline">\(x^{(N-1)/2}(1-x)^{(N-1)/2}\)</span> is some polynomial of degree at most <span class="math inline">\(N-1\)</span> with integer coefficients, and so <span class="math inline">\(I=\sum_{k=0}^{N-1} C_k \int_0^1 x^k dx\)</span> for some integer coefficients <span class="math inline">\(C_0,\ldots,C_{N-1}\)</span>.
Since <span class="math inline">\(\int_0^1 x^k dx = \tfrac{1}{k+1}\)</span>, we see that <span class="math inline">\(I\)</span> is a sum of fractions with integer numerators and with denominators that are at most <span class="math inline">\(N\)</span>.
Since all the denominators are at most <span class="math inline">\(N\)</span> and <span class="math inline">\(I&gt;0\)</span>, it follows that <span class="math inline">\(I \geq \tfrac{1}{LCM(1,\ldots,N)}\)</span>, and so
<span class="math display">\[2^{-N+1} \geq I \geq \tfrac{1}{LCM(1,\ldots,N)}\]</span>
which implies <span class="math inline">\(LCM(1,\ldots,N) \leq 2^{N-1}\)</span>. QED (CLAIM 2 and hence lemma)</p>
</div>
</div>
<div id="a-little-bit-of-group-theory." class="section level3 hasAnchor" number="10.3.3">
<h3><span class="header-section-number">10.3.3</span> A little bit of group theory.<a href="public-key-cryptography.html#a-little-bit-of-group-theory." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If you haven’t seen group theory, it might be useful for you to do a quick review. We will not use much group theory and mostly use the theory of finite commutative (also known as Abelian) groups (in fact often <em>cyclic</em>) which are such a baby version that it might not be considered true “group theory” by many group theorists.
Shoup’s <a href="http://www.shoup.net/ntb/">excellent book</a> contains everything we need to know (and much more than that).
What you need to remember is the following:</p>
<ul>
<li><p>A <em>finite commutative group</em> <span class="math inline">\(\mathbb{G}\)</span> is a finite set together with a multiplication operation that satisfies <span class="math inline">\(a\cdot b = b\cdot a\)</span> and <span class="math inline">\((a\cdot b)\cdot c = a\cdot (b\cdot c)\)</span>.</p></li>
<li><p><span class="math inline">\(\mathbb{G}\)</span> has a special element known as <span class="math inline">\(1\)</span>, where <span class="math inline">\(g1=1g=g\)</span> for every <span class="math inline">\(g\in\mathbb{G}\)</span> and for every <span class="math inline">\(g\in \mathbb{G}\)</span> there exists an element <span class="math inline">\(g^{-1}\in \mathbb{G}\)</span> such that <span class="math inline">\(gg^{-1}=1\)</span>.</p></li>
<li><p>For every <span class="math inline">\(g\in \mathbb{G}\)</span>, the <em>order</em> of <span class="math inline">\(g\)</span>, denoted <span class="math inline">\(order(g)\)</span>, is the smallest positive integer <span class="math inline">\(a\)</span> such that <span class="math inline">\(g^a=1\)</span>.</p></li>
</ul>
<p>The following basic facts are all not too hard to prove and would be useful exercises:</p>
<ul>
<li><p>For every <span class="math inline">\(g\in \mathbb{G}\)</span>, the map <span class="math inline">\(a \mapsto g^a\)</span> is a <span class="math inline">\(k\)</span> to <span class="math inline">\(1\)</span> map from <span class="math inline">\(\{0,\ldots,|\mathbb{G}|-1\}\)</span> to <span class="math inline">\(\mathbb{G}\)</span> where <span class="math inline">\(k=|\mathbb{G}|/order(g)\)</span>. See footnote for hint.<a href="#fn63" class="footnote-ref" id="fnref63"><sup>63</sup></a></p></li>
<li><p>As a corollary, the order of <span class="math inline">\(g\)</span> is always a divisor of <span class="math inline">\(|\mathbb{G}|\)</span>. This is a special case of a more general phenomenon: the set <span class="math inline">\(\{ g^a \;|\; a\in\mathbb{Z} \}\)</span> is a subset of the group <span class="math inline">\(\mathbb{G}\)</span> that is closed under multiplication, and such subsets are known as <em>subgroups</em> of <span class="math inline">\(\mathbb{G}\)</span>. It is not hard to show (using the same approach as above) that for every group <span class="math inline">\(\mathbb{G}\)</span> and subgroup <span class="math inline">\(\mathbb{H}\)</span>, the size of <span class="math inline">\(\mathbb{H}\)</span> divides the size of <span class="math inline">\(\mathbb{G}\)</span>. This is known as <a href="https://goo.gl/Q9VSqn">Lagrange’s Theorem</a> in group theory.</p></li>
<li><p>An element <span class="math inline">\(g\)</span> of <span class="math inline">\(\mathbb{G}\)</span> is called a <em>generator</em> if <span class="math inline">\(order(g)=|\mathbb{G}|\)</span>. A group is called <em>cyclic</em> if it has a generator. If <span class="math inline">\(\mathbb{G}\)</span> is cyclic then there is a (not necessarily efficiently computable) <em>isomorphism</em> <span class="math inline">\(\phi:\mathbb{G}\rightarrow\mathbb{Z}_{|\mathbb{G}|}\)</span> which is a one-to-one and onto map satisfying <span class="math inline">\(\phi(g\cdot h)=\phi(g)+\phi(h)\)</span> for every <span class="math inline">\(g,h\in\mathbb{G}\)</span>.</p></li>
</ul>
<p>When using a group <span class="math inline">\(\mathbb{G}\)</span> for the Diffie-Hellman protocol, we want the property that <span class="math inline">\(g\)</span> is a <em>generator</em> of the group, which also means that the map <span class="math inline">\(a \mapsto g^a\)</span> is a one-to-one mapping from <span class="math inline">\(\{0,\ldots,|\mathbb{G}|-1\}\)</span> to <span class="math inline">\(\mathbb{G}\)</span>.
This can be efficiently tested if we know the order of the group and its factorization, since it will occur if and only if <span class="math inline">\(g^a \neq 1\)</span> for every <span class="math inline">\(a&lt;|\mathbb{G}|\)</span> (can you see why this holds?) and we know that if <span class="math inline">\(g^a=1\)</span> then <span class="math inline">\(a\)</span> must divide <span class="math inline">\(\mathbb{G}\)</span> (and this?).<br />
It is not hard to show that a random element <span class="math inline">\(g\in \mathbb{G}\)</span> will be a generator with non-trivial probability (for similar reasons that a random number is prime with non-trivial probability). Hence, an approach to getting such a generator is to simply choose <span class="math inline">\(g\)</span> at random and test that <span class="math inline">\(g^a \neq 1\)</span> for all of the fewer than <span class="math inline">\(\log |\mathbb{G}|\)</span> numbers that are obtained by taking <span class="math inline">\(|\mathbb{G}|/q\)</span> where <span class="math inline">\(q\)</span> is a factor of <span class="math inline">\(|\mathbb{G}|\)</span>.</p>
<blockquote>
<h1 id="section-51" class="pause"></h1>
<p>Try to stop here and verify all the facts on groups mentioned above. There are additional group theory exercises at the end of the chapter as well.</p>
</blockquote>
</div>
<div id="digital-signatures" class="section level3 hasAnchor" number="10.3.4">
<h3><span class="header-section-number">10.3.4</span> Digital Signatures<a href="public-key-cryptography.html#digital-signatures" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Public key encryption solves the <em>confidentiality</em> problem, but we still need to solve the <em>authenticity</em> or <em>integrity</em> problem, which might be even more important in practice. That is, suppose Alice wants to endorse a message <span class="math inline">\(m\)</span> that <em>everyone</em> can verify, but only she can sign.
This of course is extremely widely used in many settings, including software updates, web pages, financial transactions, and more.</p>
<div class="definition" title="Digital Signatures and CMA security">
<p><span id="def:sigsdef" class="definition"><strong>Definition 10.3  </strong></span>A triple of algorithms <span class="math inline">\((G,S,V)\)</span> is a chosen-message-attack secure <em>digital signature scheme</em> if it satisfies the following:</p>
<ul>
<li><p>On input <span class="math inline">\(1^n\)</span>, the probabilistic <em>key generation</em> algorithm <span class="math inline">\(G\)</span> outputs a pair <span class="math inline">\((s,v)\)</span> of keys, where <span class="math inline">\(s\)</span> is the private <em>signing key</em> and <span class="math inline">\(v\)</span> is the public <em>verification</em> key.</p></li>
<li><p>On input a message <span class="math inline">\(m\)</span> and the signing key <span class="math inline">\(s\)</span>, the signing algorithm <span class="math inline">\(S\)</span> outputs a string <span class="math inline">\(\sigma = S_{s}(m)\)</span> such that with probability <span class="math inline">\(1-negl(n)\)</span>, <span class="math inline">\(V_v(m,S_s(m))=1\)</span>.</p></li>
<li><p>Every efficient adversary <span class="math inline">\(A\)</span> wins the following game with at most negligible probability:</p>
<ol style="list-style-type: decimal">
<li><p>The keys <span class="math inline">\((s,v)\)</span> are chosen by the key generation algorithm.</p></li>
<li><p>The adversary gets the inputs <span class="math inline">\(1^n\)</span>, <span class="math inline">\(v\)</span>, and black box access to the signing algorithm <span class="math inline">\(S_s(\cdot)\)</span>.</p></li>
<li><p>The adversary <em>wins</em> if they output a pair <span class="math inline">\((m^*,\sigma^*)\)</span> such that <span class="math inline">\(m^*\)</span> was <em>not</em> queried before to the signing algorithm and <span class="math inline">\(V_v(m^*,\sigma^*)=1\)</span>.</p></li>
</ol></li>
</ul>
</div>
<div class="remark" title="Strong unforgeability">
<p><span id="strongunforgabilitysigrem" class="remark"><em>Remark</em>. </span>Just like for MACs (see <a href="" class="ref">MACdef</a>), our definition of security for digital signatures with respect to a chosen message attack does not preclude the ability of the adversary to produce a new signature for the same message that it has seen a signature of.
Just like in MACs, people sometimes consider the notion of <em>strong unforgeability</em> which requires that it would not be possible for the adversary to produce a new message-signature pair (even if the message itself was queried before).
Some signature schemes (such as the full domain hash and the DSA scheme) satisfy this stronger notion while others do not.
However, just like MACs, it is possible to transform any signature with standard security into a signature that satisfies this stronger unforgeability condition.</p>
</div>
</div>
<div id="the-digital-signature-algorithm-dsa" class="section level3 hasAnchor" number="10.3.5">
<h3><span class="header-section-number">10.3.5</span> The Digital Signature Algorithm (DSA)<a href="public-key-cryptography.html#the-digital-signature-algorithm-dsa" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The Diffie-Hellman protocol can be turned into a signature scheme.
This was first done by ElGamal, and a variant of his scheme was developed by the NSA and standardized by NIST as the Digital Signature Algorithm (DSA) standard. When based on an elliptic curve this is known as ECDSA.
The starting point is the following generic idea of how to turn an encryption scheme into an <em>identification protocol</em>.</p>
<p>If Alice published a public encryption key <span class="math inline">\(e\)</span>, then one natural approach for Alice to prove her identity to Bob is as follows.
Bob will send an encryption <span class="math inline">\(c=E_e(x)\)</span> of some random message <span class="math inline">\(x \leftarrow_R \{0,1\}^n\)</span> to Alice, and Alice will send <span class="math inline">\(x&#39;=D_d(c)\)</span> back.
If <span class="math inline">\(x=x&#39;\)</span>, then she has proven that she can decrypt ciphertexts encrypted with <span class="math inline">\(e\)</span>, and so Bob can be assured that she is the rightful owner of the public key <span class="math inline">\(e\)</span>.</p>
<p>However, this falls short of a signature scheme in two aspects:</p>
<ul>
<li><p>This is only an identification protocol and does not allow Alice to endorse a particular message <span class="math inline">\(m\)</span>.</p></li>
<li><p>This is an <em>interactive</em> protocol, and so Alice cannot generate a static signature based on <span class="math inline">\(m\)</span> that can be verified by any party without further interaction.</p></li>
</ul>
<p>The first issue is not so significant, since we can always have the ciphertext be an encryption of <span class="math inline">\(x=H(m)\)</span> where <span class="math inline">\(H\)</span> is some hash function presumed to behave
as a random oracle. (We do <em>not</em> want to simply run this protocol with <span class="math inline">\(x=m\)</span>. Can you see why?)</p>
<p>The second issue is more serious.
We could imagine Alice trying to run this protocol on her own by generating the ciphertext and then decrypting it, and then sending over the transcript to Bob.
But this does not really prove that she knows the corresponding private key.
After all, even without knowing <span class="math inline">\(d\)</span>, any party can generate a ciphertext <span class="math inline">\(c\)</span> and its corresponding decryption.
The idea behind the DSA protocol is that we require Alice to generate a ciphertext <span class="math inline">\(c\)</span> and its decryption satisfying some additional extra conditions,
which would prove that Alice truly knew the secret key.</p>
<p><strong>DSA Signatures:</strong> The DSA signature algorithm works as follows: (See also Section 12.5.2 in the KL book)</p>
<ul>
<li><p><em>Key generation:</em> Pick generator <span class="math inline">\(g\)</span> for <span class="math inline">\(\mathbb{G}\)</span> and <span class="math inline">\(a\in \{0,\ldots,|\mathbb{G}|-1\}\)</span> and let <span class="math inline">\(h=g^a\)</span>. Pick <span class="math inline">\(H:\{0,1\}^\ell\rightarrow\mathbb{G}\)</span> and <span class="math inline">\(F:\mathbb{G}\rightarrow\mathbb{G}\)</span> to be some functions that can be thought of as “hash functions”.<a href="#fn64" class="footnote-ref" id="fnref64"><sup>64</sup></a> The public key is <span class="math inline">\((g,h)\)</span> (as well as the functions <span class="math inline">\(H,F\)</span>) and secret key is <span class="math inline">\(a\)</span>.</p></li>
<li><p><em>Signature:</em> To sign a message <span class="math inline">\(m\)</span> with the key <span class="math inline">\(a\)</span>, pick <span class="math inline">\(b\)</span> at random, and let <span class="math inline">\(f=g^b\)</span>, and then let <span class="math inline">\(\sigma = b^{-1}[H(m)+a\cdot F(f)]\)</span>, where all computation is done modulo <span class="math inline">\(|\mathbb{G}|\)</span>. The signature is <span class="math inline">\((f,\sigma)\)</span>.</p></li>
<li><p><em>Verification:</em> To verify a signature <span class="math inline">\((f,\sigma)\)</span> on a message <span class="math inline">\(m\)</span>, check that <span class="math inline">\(\sigma\neq 0\)</span> and <span class="math inline">\(f^\sigma=g^{H(m)}h^{F(f)}\)</span>.</p></li>
</ul>
<blockquote>
<h1 id="section-52" class="pause"></h1>
<p>You should pause here and verify that this is indeed a valid signature scheme, in the sense that for every <span class="math inline">\(m\)</span>, <span class="math inline">\(V_s(m,S_s(m))=1\)</span>.</p>
</blockquote>
<p>Very roughly speaking, the idea behind security is that on one hand <span class="math inline">\(\sigma\)</span> does not reveal information about <span class="math inline">\(b\)</span> and <span class="math inline">\(a\)</span> because this is “masked” by the “random” value <span class="math inline">\(H(m)\)</span>. On the other hand, if an adversary is able to come up with valid signatures, then at least if we treated <span class="math inline">\(H\)</span> and <span class="math inline">\(F\)</span> as oracles, if the signature passes verification then (by taking <span class="math inline">\(\log\)</span> to the base of <span class="math inline">\(g\)</span>) the answers <span class="math inline">\(x,y\)</span> of these oracles will satisfy <span class="math inline">\(b\sigma = x + ay\)</span>, which means that sufficiently many such equations should be enough to recover the discrete log <span class="math inline">\(a\)</span>.</p>
<blockquote>
<h1 id="section-53" class="pause"></h1>
<p>Before seeing the actual proof, it is a very good exercise to try to see how to convert the intuition above into a formal proof.</p>
</blockquote>
<blockquote>
<h1 id="DSAsec" class="theorem" title="Random-Oracle Model Security of DSA signatures"></h1>
<p>Suppose that the discrete logarithm assumption holds for the group <span class="math inline">\(\mathbb{G}\)</span>. Then the DSA signature with <span class="math inline">\(\mathbb{G}\)</span> is secure when <span class="math inline">\(H,F\)</span> are modeled as random oracles.</p>
</blockquote>
<div class="proof" data-ref="DSAsec">
<p><span id="unlabeled-div-27" class="proof"><em>Proof</em>. </span>Suppose, for the sake of contradiction, that there was a <span class="math inline">\(T\)</span>-time adversary <span class="math inline">\(A\)</span> that succeeds with probability <span class="math inline">\(\epsilon\)</span> in a chosen message attack against the DSA scheme.
We will show that there is an adversary that can compute the discrete logarithm with running time and probability polynomially related to <span class="math inline">\(T\)</span> and <span class="math inline">\(\epsilon\)</span> respectively.</p>
<p>Recall that in a chosen message attack in the random oracle model, the adversary interacts with a signature oracle and oracles that compute the functions <span class="math inline">\(F\)</span> and <span class="math inline">\(H\)</span>.
For starters, we consider the following experiment <span class="math inline">\(CMA&#39;\)</span>, where in the chosen message attack we replace the signature box with the following “fake signature oracle” and “fake function <span class="math inline">\(F\)</span> oracle”:</p>
<p>On input a message <span class="math inline">\(m\)</span>, the fake box will choose <span class="math inline">\(\sigma,r\)</span> at random in <span class="math inline">\(\{0,\ldots,p-1\}\)</span> (where <span class="math inline">\(p=|\mathbb{G}|\)</span>), and compute <span class="math display">\[f=(g^{H(m)}h^{r})^{\sigma^{-1} \mod p} \label{randomfdsaeq}\]</span>
and output <span class="math inline">\((f,\sigma)\)</span>.
We will then record the value <span class="math inline">\(F(f)=r\)</span> and answer <span class="math inline">\(r\)</span> on future queries to <span class="math inline">\(F\)</span>.
If we’ve already answered <span class="math inline">\(F(f)\)</span> before with a different value, then we halt the experiment and output an error.
We claim that the adversary’s chance of succeeding in <span class="math inline">\(CMA&#39;\)</span> is computationally indistinguishable from its chance of succeeding in the original <span class="math inline">\(CMA\)</span> experiment.
Indeed, since we choose the value <span class="math inline">\(r=F(f)\)</span> at random, as long as we don’t repeat a value <span class="math inline">\(f\)</span> that was queried before, the function <span class="math inline">\(F\)</span> is completely random.
But since the adversary makes at most <span class="math inline">\(T\)</span> queries, and each <span class="math inline">\(f\)</span> is chosen according to <a href="" class="eqref">randomfdsaeq</a>, which yields a random element the group <span class="math inline">\(\mathbb{G}\)</span> (which has size roughly <span class="math inline">\(2^n\)</span>), the probability that <span class="math inline">\(f\)</span> is repeated is at most <span class="math inline">\(T/|\mathbb{G}|\)</span>, which is negligible.
Now we computed <span class="math inline">\(\sigma\)</span> in the fake box as a random value, but we can also compute <span class="math inline">\(\sigma\)</span> as equaling <span class="math inline">\(b^{-1}(H(m)+a r) \mod p\)</span>, where <span class="math inline">\(b=\log_g f \mod p\)</span> is uniform as well, and so the distribution of the signature <span class="math inline">\((f,\sigma)\)</span> is identical to the distribution by a real box.</p>
<p>Note that we can simulate the result of the experiment <span class="math inline">\(CMA&#39;\)</span> without access to the value <span class="math inline">\(a\)</span> such that <span class="math inline">\(h=g^a\)</span>.
We now transform an algorithm <span class="math inline">\(A&#39;\)</span> that manages to forge a signature in the <span class="math inline">\(CMA&#39;\)</span> experiment into an algorithm that given <span class="math inline">\(\mathbb{G},g,g^a\)</span> manages to recover <span class="math inline">\(a\)</span>.</p>
<p>We let <span class="math inline">\((m^*,f^*,\sigma^*)\)</span> be the message and signature that the adversary <span class="math inline">\(A&#39;\)</span> outputs at the end of a successful attack.
We can assume without loss of generality that <span class="math inline">\(f^*\)</span> is queried to the <span class="math inline">\(F\)</span> oracle at some point during the attack. (For example, by modifying <span class="math inline">\(A&#39;\)</span> to make this query just before she outputs the final signature.)
So, we split into two cases:</p>
<p><strong>Case I:</strong> The value <span class="math inline">\(F(f^*)\)</span> is first queried by the signature box.</p>
<p><strong>Case II:</strong> The value <span class="math inline">\(F(f^*)\)</span> is first queried by the adversary.</p>
<p>If Case I happens with non-negligible probability, then we know that the value <span class="math inline">\(f^*\)</span> is queried when producing the signature <span class="math inline">\((f^*,\sigma)\)</span> for some message <span class="math inline">\(m \neq m^*\)</span>, and so we know the following two equations hold:
<span class="math display">\[ g^{H(m)}h^{F(f^*)} = (f^*)^{\sigma}\]</span>
and
<span class="math display">\[ g^{H(m^*)}h^{F(f^*)}=  (f^*)^{\sigma^*}\]</span>
Taking logs we get the following equations on <span class="math inline">\(a = \log_g h\)</span> and <span class="math inline">\(b=\log_g f^*\)</span>:
<span class="math display">\[H(m)+aF(f^*) = b\sigma\]</span>
and
<span class="math display">\[H(m^*)+aF(f^*)=b\sigma^*\]</span>
or
<span class="math display">\[b= (H(m)-H(m^*))(\sigma-\sigma^*)^{-1} \mod p\]</span>
since all of the values <span class="math inline">\(H(m^*),H(m),\sigma,\sigma^*\)</span> are known, this means we can compute <span class="math inline">\(b\)</span>, and hence also recover the unknown value <span class="math inline">\(a\)</span>.</p>
<p>If Case II happens, then we split it into two cases as well.</p>
<p><strong>Case IIa</strong> is the subcase of Case II where <span class="math inline">\(F(f^*)\)</span> is queried <em>before</em> <span class="math inline">\(H(m^*)\)</span> is queried, and <strong>Case IIb</strong> is the subscase of Case II when <span class="math inline">\(F(f^*)\)</span> is queried after <span class="math inline">\(H(m^*)\)</span> is queried.</p>
<p>We start by considering the setting that <strong>Case IIa</strong> happens with non-negligible probability <span class="math inline">\(\epsilon\)</span>.
By the averaging argument there are some <span class="math inline">\(t&#39;&lt; t \in \{1,\ldots,T\}\)</span> such that with probability at least <span class="math inline">\(\epsilon/T^2\)</span>, <span class="math inline">\(f^*\)</span> is queried by the adversary at the <span class="math inline">\(t&#39;\)</span>-th query and <span class="math inline">\(m^*\)</span> is queried by the adversary at its <span class="math inline">\(t\)</span>-th query.
We run the <span class="math inline">\(CMA&#39;\)</span> experiment <em>twice</em>, using the same randomness up until the <span class="math inline">\(t-1\)</span>-th query and independent randomness from then onwards.
With probability at least <span class="math inline">\((\epsilon/T^2)^2\)</span>, both experiments will result in a successful forge, and since <span class="math inline">\(f^*\)</span> was queried before at stage <span class="math inline">\(t&#39;&lt;t\)</span>, we get the following equations
<span class="math display">\[H_1(m^*)+aF(f^*) = b\sigma\]</span>
and
<span class="math display">\[H_2(m^*)+aF(f^*)=b\sigma^*\]</span>
where <span class="math inline">\(H_1(m^*)\)</span> and <span class="math inline">\(H_2(m^*)\)</span> are the answers of <span class="math inline">\(H\)</span> to the query <span class="math inline">\(m^*\)</span> in the first and second time we run the experiment. (The answers of <span class="math inline">\(F\)</span> to <span class="math inline">\(f^*\)</span> are the same since this happens before the <span class="math inline">\(t\)</span>-th step).
As before, we can use this to recover <span class="math inline">\(a=\log_g h\)</span>.</p>
<p>If <strong>Case IIb</strong> happens with non-negligible probability, <span class="math inline">\(\epsilon&gt;0\)</span>.
Then again by the averaging argument there are some <span class="math inline">\(t&lt; t&#39;  \in \{1,\ldots,T\}\)</span> such that with probability at least <span class="math inline">\(\epsilon/T^2\)</span>, <span class="math inline">\(m^*\)</span> is queried by the adversary at the <span class="math inline">\(t\)</span>-th query, and <span class="math inline">\(f^*\)</span> is queried by the adversary at its <span class="math inline">\(t&#39;\)</span>-th query.
We run the <span class="math inline">\(CMA&#39;\)</span> experiment <em>twice</em>, using the same randomness up until the <span class="math inline">\(t&#39;-1\)</span>-th query and independent randomness from then onwards.
This time we will get the two equations
<span class="math display">\[H(m^*)+aF_1(f^*) = b\sigma\]</span>
and
<span class="math display">\[H(m^*)+aF_2(f^*)=b\sigma^*\]</span>
where <span class="math inline">\(F_1(f^*)\)</span> and <span class="math inline">\(F_2(f^*)\)</span> are our two answers in the first and second experiment, and now we can use this to learn <span class="math inline">\(a= b(\sigma-\sigma^*)(F_1(f^*)-F_2(f^*))^{-1}\)</span>.</p>
<p>The bottom line is that we obtain a probabilistic polynomial time algorithm that on input <span class="math inline">\(\mathbb{G},g,g^a\)</span> recovers <span class="math inline">\(a\)</span> with non-negligible probability, hence violating the assumption that the discrete log problem is hard for the group <span class="math inline">\(\mathbb{G}\)</span>.</p>
</div>
<blockquote>
<h1 id="nonromsec" class="remark" title="Non-random oracle model security"></h1>
<p>In this lecture both our encryption scheme and digital signature schemes were not proven secure under a well-stated computational assumption but rather used the random oracle model heuristic.
However, it is known how to obtain schemes that do not rely on this heuristic, and we will see such schemes later on in this course.</p>
</blockquote>
</div>
</div>
<div id="putting-everything-together---security-in-practice." class="section level2 hasAnchor" number="10.4">
<h2><span class="header-section-number">10.4</span> Putting everything together - security in practice.<a href="public-key-cryptography.html#putting-everything-together---security-in-practice." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let us discuss briefly how public key cryptography is used to secure web traffic through the SSL/TLS protocol that we all use when we use <code>https://</code> URLs.
The security this achieves is quite amazing. No matter what wired or wireless network you are using, no matter what country you are in, as long as your device (e.g., phone/laptop/etc..) and the server you are talking to (e.g., Google, Amazon, Microsoft etc.) is functioning properly, you can communicate securely without any party in the middle able to either learn or modify the contents of your interaction.<a href="#fn65" class="footnote-ref" id="fnref65"><sup>65</sup></a></p>
<p>In the web setting, there are <em>servers</em> who have public keys, and <em>users</em> who generally don’t have such keys. Ideally, as a user, you should already know the public keys of all the entities you communicate with e.g., <code>amazon.com</code>, <code>google.com</code>, etc. However, how are you going to learn those public keys?
The traditional answer was that because they are <em>public</em> these keys are much easier to communicate and the servers could even post them as ads on the <em>New York Times</em>. Of course these days everyone reads the <em>Times</em> through <code>nytimes.com</code> and so this seems like a chicken-and-egg type of problem.</p>
<p>The solution goes back again to the quote of Archimedes of “Give me a fulcrum, and I shall move the world”. The idea is that trust can be <em>transitive</em>. Suppose you have a Mac. Then you have already trusted Apple with quite a bit of your personal information, and so you might be fine if this Mac came pre-installed with the Apple public key which you trust to be authentic. Now, suppose that you want to communicate with <code>Amazon.com</code>. Now, <em>you</em> might not know the correct public key for Amazon, but <em>Apple</em> surely does. So Apple can supply Amazon with a signed message to the effect of</p>
<blockquote>
<p><em>“I Apple certify that the public key of Amazon.com is <code>30 82 01 0a 02 82 01 01 00 94 9f 2e fd 07 63 33 53 b1 be e5 d4 21 9d 86 43 70 0e b5 7c 45 bb ab d1 ff 1f b1 48 7b a3 4f be c7 9d 0f 5c 0b f1 dc 13 15 b0 10 e3 e3 b6 21 0b 40 b0 a3 ca af cc bf 69 fb 99 b8 7b 22 32 bc 1b 17 72 5b e5 e5 77 2b bd 65 d0 03 00 10 e7 09 04 e5 f2 f5 36 e3 1b 0a 09 fd 4e 1b 5a 1e d7 da 3c 20 18 93 92 e3 a1 bd 0d 03 7c b6 4f 3a a4 e5 e5 ed 19 97 f1 dc ec 9e 9f 0a 5e 2c ae f1 3a e5 5a d4 ca f6 06 cf 24 37 34 d6 fa c4 4c 7e 0e 12 08 a5 c9 dc cd a0 84 89 35 1b ca c6 9e 3c 65 04 32 36 c7 21 07 f4 55 32 75 62 a6 b3 d6 ba e4 63 dc 01 3a 09 18 f5 c7 49 bc 36 37 52 60 23 c2 10 82 7a 60 ec 9d 21 a6 b4 da 44 d7 52 ac c4 2e 3d fe 89 93 d1 ba 7e dc 25 55 46 50 56 3e e0 f0 8e c3 0a aa 68 70 af ec 90 25 2b 56 f6 fb f7 49 15 60 50 c8 b4 c4 78 7a 6b 97 ec cd 27 2e 88 98 92 db 02 03 01 00 01</code>”</em></p>
</blockquote>
<p>Such a message is known as a <em>certificate</em>, and it allows you to extend your trust in Apple to a trust in Amazon. Now when your browser communicates with Amazon, it can request this message, and if it is not present terminate the interaction or at least display some warning. Clearly a person in the middle can stop this message from travelling and hence not allow the interaction to continue, but they cannot <em>spoof</em> the message and send a certificate for their own public key, unless they
know Apple’s secret key. (In today’s actual implementation, for various business and other reasons, the trusted keys that come pre-installed in browsers and devices do not belong to Apple or Microsoft but rather to particular companies such as <em>Verisign</em> known as <em>certificate authorities</em>. The security of these certificate authorities’ private key is crucial to the security of the whole protocol, and it has been <a href="https://en.wikipedia.org/wiki/DigiNotar">attacked</a> <a href="http://www.wired.com/2011/10/son-of-stuxnet-in-the-wild/">before</a>.)</p>
<p>Using certificates, we can assume that Bob the user has the public verification key <span class="math inline">\(v\)</span> of Alice the server.
Now Alice can send Bob also a public <em>encryption</em> key <span class="math inline">\(e\)</span>, which is authenticated by <span class="math inline">\(v\)</span> and hence guaranteed to be correct.<a href="#fn66" class="footnote-ref" id="fnref66"><sup>66</sup></a>
Once Bob knows Alice’s public key they are in business- he can use that to send an encryption of some private key <span class="math inline">\(k\)</span>, which they can then use for all the rest of their communication.</p>
<p>This is, at a very high level, the SSL/TLS protocol, but there are many details inside it including the exact security notions needed from the encryption, how the two parties negotiate <em>which</em> cryptographic algorithm to use, and more. All these issues can and have been used for attacks on this protocol. For two recent discussions see <a href="http://blog.cryptographyengineering.com/2013/12/how-does-nsa-break-ssl.html">this blog post</a> and <a href="https://weakdh.org/">this website</a>.</p>
<div class="float" id="tmplabelfig">
<img src="../figure/certificate.jpg" style="width:80.0%" alt="When you connect to a webpage protected by SSL/TLS, the browser displays information on the certificate’s authenticity" />
<div class="figcaption">When you connect to a webpage protected by SSL/TLS, the browser displays information on the certificate’s authenticity</div>
</div>
<div class="float" id="tmplabelfig">
<img src="../figure/googletls.jpg" style="width:40.0%" alt="The cipher and certificate used by ’‘’Google.com’’’. Note that Google has a 2048bit RSA signature key which it then uses to authenticate an elliptic curve based Diffie-Hellman key exchange protocol to create session keys for the block cipher AES with 128 bit key in Galois Counter Mode." />
<div class="figcaption">The cipher and certificate used by ’‘’Google.com’’’. Note that Google has a 2048bit RSA signature key which it then uses to authenticate an elliptic curve based Diffie-Hellman key exchange protocol to create session keys for the block cipher AES with 128 bit key in Galois Counter Mode.</div>
</div>
<div class="float" id="tmplabelfig">
<img src="../figure/docusign.jpg" style="width:80.0%" alt="Digital signatures and other forms of electronic signatures are legally binding in many jurisdictions. This is some material from the website of the electronic signing company DocuSign." />
<div class="figcaption">Digital signatures and other forms of electronic signatures are legally binding in many jurisdictions. This is some material from the website of the electronic signing company DocuSign.</div>
</div>
<blockquote>
<p><strong>Example:</strong> Here is the list of certificate authorities that were trusted by default (as of spring 2016) by Mozilla products: Actalis, Amazon, AS Sertifitseerimiskeskuse (SK), Atos, Autoridad de Certificacion Firmaprofesional, Buypass, CA Disig a.s., Camerfirma, Certic谩mara S.A., Certigna, Certinomis, certSIGN, China Financial Certification Authority (CFCA), China Internet Network Information Center (CNNIC), Chunghwa Telecom Corporation, Comodo, ComSign, Consorci Administraci贸 Oberta de Catalunya (Consorci AOC, CATCert), Cybertrust Japan / JCSI, D-TRUST, Deutscher Sparkassen Verlag GmbH (S-TRUST, DSV-Gruppe), DigiCert, DocuSign (OpenTrust/Keynectis), e-tugra, EDICOM, Entrust, GlobalSign, GoDaddy, Government of France (ANSSI, DCSSI), Government of Hong Kong (SAR), Hongkong Post, Certizen, Government of Japan, Ministry of Internal Affairs and Communications, Government of Spain, Autoritat de Certificaci贸n de la Comunitat Valenciana (ACCV), Government of Taiwan, Government Root Certification Authority (GRCA), Government of The Netherlands, PKIoverheid, Government of Turkey, Kamu Sertifikasyon Merkezi (Kamu SM), HARICA, IdenTrust, Izenpe S.A., Microsec e-Szign贸 CA, NetLock Ltd., PROCERT, QuoVadis, RSA the Security Division of EMC, SECOM Trust Systems Co. Ltd., Start Commercial (StartCom) Ltd., Swisscom (Switzerland) Ltd, SwissSign AG, Symantec / GeoTrust, Symantec / Thawte, Symantec / VeriSign, T-Systems International GmbH (Deutsche Telekom), Taiwan-CA Inc. (TWCA), TeliaSonera, Trend Micro, Trustis, Trustwave, TurkTrust, Unizeto Certum, Visa, Web.com, Wells Fargo Bank N.A., WISeKey, WoSign CA Limited</p>
</blockquote>
</div>
<div id="appendix-an-alternative-proof-of-the-density-of-primes" class="section level2 hasAnchor" number="10.5">
<h2><span class="header-section-number">10.5</span> Appendix: An alternative proof of the density of primes<a href="public-key-cryptography.html#appendix-an-alternative-proof-of-the-density-of-primes" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>I record here an alternative way to show that the fraction of primes in <span class="math inline">\([2^n]\)</span> is <span class="math inline">\(\Omega(1/n)\)</span>.<a href="#fn67" class="footnote-ref" id="fnref67"><sup>67</sup></a></p>
<blockquote>
<h1 id="densityprimesaltlem" class="lemma"></h1>
<p>The probability that a random <span class="math inline">\(n\)</span> bit number is prime is at least <span class="math inline">\(\Omega(1/n)\)</span>.</p>
</blockquote>
<blockquote>
<h1 id="section-54" class="proof"></h1>
<p>Let <span class="math inline">\(N=2^n\)</span>. We need to show that the number of primes between <span class="math inline">\(1\)</span> and <span class="math inline">\(N\)</span> is at least <span class="math inline">\(\Omega(N/\log N)\)</span>.
Consider the number <span class="math inline">\(\binom{2N}{N}=\tfrac{2N!}{N!N!}\)</span>. By
Stirling’s formula we know that <span class="math inline">\(\log \binom{2N}{N} = (1 - o(1))2N\)</span> and in particular <span class="math inline">\(N \leq \log\binom{2N}{N}
\leq 2N\)</span>. Also, by the formula using factorials, all the prime factors of <span class="math inline">\(\binom{2N}{N}\)</span> are between <span class="math inline">\(0\)</span> and <span class="math inline">\(2N\)</span>,
and each factor <span class="math inline">\(P\)</span> cannot appear more than <span class="math inline">\(k=\lfloor \tfrac{\log 2N}{\log P} \rfloor\)</span> times. Indeed, for every <span class="math inline">\(N\)</span>, the number of times <span class="math inline">\(P\)</span> appears
in the factorization of <span class="math inline">\(N!\)</span> is <span class="math inline">\(\sum_i \lfloor \tfrac{N}{P^i} \rfloor\)</span>, since we get <span class="math inline">\(\lfloor \tfrac{N}{P} \rfloor\)</span> times a factor
<span class="math inline">\(P\)</span> in the factorizations of <span class="math inline">\(\{1,\ldots,N\}\)</span>, <span class="math inline">\(\lfloor \tfrac{N}{P^2} \rfloor\)</span> times a factor of the form <span class="math inline">\(P^2\)</span>, etc.
Thus, the number of times <span class="math inline">\(P\)</span> appears in the factorization of <span class="math inline">\(\binom{2N}{N}=\tfrac{(2N)!}{N!N!}\)</span> is equal to
<span class="math inline">\(\sum_i \lfloor \tfrac{2N}{P^i} \rfloor-2\lfloor \tfrac{N}{P^i} \rfloor\)</span>: a sum of at most <span class="math inline">\(k\)</span> elements (since <span class="math inline">\(P^{k+1}&gt;2N\)</span>) each
of which is either <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>.</p>
<p>Thus, <span class="math inline">\(\binom{2N}{N} \leq \prod_{\substack{1 \leq P \leq 2N \\
P \text{ prime }}} P^{\lfloor \tfrac{\log 2N}{\log P} \rfloor}\)</span>. Taking logs we get that
<span class="math display">\[N \leq \log \binom{2N}{N}\]</span>
<span class="math display">\[\leq \sum_{P \text{ prime} \in [2n]} \lfloor \tfrac{\log 2N}{\log P} \rfloor\log P\]</span>
<span class="math display">\[\leq \sum_{P \text{ prime} \in [2n]} \log 2N\]</span>
establishing that the number of primes in <span class="math inline">\([1,N]\)</span> is <span class="math inline">\(\Omega(\tfrac{N}{\log N})\)</span>.</p>
</blockquote>
</div>
<div id="additional-group-theory-exercises-and-proofs" class="section level2 hasAnchor" number="10.6">
<h2><span class="header-section-number">10.6</span> Additional Group Theory Exercises and Proofs<a href="public-key-cryptography.html#additional-group-theory-exercises-and-proofs" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Below are optional group theory related exercises and proofs meant to help gain an intuition with group theory. Note that in this class, we tend only to talk about finite commutative groups <span class="math inline">\(\mathbb{G}\)</span>, but there are more general groups:</p>
<ul>
<li><p>For example, the integers (i.e. infinitely many elements) where the operation is addition is a commutative group: if <span class="math inline">\(a,b,c\)</span> are integers, then <span class="math inline">\(a+b = b+a\)</span> (commutativity), <span class="math inline">\((a+b)+c = a+(b+c)\)</span> (associativity), <span class="math inline">\(a+0 = a\)</span> (so <span class="math inline">\(0\)</span> is the identity element here; we typically think of the identity as <span class="math inline">\(1\)</span>, especially when the group operation is multiplication), and <span class="math inline">\(a+(-a) = 0\)</span> (i.e. for any integer, we are allowed to think of its additive inverse, which is also an integer).</p></li>
<li><p>A non-commutative group (or a non-abelian group) is a group such that <span class="math inline">\(\exists a,b \in \mathbb{G}\)</span> but <span class="math inline">\(a * b \neq b * a\)</span> (where <span class="math inline">\(*\)</span> is the group operation). One example (of an infinite, non-commutative group) is the set of <span class="math inline">\(2 \times 2\)</span> matrices (over the real numbers) which are invertible, and the operation is matrix multiplication. The identity element is the traditional identity matrix, and each matrix has an inverse (and the product of two invertible matrices is still invertible), and matrix multiplication satisfies associativity. However, matrix multiplication here need not satisfy commutativity.</p></li>
</ul>
<p>In this class, we restrict ourselves to finite commutative groups to avoid complications with infinite group orders and annoyances with non-commutative operations. For the problems below, assume that a “group” is really a “finite commutative group”.</p>
<p>Here are five more important groups used in cryptography other than <span class="math inline">\(\mathbb{Z}_{p}\)</span>. Recall that groups are given by a set and a binary operation.</p>
<ul>
<li>For some prime <span class="math inline">\(p\)</span>, <span class="math inline">\(\mathbb{Z}_p^{*}=\{1,\ldots , p-1\}\)</span>, with operation multiplication mod <span class="math inline">\(p\)</span> (Note: the <span class="math inline">\(^{*}\)</span> is to distinguish this group from <span class="math inline">\(\mathbb{Z}_p\)</span> with an additive operation and from <span class="math inline">\(GF(p)\)</span>.)</li>
<li>The quadratic residues of <span class="math inline">\(\mathbb{Z}_p^{*}\)</span>: <span class="math inline">\(Q_p=\{a^2:a\in \mathbb{Z}_p^{*}\}\)</span> with operation multiplication mod <span class="math inline">\(p\)</span></li>
<li><span class="math inline">\(\mathbb{Z}_n^{*}\)</span>, where <span class="math inline">\(n=p\cdot q\)</span> (product of two primes)</li>
<li>The quadratic residues of <span class="math inline">\(\mathbb{Z}_n^{*}\)</span>:: <span class="math inline">\(Q_n=\{a^2:a\in \mathbb{Z}_n^{*}\}\)</span>, where <span class="math inline">\(n=p\cdot q\)</span></li>
<li>Elliptic curve groups</li>
</ul>
<p>For more familiarity with group definitions, you could verify that the first 4 groups satisfy the group axioms. For cryptography, two operations need be efficient for elements <span class="math inline">\(a,b\)</span> in group <span class="math inline">\(\mathbb{G}\)</span>:</p>
<ul>
<li>Exponentiation: <span class="math inline">\(a,b\mapsto a^b\)</span>. This is done efficiently using repeated squaring, i.e. generate all the squares up to <span class="math inline">\(2^k\)</span> and then use the binary representation.</li>
<li>Inverse: <span class="math inline">\(a \mapsto a^{-1}\)</span>. This is done efficiently in <span class="math inline">\(\mathbb{Z}_p^{\*}\)</span> by Fermat’s little theorem. <span class="math inline">\(a^{-1}=a^{p-2}\)</span> mod <span class="math inline">\(p\)</span>.</li>
</ul>
<div id="solved-exercises" class="section level3 hasAnchor" number="10.6.1">
<h3><span class="header-section-number">10.6.1</span> Solved exercises:<a href="public-key-cryptography.html#solved-exercises" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="grouptheoryex1" class="solvedexercise">
<p>Is the set <span class="math inline">\(S = \{1,2,3,4,5,6\}\)</span> a group if the operation is multiplication mod <span class="math inline">\(7\)</span>? What if the operation is addition mod <span class="math inline">\(7\)</span>?</p>
</div>
<div class="solution" data-ref="grouptheoryex2">
<p><span id="unlabeled-div-28" class="solution"><em>Solution</em>. </span>Yes (if multiplication) and no (if addition).
To prove that something is a group, we run through the definition of a group. This set is finite, and multiplication (even multiplication mod some number) will satisfy commutativity and associativity. The identity element is <span class="math inline">\(1\)</span> because any number times <span class="math inline">\(1\)</span>, even mod <span class="math inline">\(7\)</span>, is still itself. To find inverses, we can in this case literally find the inverses. <span class="math inline">\(1 * 1 \mod 7 = 1 \mod 7\)</span> (so the inverse of <span class="math inline">\(1\)</span> is <span class="math inline">\(1\)</span>). <span class="math inline">\(2 * 4 \mod 7 = 8 \mod 7 = 1 \mod 7\)</span> (so the inverse of <span class="math inline">\(2\)</span> is <span class="math inline">\(4\)</span>, and from commutativity, the inverse of <span class="math inline">\(4\)</span> is <span class="math inline">\(2\)</span>). <span class="math inline">\(3 * 5 \mod 7 = 15 \mod 7 = 1 \mod 7\)</span> (so the inverse of <span class="math inline">\(3\)</span> is <span class="math inline">\(5\)</span>, and the inverse of <span class="math inline">\(5\)</span> is <span class="math inline">\(3\)</span>). <span class="math inline">\(6 * 6 \mod 7 = 36 \mod 7 = 1 \mod 7\)</span> (so <span class="math inline">\(6\)</span> is its own inverse; notice that an element can be its own inverse, even if it is not the identity <span class="math inline">\(1\)</span>).
The set <span class="math inline">\(S\)</span> is not a group if the operation is addition for many reasons: one way to see this <span class="math inline">\(1+6 \mod 7 = 0 \mod 7\)</span>, but <span class="math inline">\(0\)</span> is not an element of <span class="math inline">\(S\)</span>, so this group is not <em>closed</em> under its operation (implicit in the definition of a group is the idea that a group’s operation must send two group elements to another element <em>within the same set of group elements</em>).</p>
</div>
<div id="grouptheoryex2" class="solvedexercise" title="">
<p>What are the generators of the group <span class="math inline">\(\{1,2,3,4,5,6 \}\)</span>, where the operation is multiplication mod <span class="math inline">\(7\)</span>?</p>
</div>
<div class="solution" data-ref="grouptheoryex2">
<p><span id="unlabeled-div-29" class="solution"><em>Solution</em>. </span><span class="math inline">\(3\)</span> and <span class="math inline">\(5\)</span>.
Recall that a generator of a group is an element <span class="math inline">\(g\)</span> such that <span class="math inline">\(\{g,g^2,g^3,\cdots\}\)</span> is the entire group. We can directly check the elements here:
<span class="math inline">\(\{1,1^2,1^3,\cdots\} = \{1\}\)</span>, so <span class="math inline">\(1\)</span> is not a generator.
<span class="math inline">\(2\)</span> is not a generator because <span class="math inline">\(2^3 \mod 7 = 8 \mod 7 = 1\)</span>, so the set <span class="math inline">\(\{2,2^2,2^3,2^4,\cdots\}\)</span> is really the set <span class="math inline">\(\{2,4,1\}\)</span>, which is not the entire group.
<span class="math inline">\(3\)</span> will be a generator because <span class="math inline">\(3^2 \mod 7 = 9 \mod 7 = 2 \mod 7\)</span>, <span class="math inline">\(3^3 \mod 7 = 2*3 \mod 7 = 6 \mod 7\)</span>, <span class="math inline">\(3^3 \mod 7 = 18 \mod 7 = 4 \mod 7\)</span>, <span class="math inline">\(3^4 = 12 \mod 7 = 5\)</span>, <span class="math inline">\(3^5 \mod 7 = 15 \mod 7 = 1\)</span>, so <span class="math inline">\(\{3,3^2,3^3,3^4,3^5,3^6,3^7 \} = \{3,2,6,4,5,1\}\)</span>, which are all of the elements.
<span class="math inline">\(4\)</span> is not a generator because <span class="math inline">\(4^3 \mod 7  = 64 \mod 7 = 1 \mod 7\)</span>, so just like <span class="math inline">\(2\)</span>, we won’t get every element.
<span class="math inline">\(5\)</span> is a generator because <span class="math inline">\(5^2 \mod 6 = 4, 5^3 \mod 7 = 20 \mod 7 = 6, 5^4 \mod 7 = 30 \mod 7 = 2, 5^5 \mod 7 = 10 \mod 7 = 3, 5^6 \mod 7 = 15 \mod 7 = 1\)</span>, so just like <span class="math inline">\(3\)</span>, <span class="math inline">\(5\)</span> is a generator.
<span class="math inline">\(6\)</span> is not a generator because <span class="math inline">\(6^2 \mod 7= 1 \mod 7\)</span>, so just like <span class="math inline">\(2\)</span>, the set <span class="math inline">\(\{6,6^2,6^3,\cdots\}\)</span> cannot contain all elements (it will just have <span class="math inline">\(1\)</span> and <span class="math inline">\(6\)</span>).</p>
</div>
<div id="groupex3" class="solvedexercise">
<p>What is the order of every element in the group <span class="math inline">\(\{1,2,3,4,5,6 \}\)</span>, where the operation is multiplication mod <span class="math inline">\(7\)</span>?</p>
</div>
<div class="solution" data-ref="groupex3">
<p><span id="unlabeled-div-30" class="solution"><em>Solution</em>. </span>The orders (of <span class="math inline">\(1,2,3,4,5,6\)</span>) are <span class="math inline">\(1,3, 6, 3, 6, 2\)</span>, respectively.
This can be seen from the work of the previous problem, where we test out powers of elements.
Notice that all of these orders divide the number of elements in our group. This is not a coincidence, and it is an example of Lagrange’s Theorem, which states that the size of every subgroup of a group will divide the order of a group. Recall that a subgroup is simply a subset of the group which is a group in its own right and is closed under the operation of the group.</p>
</div>
<div id="groupex4" class="solvedexercise">
<p>Suppose we have some (finite, commutative) group <span class="math inline">\(\mathbb{G}\)</span>. Prove that the inverse of any element is unique (i.e. prove that if <span class="math inline">\(a \in \mathbb{G}\)</span>, then if <span class="math inline">\(b,c \in \mathbb{G}\)</span> such that <span class="math inline">\(ab = 1\)</span> and <span class="math inline">\(ac = 1\)</span>, then <span class="math inline">\(b=c\)</span>).</p>
</div>
<div class="solution" data-ref="groupex4">
<p><span id="unlabeled-div-31" class="solution"><em>Solution</em>. </span>Suppose that <span class="math inline">\(a \in \mathbb{G}\)</span> and that <span class="math inline">\(b,c \in \mathbb{G}\)</span> such that <span class="math inline">\(ab = 1\)</span> and <span class="math inline">\(ac = 1\)</span>. Then we know that <span class="math inline">\(ab = ac\)</span>, and then we can apply <span class="math inline">\(a^{-1}\)</span> to both sides (we are guaranteed that <span class="math inline">\(a\)</span> has SOME inverse <span class="math inline">\(a^{-1}\)</span> in the group), and so we have <span class="math inline">\(a^{-1}ab = a^{-1}ac\)</span>, but we know that <span class="math inline">\(a^{-1}a = 1\)</span> (and we can use associativity of a group), so <span class="math inline">\((1)b = (1)c\)</span> so <span class="math inline">\(b = c\)</span>. QED.</p>
</div>
<div id="groupex5" class="solvedexercise">
<p>Suppose we have some (finite, commutative) group <span class="math inline">\(\mathbb{G}\)</span>. Prove that the identity element is unique (i.e. if <span class="math inline">\(ca = c\)</span> for all <span class="math inline">\(c \in \mathbb{G}\)</span> and if <span class="math inline">\(cb = c\)</span> for all <span class="math inline">\(c \in \mathbb{G}\)</span>, then <span class="math inline">\(a=b\)</span>).</p>
</div>
<div class="solution" data-ref="groupex5">
<p><span id="unlabeled-div-32" class="solution"><em>Solution</em>. </span>Suppose that <span class="math inline">\(ca = c\)</span> for all <span class="math inline">\(c \in \mathbb{G}\)</span> and that <span class="math inline">\(cb = c\)</span> for all <span class="math inline">\(c \in \mathbb{G}\)</span>. Then we can say that <span class="math inline">\(ca =c = cb\)</span> (for any <span class="math inline">\(c\)</span>, but we can choose some <span class="math inline">\(c\)</span> in particular, we could have picked <span class="math inline">\(c=1\)</span>). And then <span class="math inline">\(c\)</span> has some inverse element <span class="math inline">\(c^{-1}\)</span> in the group, so <span class="math inline">\(c^{-1}ca = c^{-1}cb\)</span>, but <span class="math inline">\(c^{-1}c = 1\)</span>, so <span class="math inline">\(a = b\)</span> as desired. QED</p>
</div>
<p>The next few problems are related to quadratic residues, but these problems are a bit more general (in particular, we are considering some group, and a subgroup which are all of the elements of the first group which are squares).</p>
<div id="quadresidueex1" class="solvedexercise">
<p>Suppose that <span class="math inline">\(\mathbb{G}\)</span> is some (finite, commutative) group, and <span class="math inline">\(\mathbb{H}\)</span> is the set defined by <span class="math inline">\(\mathbb{H} := \{ h \in \mathbb{G}: \exists g \in G, g^2 = h\}\)</span>. Verify that <span class="math inline">\(\mathbb{H}\)</span> is a subgroup of <span class="math inline">\(\mathbb{G}\)</span>.</p>
</div>
<div class="solution" data-ref="quadresidueex1">
<p><span id="unlabeled-div-33" class="solution"><em>Solution</em>. </span>To be a subgroup, we need to make sure that <span class="math inline">\(\mathbb{H}\)</span> is a group in its own right (in particular, that it contains the identity, that it contains inverses, and that it is closed under multiplication; associativity and commutativity follow because we are within a larger set <span class="math inline">\(\mathbb{G}\)</span> which satisfies associativity and commutativity).</p>
<p><em>Identity</em> Well, <span class="math inline">\(1^2 = 1\)</span>, so <span class="math inline">\(1 \in \mathbb{H}\)</span>, so <span class="math inline">\(\mathbb{H}\)</span> has the identity element.
<em>Inverses</em> If <span class="math inline">\(h \in \mathbb{H}\)</span>, then <span class="math inline">\(g^2 = h\)</span> for some <span class="math inline">\(g \in \mathbb{G}\)</span>, but <span class="math inline">\(g\)</span> has an inverse in <span class="math inline">\(\mathbb{G}\)</span>, and we can look at <span class="math inline">\(g^2(g^{-1})^2 = (gg^{-1})^2 = 1^2 = 1\)</span> (where I used commutativity and associativity, as well as the definition of the inverse). It is clear that <span class="math inline">\((g^{-1})^2 \in \mathbb{H}\)</span> because there exists an element in <span class="math inline">\(\mathbb{G}\)</span> (specifically, <span class="math inline">\(g^{-1}\)</span>) whose square is <span class="math inline">\((g^{-1})^2\)</span>. Therefore <span class="math inline">\(h\)</span> has an inverse in <span class="math inline">\(\mathbb{H}\)</span>, where if <span class="math inline">\(h=g^2\)</span>, then <span class="math inline">\(h^{-1} = (g^{-1})^2\)</span>.
<em>Closure under operation</em> If <span class="math inline">\(h_1,h_2 \in \mathbb{H}\)</span>, then there exist <span class="math inline">\(g_1,g_2 \in \mathbb{G}\)</span> where <span class="math inline">\(h_1 = (g_1)^2, h_2 = (g_2)^2\)</span>. So <span class="math inline">\(h_1h_2 = (g_1)^2(g_2)^2 = (g_1g_2)^2\)</span>, so <span class="math inline">\(h_1h_2 \in \mathbb{H}\)</span>.
Therefore, <span class="math inline">\(\mathbb{H}\)</span> is a subgroup of <span class="math inline">\(\mathbb{G}\)</span>.</p>
</div>
<div id="quadresidueex2" class="solvedexercise">
<p>Assume that <span class="math inline">\(|\mathbb{G}|\)</span> is an even number and is known, and that <span class="math inline">\(g^{|\mathbb{G}|}=1\)</span> for any <span class="math inline">\(g \in \mathbb{G}\)</span>. Also assume that <span class="math inline">\(\mathbb{G}\)</span> is a cyclic group, i.e. there is some <span class="math inline">\(g \in \mathbb{G}\)</span> such that any element <span class="math inline">\(f \in \mathbb{G}\)</span> can be written as <span class="math inline">\(f^k\)</span> for some integer <span class="math inline">\(k\)</span>. Also assume that exponentiation is efficient in this context (i.e. we can compute <span class="math inline">\(g^r\)</span> for any <span class="math inline">\(0 \leq r \leq |\mathbb{G}|\)</span> in an efficient time for any <span class="math inline">\(g \in \mathbb{G}\)</span>).</p>
<p>Under the assumptions stated above, prove that there is an efficient way to check if some element of <span class="math inline">\(\mathbb{G}\)</span> is also an element of <span class="math inline">\(\mathbb{H}\)</span>, where <span class="math inline">\(\mathbb{H}\)</span> is still the subgroup of squares of elements of <span class="math inline">\(\mathbb{G}\)</span> (note: running through all possible elements of <span class="math inline">\(\mathbb{G}\)</span> may not be efficient, so this cannot be your strategy).</p>
</div>
<div class="solution" data-ref="quadresidueex2">
<p><span id="unlabeled-div-34" class="solution"><em>Solution</em>. </span>Suppose that we receive some element <span class="math inline">\(g \in \mathbb{G}\)</span>. We want to know if there exists some <span class="math inline">\(g&#39; \in \mathbb{G}\)</span> such that <span class="math inline">\(g = (g&#39;)^2\)</span> (this is equivalent to <span class="math inline">\(g\)</span> being in <span class="math inline">\(\mathbb{H}\)</span>). To do so, compute <span class="math inline">\(g^{|\mathbb{G}|/2}\)</span>. I claim that <span class="math inline">\(g^{|\mathbb{G}|/2}=1\)</span> if and only if <span class="math inline">\(g \in \mathbb{H}\)</span>.</p>
<p>(Proving the if): If <span class="math inline">\(g \in \mathbb{H}\)</span>, then <span class="math inline">\(g=(g&#39;)^2\)</span> for some <span class="math inline">\(g&#39; \in \mathbb{G}\)</span>. We then have that <span class="math inline">\(g^{|\mathbb{G}|/2} = ((g&#39;)^2)^{|\mathbb{G}|/2} = (g&#39;)^{|\mathbb{G}|}\)</span>. But from our assumption, an element raised to the order of the group is <span class="math inline">\(1\)</span>, so <span class="math inline">\((g&#39;)^{|\mathbb{G}|} = 1\)</span>, so <span class="math inline">\(g^{|\mathbb{G}|/2} = 1\)</span>. As a result, if <span class="math inline">\(g \in \mathbb{H}\)</span>, then <span class="math inline">\(g^{|\mathbb{G}|/2} = 1\)</span>.</p>
<p>(Proving the only if): Now suppose that <span class="math inline">\(g^{|\mathbb{G}|/2} = 1\)</span>. At this point, we use the fact that <span class="math inline">\(\mathbb{G}\)</span> is cyclic, so let <span class="math inline">\(f \in \mathbb{G}\)</span> be the generator of <span class="math inline">\(\mathbb{G}\)</span>. We know that <span class="math inline">\(g\)</span> is some power of <span class="math inline">\(f\)</span>, and this power is either even or odd. If the power is even, we are done. If the power is odd, then <span class="math inline">\(g = f^{2k+1}\)</span> for some natural number <span class="math inline">\(k\)</span>. And then we see
<span class="math inline">\(g^{|\mathbb{G}|/2} = (f^{2k+1})^{|\mathbb{G}|/2} = f^{|\mathbb{G}| + |\mathbb{G}|/2} = f^{|\mathbb{G}|}f^{|\mathbb{G}|/2}\)</span>.
We can use the assumption that any element raised to its group’s order is <span class="math inline">\(1\)</span>, so <span class="math inline">\(1 = g^{|\mathbb{G}|/2}  = f^{|\mathbb{G}|}f^{|\mathbb{G}|/2} = f^{|\mathbb{G}|/2}\)</span>.
This tells us that the order of <span class="math inline">\(f\)</span> is at most <span class="math inline">\(|\mathbb{G}|/2\)</span>, but this is a contradiction because <span class="math inline">\(f\)</span> is a generator of <span class="math inline">\(\mathbb{G}\)</span>, so its order cannot be less than <span class="math inline">\(|\mathbb{G}|\)</span> (if it were, then looking at <span class="math inline">\(\{f,f^2,f^3,\cdots\}\)</span>, we would only count at most half of the elements before cycling back to <span class="math inline">\(1,f,f^2,\cdots\)</span>, so this set wouldn’t contain all of <span class="math inline">\(\mathbb{G}\)</span>). As a result, we have reached a contradiction, so <span class="math inline">\(g^{|\mathbb{G}|/2} = 1\)</span> means that <span class="math inline">\(g = f^{2k} = (f^k)^2\)</span>, so <span class="math inline">\(g \in \mathbb{H}\)</span>.</p>
<p>We are given that this exponentiation is efficient, so checking <span class="math inline">\(g^{|\mathbb{G}|/2} == 1\)</span> is an efficient and correct way to test if <span class="math inline">\(g \in \mathbb{H}\)</span>. QED.</p>
<p>This proof idea came from <a href="https://crypto.stanford.edu/pbc/notes/numbertheory/qr.html">here</a> as well as from the 2/25/20 lecture at Harvard given by MIT professor Yael Kalai.</p>
<p><strong>Commentary on assumptions and proof</strong>: Proving that <span class="math inline">\(g^{|\mathbb{G}|}=1\)</span> is a useful exercise in its own right, but it overlaps somewhat with our problem sets of 2020, so we will not prove it here; observe that if <span class="math inline">\(\mathbb{G}\)</span> is the set of <span class="math inline">\(\{1,2,3,\cdots,p-1\}\)</span> for some prime <span class="math inline">\(p\)</span>, then this is a special case of Fermat’s Little Theorem, which states that <span class="math inline">\(a^{p-1} \mod p = 1\)</span> for <span class="math inline">\(a \in \{1,2,3,\cdots,p-1\}\)</span>.
Also, one can prove that <span class="math inline">\(Z_p^{\*}\)</span> (the set of numbers <span class="math inline">\(0,1,2,\cdots,p-1\)</span>, with operation multiplication mod <span class="math inline">\(p\)</span>) for <span class="math inline">\(p\)</span> a prime is cyclic, where one method can be found <a href="https://crypto.stanford.edu/pbc/notes/numbertheory/gen.html">here</a>, where the proof comes down to factorizing certain polynomials and decomposing numbers in terms of prime powers.
We can then see that this proof above says that there is an efficient way to test whether an element of <span class="math inline">\(Z_p^{\*}\)</span> is a square or not.</p>
</div>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="57">
<li id="fn57"><p>For simplicity, assume that the program <span class="math inline">\(P\)</span> is <em>side effect free</em> and hence it simply computes some function, say from <span class="math inline">\(\{0,1\}^n\)</span> to <span class="math inline">\(\{0,1\}^\ell\)</span> for some <span class="math inline">\(n,\ell\)</span>.<a href="public-key-cryptography.html#fnref57" class="footnote-back">↩︎</a></p></li>
<li id="fn58"><p>There have been some other more exotic suggestions for public key encryption (including some by <a href="http://www.eng.tau.ac.il/~bennyap/pubs/ncpkcFull1.pdf">yours truly</a> as well as suggestions such as the <a href="http://eprint.iacr.org/2006/291">isogeny star problem</a>, though see also <a href="http://arxiv.org/pdf/1012.4019.pdf">this</a>), but they have not yet received wide scrutiny.<a href="public-key-cryptography.html#fnref58" class="footnote-back">↩︎</a></p></li>
<li id="fn59"><p>The running time of the best known algorithms for computing the discrete logarithm modulo <span class="math inline">\(n\)</span> bit primes is <span class="math inline">\(2^{f(n)2^{n^{1/3}}}\)</span>, where <span class="math inline">\(f(n)\)</span> is a function that depends polylogarithmically on <span class="math inline">\(n\)</span>. If <span class="math inline">\(f(n)\)</span> would equal <span class="math inline">\(1\)</span>, then we’d need numbers of <span class="math inline">\(128^3 \approx 2\cdot 10^6\)</span> bits to get <span class="math inline">\(128\)</span> bits of security, but because <span class="math inline">\(f(n)\)</span> is larger than one, the current <a href="https://goo.gl/ntszsg">estimates</a> are that we need to let <span class="math inline">\(n=3072\)</span> bit key to get <span class="math inline">\(128\)</span> bits of of security. Still, the existence of such a non-trivial algorithm means that we need much larger keys than those used for private key systems to get the same level of security. In particular, to double the estimated security to <span class="math inline">\(256\)</span> bits, NIST recommends that we multiply the RSA keysize five-fold to <span class="math inline">\(15,360\)</span>. (The same document also says that SHA-256 gives <span class="math inline">\(256\)</span> bits of security as a pseudorandom generator but only <span class="math inline">\(128\)</span> bits when used to hash documents for digital signatures; can you see why?)<a href="public-key-cryptography.html#fnref59" class="footnote-back">↩︎</a></p></li>
<li id="fn60"><p>Formally, the secret key should contain all the information in the public key plus the extra secret information, but we omit the public information for simplicity of notation.<a href="public-key-cryptography.html#fnref60" class="footnote-back">↩︎</a></p></li>
<li id="fn61"><p>Formally, since it is an asymptotic statement, the CDH assumption needs to be defined with a <em>sequence of groups</em>. However, to make notation simpler we will ignore this issue, and use it only for groups (such as the numbers modulo some <span class="math inline">\(n\)</span> bit primes) where we can easily increase the “security parameter” <span class="math inline">\(n\)</span>.<a href="public-key-cryptography.html#fnref61" class="footnote-back">↩︎</a></p></li>
<li id="fn62"><p>ElGamal’s actual contribution was to design a <em>signature scheme</em> based on the Diffie-Hellman problem, a variant of which is the Digital Signature Algorithm (DSA) described below.<a href="public-key-cryptography.html#fnref62" class="footnote-back">↩︎</a></p></li>
<li id="fn63"><p>For every <span class="math inline">\(f\in \mathbb{G}\)</span>, you can show a one to one and onto mapping between the set <span class="math inline">\(\{ a : g^a = 1 \}\)</span> and the set <span class="math inline">\(\{b : g^b= f \}\)</span> by choosing some element <span class="math inline">\(b\)</span> from the latter set and looking at the map <span class="math inline">\(a \mapsto a+b \mod |\mathbb{G}|\)</span>.<a href="public-key-cryptography.html#fnref63" class="footnote-back">↩︎</a></p></li>
<li id="fn64"><p>It is a bit cumbersome, but not so hard, to transform functions that map strings to strings to functions whose domain or range are group elements. As noted in the KL book, in the actual DSA protocol <span class="math inline">\(F\)</span> is <em>not</em> a cryptographic hash function but rather some very simple function that is still assumed to be “good enough” for security.<a href="public-key-cryptography.html#fnref64" class="footnote-back">↩︎</a></p></li>
<li id="fn65"><p>They are able to know that such an interaction took place and the amount of bits exchanged. Preventing these kind of attacks is more subtle and approaches for solutions are known as <em>steganography</em> and <em>anonymous routing</em>.<a href="public-key-cryptography.html#fnref65" class="footnote-back">↩︎</a></p></li>
<li id="fn66"><p>If this key is <em>ephemeral</em>- generated on the spot for this interaction and deleted afterward- then this has the benefit of ensuring the <em>forward secrecy</em> property that even if some entity that is in the habit of recording all communication later finds out Alice’s private verification key, then it still will not be able to decrypt the information. In applied crypto circles this property is somewhat misnamed as “perfect forward secrecy” and associated with the Diffie-Hellman key exchange (or its elliptic curves variants), since in those protocols there is not much additional overhead for implementing it (see <a href="http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html">this blog post</a>). The importance of forward security was emphasized by the discovery of the <a href="http://heartbleed.com/">Heartbleed</a> vulnerability (see <a href="https://jhalderm.com/pub/papers/heartbleed-imc14.pdf">this paper</a>) that allowed via a buffer-overflow attack in OpenSSL to learn the private key of the server.<a href="public-key-cryptography.html#fnref66" class="footnote-back">↩︎</a></p></li>
<li id="fn67"><p>It might be that the two ways are more or less the same, as if we open up the polynomial <span class="math inline">\((1-x)^kx^k\)</span> we get the binomial coefficients.<a href="public-key-cryptography.html#fnref67" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="concrete-candidates-for-public-key-crypto.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/09-public-key-intro.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
