<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>20 Quantum computing and cryptography II | A Minimal Book Example</title>
  <meta name="description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="20 Quantum computing and cryptography II | A Minimal Book Example" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="20 Quantum computing and cryptography II | A Minimal Book Example" />
  
  <meta name="twitter:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="quantum-computing-and-cryptography-i.html"/>
<link rel="next" href="software-obfuscation.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">A Minimal Book Example</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="mathematical-background.html"><a href="mathematical-background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a>
<ul>
<li class="chapter" data-level="1.1" data-path="mathematical-background.html"><a href="mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>1.1</b> A quick overview of mathematical prerequisites</a></li>
<li class="chapter" data-level="1.2" data-path="mathematical-background.html"><a href="mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>1.2</b> Mathematical Proofs</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="mathematical-background.html"><a href="mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>1.2.1</b> Example: The existence of infinitely many primes.</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="mathematical-background.html"><a href="mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>1.3</b> Probability and Sample spaces</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="mathematical-background.html"><a href="mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>1.3.1</b> Random variables</a></li>
<li class="chapter" data-level="1.3.2" data-path="mathematical-background.html"><a href="mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>1.3.2</b> Distributions over strings</a></li>
<li class="chapter" data-level="1.3.3" data-path="mathematical-background.html"><a href="mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>1.3.3</b> More general sample spaces.</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="mathematical-background.html"><a href="mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>1.4</b> Correlations and independence</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="mathematical-background.html"><a href="mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>1.4.1</b> Independent random variables</a></li>
<li class="chapter" data-level="1.4.2" data-path="mathematical-background.html"><a href="mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>1.4.2</b> Collections of independent random variables.</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="mathematical-background.html"><a href="mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>1.5</b> Concentration and tail bounds</a>
<ul>
<li class="chapter" data-level="1.5.1" data-path="mathematical-background.html"><a href="mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>1.5.1</b> Chebyshev’s Inequality</a></li>
<li class="chapter" data-level="1.5.2" data-path="mathematical-background.html"><a href="mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>1.5.2</b> The Chernoff bound</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
<li class="chapter" data-level="1.7" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>1.7</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a>
<ul>
<li class="chapter" data-level="2.1" data-path="introduction.html"><a href="introduction.html#some-history"><i class="fa fa-check"></i><b>2.1</b> Some history</a></li>
<li class="chapter" data-level="2.2" data-path="introduction.html"><a href="introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>2.2</b> Defining encryptions</a></li>
<li class="chapter" data-level="2.3" data-path="introduction.html"><a href="introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>2.3</b> Defining security of encryption</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="introduction.html"><a href="introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>2.3.1</b> Generating randomness in actual cryptographic systems</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="introduction.html"><a href="introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>2.4</b> Defining the secrecy requirement.</a></li>
<li class="chapter" data-level="2.5" data-path="introduction.html"><a href="introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>2.5</b> Perfect Secrecy</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="introduction.html"><a href="introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>2.5.1</b> Achieving perfect secrecy</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="introduction.html"><a href="introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>2.6</b> Necessity of long keys</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="introduction.html"><a href="introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>2.6.1</b> Amplifying success probability</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="introduction.html"><a href="introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="computational-security.html"><a href="computational-security.html"><i class="fa fa-check"></i><b>3</b> Computational Security</a>
<ul>
<li class="chapter" data-level="3.0.1" data-path="computational-security.html"><a href="computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>3.0.1</b> Proof by reduction</a></li>
<li class="chapter" data-level="3.1" data-path="computational-security.html"><a href="computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>3.1</b> The asymptotic approach</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="computational-security.html"><a href="computational-security.html#countoperation"><i class="fa fa-check"></i><b>3.1.1</b> Counting number of operations.</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="computational-security.html"><a href="computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>3.2</b> Our first conjecture</a></li>
<li class="chapter" data-level="3.3" data-path="computational-security.html"><a href="computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>3.3</b> Why care about the cipher conjecture?</a></li>
<li class="chapter" data-level="3.4" data-path="computational-security.html"><a href="computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>3.4</b> Prelude: Computational Indistinguishability</a></li>
<li class="chapter" data-level="3.5" data-path="computational-security.html"><a href="computational-security.html#the-length-extension-theorem-or-stream-ciphers"><i class="fa fa-check"></i><b>3.5</b> The Length Extension Theorem or Stream Ciphers</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="computational-security.html"><a href="computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>3.5.1</b> Appendix: The computational model</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pseudorandomness.html"><a href="pseudorandomness.html"><i class="fa fa-check"></i><b>4</b> Pseudorandomness</a>
<ul>
<li class="chapter" data-level="4.0.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#unpredictability-an-alternative-approach-for-proving-the-length-extension-theorem"><i class="fa fa-check"></i><b>4.0.1</b> Unpredictability: an alternative approach for proving the length extension theorem</a></li>
<li class="chapter" data-level="4.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#stream-ciphers"><i class="fa fa-check"></i><b>4.1</b> Stream ciphers</a></li>
<li class="chapter" data-level="4.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>4.2</b> What do pseudorandom generators actually look like?</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>4.2.1</b> Attempt 0: The counter generator</a></li>
<li class="chapter" data-level="4.2.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>4.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li>
<li class="chapter" data-level="4.2.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>4.2.3</b> From insecurity to security</a></li>
<li class="chapter" data-level="4.2.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>4.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#successful-examples"><i class="fa fa-check"></i><b>4.3</b> Successful examples</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>4.3.1</b> Case Study 1: Subset Sum Generator</a></li>
<li class="chapter" data-level="4.3.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-2-rc4"><i class="fa fa-check"></i><b>4.3.2</b> Case Study 2: RC4</a></li>
<li class="chapter" data-level="4.3.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-3-blum-blum-and-shub"><i class="fa fa-check"></i><b>4.3.3</b> Case Study 3: Blum, Blum and Shub</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>4.4</b> Non-constructive existence of pseudorandom generators</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions</a>
<ul>
<li class="chapter" data-level="5.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>5.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>5.1.1</b> How do pseudorandom functions help in the login problem?</a></li>
<li class="chapter" data-level="5.1.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#modifying-input-and-output-lengths-of-prfs"><i class="fa fa-check"></i><b>5.1.2</b> Modifying input and output lengths of PRFs</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>5.2</b> Message Authentication Codes</a></li>
<li class="chapter" data-level="5.3" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>5.3</b> MACs from PRFs</a></li>
<li class="chapter" data-level="5.4" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#arbitrary-input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>5.4</b> Arbitrary input length extension for MACs and PRFs</a></li>
<li class="chapter" data-level="5.5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>5.5</b> Aside: natural proofs</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><i class="fa fa-check"></i><b>6</b> Pseudorandom functions from pseudorandom generators and CPA security</a>
<ul>
<li class="chapter" data-level="6.1" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>6.1</b> Securely encrypting many messages - chosen plaintext security</a></li>
<li class="chapter" data-level="6.2" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>6.2</b> Pseudorandom permutations / block ciphers</a></li>
<li class="chapter" data-level="6.3" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#encryption-modes"><i class="fa fa-check"></i><b>6.3</b> Encryption modes</a></li>
<li class="chapter" data-level="6.4" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>6.4</b> Optional, Aside: Broadcast Encryption</a></li>
<li class="chapter" data-level="6.5" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#reading-comprehension-exercises"><i class="fa fa-check"></i><b>6.5</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html"><i class="fa fa-check"></i><b>7</b> Chosen Ciphertext Security</a>
<ul>
<li class="chapter" data-level="7.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#short-recap"><i class="fa fa-check"></i><b>7.1</b> Short recap</a></li>
<li class="chapter" data-level="7.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#going-beyond-cpa"><i class="fa fa-check"></i><b>7.2</b> Going beyond CPA</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#example-the-wired-equivalence-privacy-wep"><i class="fa fa-check"></i><b>7.2.1</b> Example: The Wired Equivalence Privacy (WEP)</a></li>
<li class="chapter" data-level="7.2.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>7.2.2</b> Chosen ciphertext security</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>7.3</b> Constructing CCA secure encryption</a></li>
<li class="chapter" data-level="7.4" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>7.4</b> (Simplified) GCM encryption</a></li>
<li class="chapter" data-level="7.5" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>7.5</b> Padding, chopping, and their pitfalls: the “buffer overflow” of cryptography</a></li>
<li class="chapter" data-level="7.6" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>7.6</b> Chosen ciphertext attack as implementing metaphors</a></li>
<li class="chapter" data-level="7.7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#reading-comprehension-exercises-1"><i class="fa fa-check"></i><b>7.7</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="hash-functions-random-oracles-and-bitcoin.html"><a href="hash-functions-random-oracles-and-bitcoin.html"><i class="fa fa-check"></i><b>8</b> Hash Functions, Random Oracles, and Bitcoin</a></li>
<li class="chapter" data-level="9" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><i class="fa fa-check"></i><b>9</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a>
<ul>
<li class="chapter" data-level="9.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#keys-from-passwords"><i class="fa fa-check"></i><b>9.1</b> Keys from passwords</a></li>
<li class="chapter" data-level="9.2" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>9.2</b> Merkle trees and verifying storage.</a></li>
<li class="chapter" data-level="9.3" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>9.3</b> Proofs of Retrievability</a></li>
<li class="chapter" data-level="9.4" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#entropy-extraction"><i class="fa fa-check"></i><b>9.4</b> Entropy extraction</a>
<ul>
<li class="chapter" data-level="9.4.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>9.4.1</b> Forward and backward secrecy</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a>
<ul>
<li class="chapter" data-level="10.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li>
<li class="chapter" data-level="10.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a>
<ul>
<li class="chapter" data-level="10.3.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li>
<li class="chapter" data-level="10.3.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li>
<li class="chapter" data-level="10.3.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li>
<li class="chapter" data-level="10.3.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li>
<li class="chapter" data-level="10.3.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li>
<li class="chapter" data-level="10.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li>
<li class="chapter" data-level="10.6" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a>
<ul>
<li class="chapter" data-level="10.6.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a>
<ul>
<li class="chapter" data-level="11.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a>
<ul>
<li class="chapter" data-level="11.1.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li>
<li class="chapter" data-level="11.1.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li>
<li class="chapter" data-level="11.1.3" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li>
<li class="chapter" data-level="11.1.4" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li>
<li class="chapter" data-level="11.1.5" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.6" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.7" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li>
</ul></li>
<li class="chapter" data-level="11.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#extending-to-more-than-one-hardcore-bit"><i class="fa fa-check"></i><b>11.2.1</b> Extending to more than one hardcore bit</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a>
<ul>
<li class="chapter" data-level="12.0.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li>
<li class="chapter" data-level="12.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li>
<li class="chapter" data-level="12.2" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li>
<li class="chapter" data-level="12.3" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li>
<li class="chapter" data-level="12.4" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li>
<li class="chapter" data-level="12.5" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li>
<li class="chapter" data-level="12.6" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html"><i class="fa fa-check"></i><b>13</b> Establishing secure connections over insecure channels</a>
<ul>
<li class="chapter" data-level="13.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>13.1</b> Cryptography’s obsession with adjectives.</a></li>
<li class="chapter" data-level="13.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>13.2</b> Basic Key Exchange protocol</a></li>
<li class="chapter" data-level="13.3" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>13.3</b> Authenticated key exchange</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>13.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>13.4</b> Chosen ciphertext attack security for public key cryptography</a></li>
<li class="chapter" data-level="13.5" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>13.5</b> CCA secure public key encryption in the Random Oracle Model</a>
<ul>
<li class="chapter" data-level="13.5.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.1</b> Defining secure authenticated key exchange</a></li>
<li class="chapter" data-level="13.5.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.2</b> The compiler approach for authenticated key exchange</a></li>
</ul></li>
<li class="chapter" data-level="13.6" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>13.6</b> Password authenticated key exchange.</a></li>
<li class="chapter" data-level="13.7" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>13.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li>
<li class="chapter" data-level="13.8" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>13.8</b> Heartbleed and logjam attacks</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html"><i class="fa fa-check"></i><b>14</b> Zero knowledge proofs</a>
<ul>
<li class="chapter" data-level="14.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>14.1</b> Applications for zero knowledge proofs.</a>
<ul>
<li class="chapter" data-level="14.1.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#nuclear-disarmament"><i class="fa fa-check"></i><b>14.1.1</b> Nuclear disarmament</a></li>
<li class="chapter" data-level="14.1.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#voting"><i class="fa fa-check"></i><b>14.1.2</b> Voting</a></li>
<li class="chapter" data-level="14.1.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#more-applications"><i class="fa fa-check"></i><b>14.1.3</b> More applications</a></li>
</ul></li>
<li class="chapter" data-level="14.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>14.2</b> Defining and constructing zero knowledge proofs</a></li>
<li class="chapter" data-level="14.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>14.3</b> Defining zero knowledge</a></li>
<li class="chapter" data-level="14.4" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>14.4</b> Zero knowledge proof for Hamiltonicity.</a>
<ul>
<li class="chapter" data-level="14.4.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#why-is-this-interesting"><i class="fa fa-check"></i><b>14.4.1</b> Why is this interesting?</a></li>
</ul></li>
<li class="chapter" data-level="14.5" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>14.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a>
<ul>
<li class="chapter" data-level="14.5.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>14.5.1</b> “Bonus features” of zero knowledge</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="chapfheone.html"><a href="chapfheone.html"><i class="fa fa-check"></i><b>15</b> Fully homomorphic encryption: Introduction and bootstrapping</a>
<ul>
<li class="chapter" data-level="15.1" data-path="chapfheone.html"><a href="chapfheone.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>15.1</b> Defining fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.1.1" data-path="chapfheone.html"><a href="chapfheone.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>15.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="chapfheone.html"><a href="chapfheone.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>15.2</b> Example: An XOR homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.2.1" data-path="chapfheone.html"><a href="chapfheone.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>15.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="chapfheone.html"><a href="chapfheone.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>15.3</b> From linear homomorphism to full homomorphism</a></li>
<li class="chapter" data-level="15.4" data-path="chapfheone.html"><a href="chapfheone.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>15.4</b> Bootstrapping: Fully Homomorphic “escape velocity”</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="chapfheone.html"><a href="chapfheone.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>15.4.1</b> Radioactive legos analogy</a></li>
<li class="chapter" data-level="15.4.2" data-path="chapfheone.html"><a href="chapfheone.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>15.4.2</b> Proving the bootstrapping theorem</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="chapfhetwo.html"><a href="chapfhetwo.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Construction</a>
<ul>
<li class="chapter" data-level="16.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>16.1</b> Prelude: from vectors to matrices</a></li>
<li class="chapter" data-level="16.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Real world partially homomorphic encryption</a></li>
<li class="chapter" data-level="16.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>16.3</b> Noise management via encoding</a></li>
<li class="chapter" data-level="16.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#putting-it-all-together"><i class="fa fa-check"></i><b>16.4</b> Putting it all together</a></li>
<li class="chapter" data-level="16.5" data-path="chapfhetwo.html"><a href="chapfhetwo.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>16.5</b> Analysis of our scheme</a>
<ul>
<li class="chapter" data-level="16.5.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#correctness"><i class="fa fa-check"></i><b>16.5.1</b> Correctness</a></li>
<li class="chapter" data-level="16.5.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#cpa-security"><i class="fa fa-check"></i><b>16.5.2</b> CPA Security</a></li>
<li class="chapter" data-level="16.5.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#homomorphism"><i class="fa fa-check"></i><b>16.5.3</b> Homomorphism</a></li>
<li class="chapter" data-level="16.5.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>16.5.4</b> Shallow decryption circuit</a></li>
</ul></li>
<li class="chapter" data-level="16.6" data-path="chapfhetwo.html"><a href="chapfhetwo.html#advanced-topics"><i class="fa fa-check"></i><b>16.6</b> Advanced topics:</a>
<ul>
<li class="chapter" data-level="16.6.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#fully-homomorphic-encryption-for-approximate-computation-over-the-real-numbers-ckks"><i class="fa fa-check"></i><b>16.6.1</b> Fully homomorphic encryption for approximate computation over the real numbers: CKKS</a></li>
<li class="chapter" data-level="16.6.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#bandwidth-efficient-fully-homomorphic-encryption-gh"><i class="fa fa-check"></i><b>16.6.2</b> Bandwidth efficient fully homomorphic encryption GH</a></li>
<li class="chapter" data-level="16.6.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#using-fully-homomorphic-encryption-to-achieve-private-information-retrieval."><i class="fa fa-check"></i><b>16.6.3</b> Using fully homomorphic encryption to achieve private information retrieval.</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="sfeonechap.html"><a href="sfeonechap.html"><i class="fa fa-check"></i><b>17</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a>
<ul>
<li class="chapter" data-level="17.1" data-path="sfeonechap.html"><a href="sfeonechap.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>17.1</b> Ideal vs. Real Model Security.</a></li>
<li class="chapter" data-level="17.2" data-path="sfeonechap.html"><a href="sfeonechap.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>17.2</b> Formally defining secure multiparty computation</a>
<ul>
<li class="chapter" data-level="17.2.1" data-path="sfeonechap.html"><a href="sfeonechap.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>17.2.1</b> First attempt: a slightly “too ideal” definition</a></li>
<li class="chapter" data-level="17.2.2" data-path="sfeonechap.html"><a href="sfeonechap.html#allowing-for-aborts"><i class="fa fa-check"></i><b>17.2.2</b> Allowing for aborts</a></li>
<li class="chapter" data-level="17.2.3" data-path="sfeonechap.html"><a href="sfeonechap.html#some-comments"><i class="fa fa-check"></i><b>17.2.3</b> Some comments:</a></li>
</ul></li>
<li class="chapter" data-level="17.3" data-path="sfeonechap.html"><a href="sfeonechap.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>17.3</b> Example: Second price auction using bitcoin</a>
<ul>
<li class="chapter" data-level="17.3.1" data-path="sfeonechap.html"><a href="sfeonechap.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>17.3.1</b> Another example: distributed and threshold cryptography</a></li>
</ul></li>
<li class="chapter" data-level="17.4" data-path="sfeonechap.html"><a href="sfeonechap.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>17.4</b> Proving the fundamental theorem:</a></li>
<li class="chapter" data-level="17.5" data-path="sfeonechap.html"><a href="sfeonechap.html#hbctomalred"><i class="fa fa-check"></i><b>17.5</b> Malicious to honest but curious reduction</a>
<ul>
<li class="chapter" data-level="17.5.1" data-path="sfeonechap.html"><a href="sfeonechap.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>17.5.1</b> Handling probabilistic strategies:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="sfetwochap.html"><a href="sfetwochap.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a>
<ul>
<li class="chapter" data-level="18.1" data-path="sfetwochap.html"><a href="sfetwochap.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li>
<li class="chapter" data-level="18.2" data-path="sfetwochap.html"><a href="sfetwochap.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.2</b> Achieving circuit privacy in a fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="18.2.1" data-path="sfetwochap.html"><a href="sfetwochap.html#bottom-line-a-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>18.2.1</b> Bottom line: A two party secure computation protocol</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="sfetwochap.html"><a href="sfetwochap.html#beyond-two-parties"><i class="fa fa-check"></i><b>18.3</b> Beyond two parties</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html"><i class="fa fa-check"></i><b>19</b> Quantum computing and cryptography I</a>
<ul>
<li class="chapter" data-level="19.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>19.1</b> The double slit experiment</a></li>
<li class="chapter" data-level="19.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-amplitudes"><i class="fa fa-check"></i><b>19.2</b> Quantum amplitudes</a>
<ul>
<li class="chapter" data-level="19.2.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>19.2.1</b> Quantum computing and computation - an executive summary.</a></li>
</ul></li>
<li class="chapter" data-level="19.3" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-101"><i class="fa fa-check"></i><b>19.3</b> Quantum 101</a>
<ul>
<li class="chapter" data-level="19.3.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>19.3.1</b> Physically realizing quantum computation</a></li>
<li class="chapter" data-level="19.3.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bra-ket-notation"><i class="fa fa-check"></i><b>19.3.2</b> Bra-ket notation</a></li>
</ul></li>
<li class="chapter" data-level="19.4" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bells-inequality"><i class="fa fa-check"></i><b>19.4</b> Bell’s Inequality</a></li>
<li class="chapter" data-level="19.5" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#analysis-of-bells-inequality"><i class="fa fa-check"></i><b>19.5</b> Analysis of Bell’s Inequality</a></li>
<li class="chapter" data-level="19.6" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#grovers-algorithm"><i class="fa fa-check"></i><b>19.6</b> Grover’s Algorithm</a></li>
</ul></li>
<li class="chapter" data-level="20" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography II</a>
<ul>
<li class="chapter" data-level="20.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>20.1</b> From order finding to factoring and discrete log</a></li>
<li class="chapter" data-level="20.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>20.2</b> Finding periods of a function: Simon’s Algorithm</a></li>
<li class="chapter" data-level="20.3" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-simon-to-shor"><i class="fa fa-check"></i><b>20.3</b> From Simon to Shor</a>
<ul>
<li class="chapter" data-level="20.3.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#the-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.1</b> The Fourier transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
<li class="chapter" data-level="20.3.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.2</b> Quantum Fourier Transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.4" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#shor鈥檚-order-finding-algorithm."><i class="fa fa-check"></i><b>20.4</b> Shor鈥檚 Order-Finding Algorithm.</a>
<ul>
<li class="chapter" data-level="20.4.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>20.4.1</b> Analysis: the case that <span class="math inline">\(r|m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.5" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>20.5</b> Rational approximation of real numbers</a>
<ul>
<li class="chapter" data-level="20.5.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-cryptography"><i class="fa fa-check"></i><b>20.5.1</b> Quantum cryptography</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="21" data-path="software-obfuscation.html"><a href="software-obfuscation.html"><i class="fa fa-check"></i><b>21</b> Software Obfuscation</a>
<ul>
<li class="chapter" data-level="21.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>21.1</b> Witness encryption</a></li>
<li class="chapter" data-level="21.2" data-path="software-obfuscation.html"><a href="software-obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>21.2</b> Deniable encryption</a></li>
<li class="chapter" data-level="21.3" data-path="software-obfuscation.html"><a href="software-obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>21.3</b> Functional encryption</a></li>
<li class="chapter" data-level="21.4" data-path="software-obfuscation.html"><a href="software-obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>21.4</b> The software patch problem</a></li>
<li class="chapter" data-level="21.5" data-path="software-obfuscation.html"><a href="software-obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>21.5</b> Software obfuscation</a></li>
<li class="chapter" data-level="21.6" data-path="software-obfuscation.html"><a href="software-obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>21.6</b> Applications of obfuscation</a></li>
<li class="chapter" data-level="21.7" data-path="software-obfuscation.html"><a href="software-obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>21.7</b> Impossibility of obfuscation</a>
<ul>
<li class="chapter" data-level="21.7.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>21.7.1</b> Proof of impossibility of VBB obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="21.8" data-path="software-obfuscation.html"><a href="software-obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>21.8</b> Indistinguishability obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html"><i class="fa fa-check"></i><b>22</b> More obfuscation, exotic encryptions</a>
<ul>
<li class="chapter" data-level="22.1" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>22.1</b> Slower, weaker, less securer</a></li>
<li class="chapter" data-level="22.2" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>22.2</b> How to get IBE from pairing based assumptions.</a></li>
<li class="chapter" data-level="22.3" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>22.3</b> Beyond pairing based cryptography</a></li>
</ul></li>
<li class="chapter" data-level="23" data-path="anonymous-communication.html"><a href="anonymous-communication.html"><i class="fa fa-check"></i><b>23</b> Anonymous communication</a>
<ul>
<li class="chapter" data-level="23.1" data-path="anonymous-communication.html"><a href="anonymous-communication.html#steganography"><i class="fa fa-check"></i><b>23.1</b> Steganography</a></li>
<li class="chapter" data-level="23.2" data-path="anonymous-communication.html"><a href="anonymous-communication.html#anonymous-routing"><i class="fa fa-check"></i><b>23.2</b> Anonymous routing</a></li>
<li class="chapter" data-level="23.3" data-path="anonymous-communication.html"><a href="anonymous-communication.html#tor"><i class="fa fa-check"></i><b>23.3</b> Tor</a></li>
<li class="chapter" data-level="23.4" data-path="anonymous-communication.html"><a href="anonymous-communication.html#telex"><i class="fa fa-check"></i><b>23.4</b> Telex</a></li>
<li class="chapter" data-level="23.5" data-path="anonymous-communication.html"><a href="anonymous-communication.html#riposte"><i class="fa fa-check"></i><b>23.5</b> Riposte</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html"><i class="fa fa-check"></i><b>24</b> Ethical, moral, and policy dimensions to cryptography</a>
<ul>
<li class="chapter" data-level="24.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>24.1</b> Reading prior to lecture:</a></li>
<li class="chapter" data-level="24.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#case-studies."><i class="fa fa-check"></i><b>24.2</b> Case studies.</a>
<ul>
<li class="chapter" data-level="24.2.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#the-snowden-revelations"><i class="fa fa-check"></i><b>24.2.1</b> The Snowden revelations</a></li>
<li class="chapter" data-level="24.2.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>24.2.2</b> FBI vs Apple case</a></li>
<li class="chapter" data-level="24.2.3" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>24.2.3</b> Juniper backdoor case and the OPM break-in</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="25" data-path="course-recap.html"><a href="course-recap.html"><i class="fa fa-check"></i><b>25</b> Course recap</a>
<ul>
<li class="chapter" data-level="25.1" data-path="course-recap.html"><a href="course-recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>25.1</b> Some things we did not cover</a></li>
<li class="chapter" data-level="25.2" data-path="course-recap.html"><a href="course-recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>25.2</b> What I hope you learned</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">A Minimal Book Example</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="quantum-computing-and-cryptography-ii" class="section level1 hasAnchor" number="20">
<h1><span class="header-section-number">20</span> Quantum computing and cryptography II<a href="quantum-computing-and-cryptography-ii.html#quantum-computing-and-cryptography-ii" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Bell’s Inequality is powerful demonstration that there is something very strange going on with quantum mechanics.
But could this “strangeness” be of any use to solve computational problems not directly related to quantum systems?
A priori, one could guess the answer is <em>no</em>.
In 1994 Peter Shor showed that one would be wrong:</p>
<blockquote>
<h1 id="shorthm" class="theorem" title="Shor&#39;s Theorem"></h1>
<p>The map that takes an integer <span class="math inline">\(m\)</span> into its prime factorization is efficiently quantumly computable. Specifically, it can be computed using <span class="math inline">\(O(\log^3 m)\)</span> quantum gates.</p>
</blockquote>
<p>This is an exponential improvement over the best known classical algorithms, which as we mentioned before, take roughly <span class="math inline">\(2^{\tilde{O(\log^{1/3}m)}}\)</span> time.</p>
<p>We will now sketch the ideas behind Shor’s algorithm. In fact, Shor proved the following more general theorem:</p>
<blockquote>
<h1 id="hiddengroupthm" class="theorem" title="Order Finding Algorithm"></h1>
<p>There is a quantum polynomial time algorithm that given a multiplicative Abelian group <span class="math inline">\(\mathbb{G}\)</span> and element <span class="math inline">\(g\in\mathbb{G}\)</span> computes the <em>order</em> of <span class="math inline">\(g\)</span> in the group.</p>
</blockquote>
<p>Recall that the order of <span class="math inline">\(g\)</span> in <span class="math inline">\(\mathbb{G}\)</span> is the smallest positive integer <span class="math inline">\(a\)</span> such that <span class="math inline">\(g^a = 1\)</span>. By “given a group” we mean that we can represent the elements of the group as strings of length <span class="math inline">\(O(\log |\mathbb{G}|)\)</span> and there is a <span class="math inline">\(poly(\log|\mathbb{G}|)\)</span> algorithm to perform multiplication
in the group.</p>
<div id="from-order-finding-to-factoring-and-discrete-log" class="section level2 hasAnchor" number="20.1">
<h2><span class="header-section-number">20.1</span> From order finding to factoring and discrete log<a href="quantum-computing-and-cryptography-ii.html#from-order-finding-to-factoring-and-discrete-log" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The order finding problem allows not just to factor integers in polynomial time, but also solve the discrete logarithm over arbitrary Abelian groups, hereby showing that quantum computers will break not just RSA but also Diffie Hellman and Elliptic Curve Cryptography.
We merely sketch how one reduces the factoring and discrete logarithm problems to order finding: (see some of the sources above for the full details)</p>
<ul>
<li><p>For <strong>factoring</strong>, let us restrict to the case <span class="math inline">\(m=pq\)</span> for distinct <span class="math inline">\(p,q\)</span>. Recall that we showed that finding the size <span class="math inline">\((p-1)(q-1)=m-p-q+1\)</span> of the group <span class="math inline">\(\mathbb{Z}^*_m\)</span> is sufficient to recover <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>. One can show that if we pick a few random <span class="math inline">\(x\)</span>’s in <span class="math inline">\(\mathbb{Z}^*_m\)</span> and compute their order, the least common multiplier of these orders is likely to be the group size.</p></li>
<li><p>For <strong>discrete log</strong> in a group <span class="math inline">\(\mathbb{G}\)</span>, if we get <span class="math inline">\(X=g^x\)</span> and need to recover <span class="math inline">\(x\)</span>, we can compute the order of various elements of the form <span class="math inline">\(X^ag^b\)</span>. The order of such an element is a number <span class="math inline">\(c\)</span> satisfying <span class="math inline">\(c(xa+b) = 0 \pmod{|\mathbb{G}|}\)</span>. Again, with a few random examples we will get a non trivial example (where <span class="math inline">\(c \neq 0 \pmod{|\mathbb{G}|}\)</span> ) and be able to recover the unknown <span class="math inline">\(x\)</span>.</p></li>
</ul>
</div>
<div id="finding-periods-of-a-function-simons-algorithm" class="section level2 hasAnchor" number="20.2">
<h2><span class="header-section-number">20.2</span> Finding periods of a function: Simon’s Algorithm<a href="quantum-computing-and-cryptography-ii.html#finding-periods-of-a-function-simons-algorithm" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let <span class="math inline">\(\mathbb{H}\)</span> be some Abelian group with a group operation that we’ll denote by <span class="math inline">\(\oplus\)</span>, and <span class="math inline">\(f\)</span> be some function mapping <span class="math inline">\(\mathbb{H}\)</span> to an arbitrary set (which we can encode as <span class="math inline">\(\{0,1\}^*\)</span>).
We say that <span class="math inline">\(f\)</span> has <em>period <span class="math inline">\(h^*\)</span></em> for some <span class="math inline">\(h^*\in\mathbb{H}\)</span> if for every <span class="math inline">\(x,y \in \mathbb{H}\)</span>, <span class="math inline">\(f(x)=f(y)\)</span> if and only if <span class="math inline">\(y = x \oplus kh^*\)</span> for some integer <span class="math inline">\(k\)</span>.
Note that if <span class="math inline">\(\mathbb{G}\)</span> is some Abelian group, then if we define <span class="math inline">\(\mathbb{H}=\mathbb{Z}_{|\mathbb{G}|}\)</span>, for every element <span class="math inline">\(g\in \mathbb{G}\)</span>, the map <span class="math inline">\(f(a)=g^a\)</span> is a periodic map over <span class="math inline">\(\mathbb{H}\)</span> with period the order of <span class="math inline">\(g\)</span>.
So, finding the order of an item reduces to the question of finding the period of a function.</p>
<p>How do we generally find the period of a function? Let us consider the simplest case, where <span class="math inline">\(f\)</span> is a function from <span class="math inline">\(\mathbb{R}\)</span> to <span class="math inline">\(\mathbb{R}\)</span> that is <span class="math inline">\(h^*\)</span> periodic for some number <span class="math inline">\(h^*\)</span>, in the sense that <span class="math inline">\(f\)</span> repeats itself on the intervals <span class="math inline">\([0,h^*]\)</span>, <span class="math inline">\([h^*,2h^*]\)</span>, <span class="math inline">\([2h^*,3h^*]\)</span>, etc..
How do we find this number <span class="math inline">\(h^*\)</span>?
The key idea would be to transform <span class="math inline">\(f\)</span> from the <em>time</em> to the <em>frequency</em> domain.
That is, we use the <em>Fourier transform</em> to represent <span class="math inline">\(f\)</span> as a sum of wave functions. In this representation wavelengths that divide the period <span class="math inline">\(h^*\)</span> would get significant mass, while wavelengths that don’t would likely “cancel out”.</p>
<div class="float" id="tmplabelfig">
<img src="../figure/quantum_fourier.jpg" alt="If f is a periodic function then when we represent it in the Fourier transform, we expect the coefficients corresponding to wavelengths that do not evenly divide the period to be very small, as they would tend to “cancel out”." />
<div class="figcaption">If <span class="math inline">\(f\)</span> is a periodic function then when we represent it in the Fourier transform, we expect the coefficients corresponding to wavelengths that do not evenly divide the period to be very small, as they would tend to “cancel out”.</div>
</div>
<p>Similarly, the main idea behind Shor’s algorithm is to use a tool known as the <em>quantum fourier transform</em> that given a circuit computing the function <span class="math inline">\(f:\mathbb{H}\rightarrow\mathbb{R}\)</span>, creates a quantum state over roughly <span class="math inline">\(\log |\mathbb{H}|\)</span> qubits (and hence dimension <span class="math inline">\(|\mathbb{H}|\)</span>) that corresponds to the Fourier transform of <span class="math inline">\(f\)</span>.
Hence when we measure this state, we get a group element <span class="math inline">\(h\)</span> with probability proportional to the square of the corresponding Fourier coefficient.
One can show that if <span class="math inline">\(f\)</span> is <span class="math inline">\(h^*\)</span>-periodic then we can recover <span class="math inline">\(h^*\)</span> from this distribution.</p>
<p>Shor carried out this approach for the group <span class="math inline">\(\mathbb{H}=\mathbb{Z}^*_q\)</span> for some <span class="math inline">\(q\)</span>, but we will start be seeing this for the group <span class="math inline">\(\mathbb{H} = \{0,1\}^n\)</span> with the XOR operation.
This case is known as <em>Simon’s algorithm</em> (given by Dan Simon in 1994) and actually preceded (and inspired) Shor’s algorithm:</p>
<blockquote>
<h1 id="simonsthm" class="theorem" title="Simon&#39;s Algorithm"></h1>
<p>If <span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}^*\)</span> is polynomial time computable and satisfies the property that <span class="math inline">\(f(x)=f(y)\)</span> iff <span class="math inline">\(x\oplus y = h^*\)</span> then there exists
a quantum polynomial-time algorithm that outputs a random <span class="math inline">\(h\in \{0,1\}^n\)</span> such that <span class="math inline">\(\langle h,h^* \rangle=0 \pmod{2}\)</span>.</p>
</blockquote>
<p>Note that given <span class="math inline">\(O(n)\)</span> such samples, we can recover <span class="math inline">\(h^*\)</span> with high probability by solving the corresponding linear equations.</p>
<blockquote>
<h1 id="section-98" class="proof"></h1>
<p>Let <span class="math inline">\(HAD\)</span> be the <span class="math inline">\(2\times 2\)</span> unitary matrix corresponding to the one qubit operation <span class="math inline">\(|0\rangle \mapsto \tfrac{1}{\sqrt{2}}(|0\rangle+|1\rangle)\)</span> and
<span class="math inline">\(|1\rangle \mapsto \tfrac{1}{\sqrt{2}}(|0\rangle-|1\rangle)\)</span> or <span class="math inline">\(|a\rangle\mapsto \tfrac{1}{\sqrt{2}}(|0\rangle+(-1)^a|1\rangle)\)</span>.
Given the state <span class="math inline">\(|0^{n+m\rangle}\)</span> we can apply this map to each one of the first <span class="math inline">\(n\)</span> qubits to get the state
<span class="math inline">\(2^{-n/2}\sum_{x\in\{0,1\}^n}|x\rangle|0^m\rangle\)</span>
and then we can apply the gates of <span class="math inline">\(f\)</span> to map this to the state
<span class="math inline">\(2^{-n/2}\sum_{x\in\{0,1\}^n}|x\rangle|f(x)\rangle\)</span>
now suppose that we apply this operation again to the first <span class="math inline">\(n\)</span> qubits then we get the state
<span class="math inline">\(2^{-n}\sum_{x\in\{0,1\}^n}\prod_{i=1}^n(|0\rangle+(-1)^{x_i}|1\rangle)|f(x)\rangle\)</span>
which if we open up each one of these product and look at all <span class="math inline">\(2^n\)</span> choices <span class="math inline">\(y\in\{0,1\}^n\)</span> (with <span class="math inline">\(y_i=0\)</span> corresponding to picking <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(y_i=1\)</span> corresponding to picking <span class="math inline">\(|1\rangle\)</span> in the <span class="math inline">\(i^{th}\)</span> product) we get
<span class="math inline">\(2^{-n}\sum_{x\in\{0,1\}^n}\sum_{y\in\{0,1\}^n}(-1)^{\langle x,y \rangle}|y\rangle|f(x)\rangle\)</span>.
Now under our assumptions for every particular <span class="math inline">\(z\)</span> in the image of <span class="math inline">\(f\)</span>, there exist exactly two preimages <span class="math inline">\(x\)</span> and <span class="math inline">\(x\oplus h^*\)</span> such that <span class="math inline">\(f(x)=f(x+h^*)=z\)</span>.
So, if <span class="math inline">\(\langle y,h^* \rangle=0 \pmod{2}\)</span>, we get that <span class="math inline">\((-1)^{\langle x,y \rangle}+(-1)^{\langle x,y+h^* \rangle}=2\)</span> and otherwise we get <span class="math inline">\((-1)^{\langle x,y \rangle}+(-1)^{\langle x,y+h^* \rangle}=0\)</span>.
Therefore, if measure the state we will get a pair <span class="math inline">\((y,z)\)</span> such that <span class="math inline">\(\langle y,h^* \rangle=0 \pmod{2}\)</span>. QED</p>
</blockquote>
<p>Simon’s algorithm seems to really use the special bit-wise structure of the group <span class="math inline">\(\{0,1\}^n\)</span>, so one could wonder if it has any relevance for the group <span class="math inline">\(\mathbb{Z}^*_m\)</span> for some exponentially large <span class="math inline">\(m\)</span>.
It turns out that the same insights that underlie the well known Fast Fourier Transform (FFT) algorithm can be used to essentially follow the same strategy for this group as well.</p>
</div>
<div id="from-simon-to-shor" class="section level2 hasAnchor" number="20.3">
<h2><span class="header-section-number">20.3</span> From Simon to Shor<a href="quantum-computing-and-cryptography-ii.html#from-simon-to-shor" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>(Note: The presentation here is adapted from the quantum computing chapter in my textbook with Arora.)</p>
<p>We now describe how to achieve Shor’s algorithm for order finding. We will not do this for a general group but rather focus our attention on the group <span class="math inline">\(\mathbb{Z}^*_{\ell}\)</span> for some number <span class="math inline">\(\ell\)</span> which is the case of interest for integer factoring and the discrete logarithm modulo primes problems.</p>
<p>That is, we prove the following theorem:</p>
<blockquote>
<h1 id="shortwothm" class="theorem" title="Shor&#39;s Algorithm, restated"></h1>
<p>For every <span class="math inline">\(\ell\)</span> and <span class="math inline">\(a\in\mathbb{Z}^*_\ell\)</span>, there is a quantum <span class="math inline">\(poly(log \ell)\)</span> algorithm to find the order of <span class="math inline">\(a\)</span> in <span class="math inline">\(\mathbb{Z}^*_\ell\)</span>.</p>
</blockquote>
<p>The idea is similar to Simon’s algorithm. We consider the map <span class="math inline">\(x \mapsto a^x (\mod \ell)\)</span> which is a periodic map over <span class="math inline">\(\mathbb{Z}_m\)</span> where <span class="math inline">\(m=|\mathbb{Z}^*_\ell|\)</span> with period being the order of <span class="math inline">\(a\)</span>.<br />
To find the period of this map we will now need to perform a <em>Quantum Fourier Transform (QFT)</em> over the group <span class="math inline">\(\mathbb{Z}_m\)</span> instead of <span class="math inline">\(\{0,1\}^n\)</span>.
This is a quantum algorithm that takes a register from some arbitrary
state <span class="math inline">\(f \in \mathbb{C}^{m}\)</span> into a state whose vector is the Fourier transform
<span class="math inline">\(\hat{f}\)</span> of <span class="math inline">\(f\)</span>. The QFT takes only <span class="math inline">\(O(\log^2 m)\)</span> elementary steps and
is thus very efficient. Note that we cannot say that this algorithm
鈥渃omputes鈥? the Fourier transform, since the transform is stored in the
amplitudes of the state, and as mentioned earlier, quantum mechanics
give no way to 鈥渞ead out鈥? the amplitudes per se. The only way to get
information from a quantum state is by <em>measuring</em> it, which yields a
single basis state with probability that is related to its amplitude.
This is hardly representative of the entire Fourier transform vector,
but sometimes (as is the case in Shor鈥檚 algorithm) this is enough to get
highly non-trivial information, which we do not know how to obtain using
classical (non-quantum) computers.</p>
<div id="the-fourier-transform-over-mathbbz_m" class="section level3 hasAnchor" number="20.3.1">
<h3><span class="header-section-number">20.3.1</span> The Fourier transform over <span class="math inline">\(\mathbb{Z}_m\)</span><a href="quantum-computing-and-cryptography-ii.html#the-fourier-transform-over-mathbbz_m" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We now define the Fourier transform over <span class="math inline">\(\mathbb{Z}_m\)</span> (the group of integers
in <span class="math inline">\(\{0,\ldots,m-1\}\)</span> with addition modulo <span class="math inline">\(m\)</span>). We give a definition that is specialized to the current context.
For every vector <span class="math inline">\(f\in\mathbb{C}^m\)</span>, the <em>Fourier transform of <span class="math inline">\(f\)</span></em> is the
vector <span class="math inline">\(\hat{f}\)</span> where the <span class="math inline">\(x^{th}\)</span> coordinate of <span class="math inline">\(\hat{f}\)</span> is defined as[^8]</p>
<p><span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}}\sum_{y\in\mathbb{Z}_m} f(x)\omega^{xy}\)</span></p>
<p>where <span class="math inline">\(\omega = e^{2\pi i/m}\)</span>.</p>
<p>The Fourier transform is simply a representation of <span class="math inline">\(f\)</span> in the <em>Fourier basis</em> <span class="math inline">\(\{  \chi_x \}_{x \in \mathbb{Z}_m}\)</span>, where <span class="math inline">\(\chi_x\)</span> is the
vector/function whose <span class="math inline">\(y^{th}\)</span> coordinate is
<span class="math inline">\(\tfrac{1}{\sqrt{m}\omega^{xy}}\)</span>. Now the inner product of any two vectors
<span class="math inline">\(\chi_x,\chi_z\)</span> in this basis is equal to
<span class="math display">\[\langle \chi_x,\chi_z \rangle = \tfrac{1}{m}\sum_{y\in\mathbb{Z}_m} \omega^{xy} \overline{\omega^{zy}} = \tfrac{1}{m}\sum_{y\in\mathbb{Z}_m} \omega^{(x-z)y}  \;.\]</span>
But if <span class="math inline">\(x=z\)</span> then <span class="math inline">\(\omega^{(x-z)}=1\)</span> and hence this sum is equal to <span class="math inline">\(1\)</span>. On
the other hand, if <span class="math inline">\(x \neq z\)</span>, then this sum is equal to
<span class="math inline">\(\tfrac{1}{m} \tfrac{1 -\omega^{(x-y)m}}{1-\omega^{x-y}}=
\tfrac{1}{m}\tfrac{1-1}{1-\omega^{x-y}}=0\)</span> using the formula for the sum of
a geometric series. In other words, this is an <em>orthonormal</em> basis which
means that the Fourier transform map <span class="math inline">\(f \mapsto \hat{f}\)</span> is a <em>unitary</em>
operation.</p>
<p>What is so special about the Fourier basis? For one thing, if we
identify vectors in <span class="math inline">\(\mathbb{C}^m\)</span> with functions mapping <span class="math inline">\(\mathbb{Z}_m\)</span> to <span class="math inline">\(\mathbb{C}\)</span>, then
it鈥檚 easy to see that every function <span class="math inline">\(\chi\)</span> in the Fourier basis is a
<em>homomorphism</em> from <span class="math inline">\(\mathbb{Z}_m\)</span> to <span class="math inline">\(\mathbb{C}\)</span> in the sense that
<span class="math inline">\(\chi(y+z)= \chi(y)\chi(z)\)</span> for every <span class="math inline">\(y,z \in
\mathbb{Z}_m\)</span>. Also, every function <span class="math inline">\(\chi\)</span> is <em>periodic</em> in the sense that there
exists <span class="math inline">\(r\in \mathbb{Z}_m\)</span> such that <span class="math inline">\(\chi(y+r)=\chi(z)\)</span> for every <span class="math inline">\(y\in \mathbb{Z}_m\)</span>
(indeed if <span class="math inline">\(\chi(y) =
\omega^{xy}\)</span> then we can take <span class="math inline">\(r\)</span> to be <span class="math inline">\(\ell/x\)</span> where <span class="math inline">\(\ell\)</span> is the least
common multiple of <span class="math inline">\(x\)</span> and <span class="math inline">\(m\)</span>). Thus, intuitively, if a function
<span class="math inline">\(f:\mathbb{Z}_m\rightarrow\mathbb{C}\)</span> is itself periodic (or roughly periodic) then when
representing <span class="math inline">\(f\)</span> in the Fourier basis, the coefficients of basis vectors
with periods agreeing with the period of <span class="math inline">\(f\)</span> should be large, and so we
might be able to discover <span class="math inline">\(f\)</span>鈥檚 period from this representation. This
does turn out to be the case, and is a crucial point in Shor鈥檚
algorithm.</p>
<div id="fast-fourier-transform." class="section level4 hasAnchor" number="20.3.1.1">
<h4><span class="header-section-number">20.3.1.1</span> Fast Fourier Transform.<a href="quantum-computing-and-cryptography-ii.html#fast-fourier-transform." class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Denote by <span class="math inline">\(FT_m\)</span> the operation that maps every vector <span class="math inline">\(f\in\mathbb{C}^m\)</span> to its
Fourier transform <span class="math inline">\(\hat{f}\)</span>. The operation <span class="math inline">\(FT_m\)</span> is represented by an
<span class="math inline">\(m\times m\)</span> matrix whose <span class="math inline">\((x,y)\)</span>th entry is <span class="math inline">\(\omega^{xy}\)</span>. The trivial
algorithm to compute it takes <span class="math inline">\(m^2\)</span> operations. The famous <em>Fast Fourier
Transform</em> (FFT) algorithm computes the Fourier transform in
<span class="math inline">\(O(m\log m)\)</span> operations. We now sketch the idea behind the FFT algorithm as
the same idea is used in the <em>quantum</em> Fourier transform algorithm.</p>
<p>Note that</p>
<p><span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}}\sum_{y\in\mathbb{Z}_m} f(y)\omega^{xy} =\)</span></p>
<p><span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{y\in\mathbb{Z}_m,y \;even} f(y)\omega^{-2x(y/2)} + \omega^x\tfrac{1}{\sqrt{m}}\sum_{y\in\mathbb{Z}_m,y \;odd} f(y)\omega^{2x(y-1)/2} \;.\)</span></p>
<p>Now since <span class="math inline">\(\omega^2\)</span> is an <span class="math inline">\(m/2\)</span>th root of unity and <span class="math inline">\(\omega^{m/2}=-1\)</span>, letting
<span class="math inline">\(W\)</span> be the <span class="math inline">\(m/2 \times m/2\)</span> diagonal matrix with diagonal entries
<span class="math inline">\(\omega^0,\ldots,\omega^{m/2-1}\)</span>, we get that</p>
<p><span class="math inline">\(FT_m(f)_{low} = FT_{m/2}(f_{even}) + W FT_{m/2}(f_{odd})\)</span></p>
<p><span class="math inline">\(FT_m(f)_{high} = FT_{m/2}(f_{even}) - W FT_{m/2}(f_{odd})\)</span></p>
<p>where for an <span class="math inline">\(m\)</span>-dimensional vector <span class="math inline">\(\vec{v}\)</span>, we denote by <span class="math inline">\(\vec{v}_{even}\)</span> (resp. <span class="math inline">\(\vec{v}_{odd}\)</span>)
the <span class="math inline">\(m/2\)</span>-dimensional vector obtained by restricting <span class="math inline">\(\vec{v}\)</span> to the
coordinates whose indices have least significant bit equal to <span class="math inline">\(0\)</span> (resp.
<span class="math inline">\(1\)</span>) and by <span class="math inline">\(\vec{v}_{low}\)</span> (resp. <span class="math inline">\(\vec{v}_{high}\)</span>) the restriction of
<span class="math inline">\(\vec{v}\)</span> to coordinates with most significant bit <span class="math inline">\(0\)</span> (resp. <span class="math inline">\(1\)</span>).</p>
<p>The equations above are the crux
of the divide-and-conquer idea of the FFT algorithm, since they allow to
replace a size-<span class="math inline">\(m\)</span> problem with two size-<span class="math inline">\(m/2\)</span> subproblems, leading to a
recursive time bound of the form <span class="math inline">\(T(m) = 2T(m/2) + O(m)\)</span> which solves to
<span class="math inline">\(T(m)=O(m\log m)\)</span>.</p>
</div>
</div>
<div id="quantum-fourier-transform-over-mathbbz_m" class="section level3 hasAnchor" number="20.3.2">
<h3><span class="header-section-number">20.3.2</span> Quantum Fourier Transform over <span class="math inline">\(\mathbb{Z}_m\)</span><a href="quantum-computing-and-cryptography-ii.html#quantum-fourier-transform-over-mathbbz_m" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The <em>quantum Fourier transform</em> is an algorithm to change the state of a
quantum register from <span class="math inline">\(f \in \mathbb{C}^m\)</span> to its Fourier transform <span class="math inline">\(\hat{f}\)</span>.</p>
<blockquote>
<h1 id="quantumftthm" class="theorem" title="Quantum Fourier Transform (Bernstein-Vazirani)"></h1>
<p>For every <span class="math inline">\(m\)</span> and <span class="math inline">\(m =2^m\)</span> there is a quantum algorithm that uses
<span class="math inline">\(O(m^2)\)</span> elementary quantum operations and transforms a quantum register
in state <span class="math inline">\(f = \sum_{x\in\mathbb{Z}_m} f(x)|x\rangle\)</span> into the state
<span class="math inline">\(\hat{f}= \sum_{x\in\mathbb{Z}_m} \hat{f}(x) |x\rangle\)</span>, where
<span class="math inline">\(\hat{f}(x) = \tfrac{1}{\sqrt{m}} \sum_{y\in \mathbb{Z}_m} \omega^{xy}f(x)\)</span>.</p>
</blockquote>
<p>The crux of the algorithm is the FFT equations, which allow the problem of computing <span class="math inline">\(FT_m\)</span>,
the problem of size <span class="math inline">\(m\)</span>, to be split into two identical subproblems of
size <span class="math inline">\(m/2\)</span> involving computation of <span class="math inline">\(FT_{m/2}\)</span>, which can be carried out
recursively using the same elementary operations. (Aside: Not every
divide-and-conquer classical algorithm can be implemented as a fast
quantum algorithm; we are really using the structure of the problem
here.)</p>
<p>We now describe the algorithm and the state, neglecting normalizing factors.</p>
<ol style="list-style-type: decimal">
<li><p><em>initial state:</em> <span class="math inline">\(f= \sum_{x\in\mathbb{Z}_m} f(x)|x\rangle\)</span></p></li>
<li><p>Recursively run <span class="math inline">\(FT_{m/2}\)</span> on <span class="math inline">\(m-1\)</span> most significant qubits (state: <span class="math inline">\((FT_{m/2}f_{even})|0\rangle + (FT_{m/2}f_{odd})|1\rangle\)</span>)</p></li>
<li><p>If LSB is <span class="math inline">\(1\)</span> then compute <span class="math inline">\(W\)</span> on <span class="math inline">\(m-1\)</span> most significant qubits (see below). (state : <span class="math inline">\((FT_{m/2}f_{even})|0\rangle + (W FT_{m/2}f_{odd})|1\rangle\)</span>)</p></li>
<li><p>Apply Hadmard gate <span class="math inline">\(H\)</span> to least significant qubit. (state: <span class="math inline">\((FT_{m/2}f_{even})(|0\rangle+|1\rangle)\)</span> <span class="math inline">\(+\)</span> <span class="math inline">\((W FT_{m/2}f_{odd})(|0\rangle-|1\rangle) =\)</span> <span class="math inline">\((FT_{m/2}f_{even}+ W FT_{m/2}f_{odd})|0\rangle + (FT_{m/2}f_{even}-W FT_{m/2}f_{odd})|1\rangle\)</span>)</p></li>
<li><p>Move LSB to the most significant position. (state: <span class="math inline">\(|0\rangle(FT_{m/2}f_{even}+ W FT_{m/2}f_{odd}) + |1\rangle(FT_{m/2}f_{even}- W FT_{m/2}f_{odd}) = \hat{f}\)</span>)</p></li>
</ol>
<p>The transformation <span class="math inline">\(W\)</span> on <span class="math inline">\(m-1\)</span> qubits can be defined by <span class="math inline">\(|x\rangle \mapsto \omega^x = \omega^{\sum_{i=0}^{m-2} 2^ix_i}\)</span> (where <span class="math inline">\(x_i\)</span> is
the <span class="math inline">\(i^{th}\)</span> qubit of <span class="math inline">\(x\)</span>). It can be easily seen to be the result of
applying for every <span class="math inline">\(i\in \{ 0,\ldots,m-2\}\)</span> the following elementary
operation on the <span class="math inline">\(i^{th}\)</span> qubit of the register:</p>
<p><span class="math inline">\(|0\rangle \mapsto |0\rangle\)</span> and <span class="math inline">\(|1\rangle \mapsto \omega^{2^i}|1\rangle\)</span>.</p>
<p>The final state is equal to <span class="math inline">\(\hat{f}\)</span> by the FFT equations (we leave this as an exercise)</p>
</div>
</div>
<div id="shor鈥檚-order-finding-algorithm." class="section level2 hasAnchor" number="20.4">
<h2><span class="header-section-number">20.4</span> Shor鈥檚 Order-Finding Algorithm.<a href="quantum-computing-and-cryptography-ii.html#shor鈥檚-order-finding-algorithm." class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We now present the central step in Shor鈥檚 factoring algorithm: a quantum polynomial-time algorithm to find the <em>order</em> of an integer <span class="math inline">\(a\)</span> modulo an integer <span class="math inline">\(\ell\)</span>.</p>
<blockquote>
<h1 id="orderdinfindrestatethm" class="theorem" title="Order finding algorithm, restated"></h1>
<p>There is a polynomial-time quantum algorithm that
on input <span class="math inline">\(A,N\)</span> (represented in binary) finds the smallest <span class="math inline">\(r\)</span> such that <span class="math inline">\(A^r=1 \pmod{N}\)</span>.</p>
</blockquote>
<p>Let <span class="math inline">\(t=\ceil{5\log (A+N)}\)</span>. Our register will consist of
<span class="math inline">\(t+polylog(N)\)</span> qubits. Note that the function <span class="math inline">\(x
\mapsto A^x \pmod{N}\)</span> can be computed in <span class="math inline">\(polylog(N)\)</span> time and so we will assume that we can
compute the map <span class="math inline">\(|x\rangle|y\rangle \mapsto |x\rangle|y\oplus (A^x \pmod{N\rangle)}\)</span> (where we identify a number <span class="math inline">\(X \in \{ 0,\ldots,N-1\}\)</span> with its representation as a binary
string of length <span class="math inline">\(\log N\)</span>).[^9] Now we describe the order-finding
algorithm. It uses a tool of elementary number theory called <em>continued fractions</em> which allows us to approximate (using a classical algorithm)
an arbitrary real number <span class="math inline">\(\alpha\)</span> with a rational number <span class="math inline">\(p/q\)</span> where
there is a prescribed upper bound on <span class="math inline">\(q\)</span> (see below)</p>
<p>We now describe the algorithm and the state, this time <em>including</em> normalizing factors.</p>
<ol style="list-style-type: decimal">
<li><p>Apply Fourier transform to the first <span class="math inline">\(m\)</span> bits. (state: <span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{x\in\mathbb{Z}_m}|x\rangle)|0^n\rangle\)</span>)</p></li>
<li><p>Compute the transformation <span class="math inline">\(|x\rangle|y\rangle \mapsto |x\rangle|y \oplus (A^x \pmod{N\rangle)}\)</span>. (state: <span class="math inline">\(\tfrac{1}{\sqrt{m}}\sum_{x\in\mathbb{Z}_m} |x\rangle|A^x \pmod{N\rangle}\)</span>)</p></li>
<li><p>Measure the second register to get a value <span class="math inline">\(y_0\)</span>. (state: <span class="math inline">\(\tfrac{1}{\sqrt{K}}\sum_{\ell=0}^{K-1}|x_0 + \ell r\rangle|y_0\rangle\)</span> where <span class="math inline">\(x_0\)</span> is the smallest number such that <span class="math inline">\(A^{x_0} = y_0 \pmod{N}\)</span> and <span class="math inline">\(K= \lfloor (m-1-x_0)/r \rfloor\)</span>.)</p></li>
<li><p>Apply the Fourier transform to the first register. (state: <span class="math inline">\(\tfrac{1}{\sqrt{m}\sqrt{K}} \left(\sum_{x\in\mathbb{Z}_n}\sum_{\ell=0}^{K-1} \omega^{(x_0+\ell r)x}|x\rangle \right) |y_0\rangle\)</span>)</p></li>
</ol>
<p>In the analysis, it will suffice to show that this algorithm outputs the order <span class="math inline">\(r\)</span> with probability at least <span class="math inline">\(\Omega(1/\log N)\)</span> (we can always
amplify the algorithm鈥檚 success by running it several times and taking
the smallest output).</p>
<div id="analysis-the-case-that-rm" class="section level3 hasAnchor" number="20.4.1">
<h3><span class="header-section-number">20.4.1</span> Analysis: the case that <span class="math inline">\(r|m\)</span><a href="quantum-computing-and-cryptography-ii.html#analysis-the-case-that-rm" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We start by analyzing the algorithm in the case that <span class="math inline">\(m = rc\)</span> for some
integer <span class="math inline">\(c\)</span>. Though very unrealistic (remember that <span class="math inline">\(m\)</span> is a power of
<span class="math inline">\(2\)</span>!) this gives the intuition why Fourier transforms are useful for
detecting periods.</p>
<p><strong>Claim:</strong> In this case the value <span class="math inline">\(x\)</span> measured will be equal to <span class="math inline">\(ac\)</span> for a random <span class="math inline">\(a \in \{0,\ldots,r-1\}\)</span>.</p>
<p>The claim concludes the proof since it implies that <span class="math inline">\(x/m = a/r\)</span> where <span class="math inline">\(a\)</span> is random integer less than <span class="math inline">\(r\)</span>. Now for every <span class="math inline">\(r\)</span>, at
least <span class="math inline">\(\Omega(r/\log r)\)</span> of the numbers in <span class="math inline">\([r-1]\)</span> are co-prime to <span class="math inline">\(r\)</span>.
Indeed, the prime number theorem says that there at least this many primes in this
interval, and since <span class="math inline">\(r\)</span> has at most <span class="math inline">\(\log r\)</span> prime factors, all but
<span class="math inline">\(\log r\)</span> of these primes are co-prime to <span class="math inline">\(r\)</span>. Thus, when the algorithm
computes a rational approximation for <span class="math inline">\(x/m\)</span>, the denominator it will
find will indeed be <span class="math inline">\(r\)</span>.</p>
<p>To prove the claim, we compute for every <span class="math inline">\(x \in \mathbb{Z}_m\)</span> the absolute value
of <span class="math inline">\(|x\rangle\)</span>鈥檚 coefficient before the measurement. Up to some
normalization factor this is</p>
<p><span class="math inline">\(\left|  \sum_{\ell=0}^{c-1} \omega^{(x_0+\ell r)x} \right| = \left| \omega^{x_0c&#39;c} \right| \left| \sum_{\ell=0}^{c-1} \omega^{r\ell x} \right| = 1 \cdot \left| \sum_{\ell=0}^{c-1} \omega^{r\ell x} \right| \;.\)</span></p>
<p>If <span class="math inline">\(c\)</span> does not divide <span class="math inline">\(x\)</span> then
<span class="math inline">\(\omega^r\)</span> is a <span class="math inline">\(c^{th}\)</span> root of unity, so
<span class="math inline">\(\sum_{\ell=0}^{c-1} w^{r \ell x} =0\)</span> by the formula for sums of
geometric progressions. Thus, such a number <span class="math inline">\(x\)</span> would be measured with
zero probability. But if <span class="math inline">\(x = cj\)</span> then
<span class="math inline">\(\omega^{r\ell x} = w^{r c j \ell}  = \omega^{Mj} = 1\)</span>, and hence the amplitudes
of all such <span class="math inline">\(x\)</span>鈥檚 are equal for all <span class="math inline">\(j \in \{0, 2, \ldots, r-1\}\)</span>.</p>
<div id="the-general-case" class="section level4 hasAnchor" number="20.4.1.1">
<h4><span class="header-section-number">20.4.1.1</span> The general case<a href="quantum-computing-and-cryptography-ii.html#the-general-case" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>In the general case, where <span class="math inline">\(r\)</span> does not necessarily divide <span class="math inline">\(m\)</span>, we will
not be able to show that the measured value <span class="math inline">\(x\)</span> satisfies <span class="math inline">\(m | xr\)</span>.
However, we will show that with <span class="math inline">\(\Omega(1/\log r)\)</span> probability,
<strong>(1)</strong> <span class="math inline">\(xr\)</span> will be 鈥渁lmost divisible鈥? by <span class="math inline">\(m\)</span> in the sense that <span class="math inline">\(0 \leq xr \pmod{m} &lt; r/10\)</span> and <strong>(2)</strong> <span class="math inline">\(\lfloor xr/m \rfloor\)</span> is coprime to <span class="math inline">\(r\)</span>.</p>
<p>Condition <strong>(1)</strong> implies that <span class="math inline">\(|xr - cM| &lt; r/10\)</span> for <span class="math inline">\(c=\lfloor xr/m \rfloor\)</span>. Dividing
by <span class="math inline">\(rM\)</span> gives
<span class="math inline">\(\left| \frac{x}{m} - \tfrac{c}{r} \right| &lt; \tfrac{1}{10M}\)</span>.
Therefore,
<span class="math inline">\(\tfrac{c}{r}\)</span> is a rational number with denominator at most <span class="math inline">\(N\)</span> that
approximates <span class="math inline">\(\frac{x}{m}\)</span> to within <span class="math inline">\(1/(10M) &lt; 1/(4N^4)\)</span>. It is not hard to see that such an approximation is unique
(again left as an exercise) and hence in this case the algorithm
will come up with <span class="math inline">\(c/r\)</span> and output the denominator <span class="math inline">\(r\)</span>.</p>
<p>Thus all that is left is to prove the next two lemmas. The first shows
that there are <span class="math inline">\(\Omega(r/\log r)\)</span> values of <span class="math inline">\(x\)</span> that satisfy the above
two conditions and the second shows that each is measured with
probability <span class="math inline">\(\Omega((1/\sqrt{r})^2) =\Omega(1/r)\)</span>.</p>
<p><strong>Lemma 1:</strong> There exist <span class="math inline">\(\Omega(r/\log r)\)</span> values <span class="math inline">\(x \in \mathbb{Z}_m\)</span> such that:</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span></p></li>
<li><p><span class="math inline">\(\lfloor xr/m \rfloor\)</span> and <span class="math inline">\(r\)</span> are coprime</p></li>
</ol>
<p><strong>Lemma 2:</strong> If <span class="math inline">\(x\)</span> satisfies <span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span> then,
before the measurement in the final step of the order-finding algorithm,
the coefficient of <span class="math inline">\(|x\rangle\)</span> is at least <span class="math inline">\(\Omega(\tfrac{1}{\sqrt{r}})\)</span>.</p>
<p><strong>Proof of Lemma 1</strong> We prove the lemma for the
case that <span class="math inline">\(r\)</span> is coprime to <span class="math inline">\(m\)</span>, leaving the general case to the reader. In this case, the map
<span class="math inline">\(x \mapsto rx \pmod{m}\)</span> is a permutation of <span class="math inline">\(\mathbb{Z}^*_m\)</span>. There are at least
<span class="math inline">\(\Omega(r/\log r)\)</span> numbers in <span class="math inline">\([1..r/10]\)</span> that are coprime to <span class="math inline">\(r\)</span> (take
primes in this range that are not one of <span class="math inline">\(r\)</span>鈥檚 at most <span class="math inline">\(\log r\)</span> prime
factors) and hence <span class="math inline">\(\Omega(r/\log r)\)</span> numbers <span class="math inline">\(x\)</span> such that
<span class="math inline">\(rx \pmod{m} = xr - \lfloor xr/m \rfloor m\)</span> is in <span class="math inline">\([1..r/10]\)</span> and coprime to <span class="math inline">\(r\)</span>. But this means that
<span class="math inline">\(\lfloor rx/m \rfloor\)</span> can not have a nontrivial shared factor with <span class="math inline">\(r\)</span>, as
otherwise this factor would be shared with <span class="math inline">\(rx \pmod{m}\)</span> as well.</p>
<p><strong>Proof of Lemma 2:</strong> Let <span class="math inline">\(x\)</span> be such that
<span class="math inline">\(0 &lt; xr \pmod{m} &lt; r/10\)</span>. The absolute value of <span class="math inline">\(|x\rangle\)</span>鈥檚 coefficient
in the state before the measurement is
<span class="math display">\[\tfrac{1}{\sqrt{K}\sqrt{m}}\left| \sum_{\ell=0}^{K-1} \omega^{\ell r x} \right| \;,\]</span> where
<span class="math inline">\(K = \lfloor (m-x_0-1)/r \rfloor\)</span>. Note that <span class="math inline">\(\tfrac{m}{2r} &lt; K &lt; \tfrac{m}{r}\)</span>
since <span class="math inline">\(x_0 &lt; N \ll m\)</span>.</p>
<p>Setting <span class="math inline">\(\beta=\omega^{rx}\)</span> (note that since <span class="math inline">\(m \not| rx\)</span>, <span class="math inline">\(\beta
\neq 1\)</span>) and using the formula for the sum of a geometric series, this
is at least
<span class="math inline">\(\tfrac{\sqrt{r}}{2M}\left| \tfrac{1 - \beta^{\ceil{m/r}}}{1-\beta} \right| = \tfrac{\sqrt{r}}{2M}\tfrac{\sin(\theta\ceil{m/r}/2)}{\sin(\theta/2)} \;,\)</span>
where <span class="math inline">\(\theta=\tfrac{rx \pmod{m}}{m}\)</span> is the angle such that
<span class="math inline">\(\beta = e^{i\theta}\)</span> (see Figure聽<span class="math display">\[quantum:fig:theta\]</span> for a proof by
picture of the last equality). Under our assumptions
<span class="math inline">\(\ceil{m/r}\theta&lt;1/10\)</span> and hence (using the fact that
<span class="math inline">\(\sin \alpha \sim \alpha\)</span> for small angles <span class="math inline">\(\alpha\)</span>), the coefficient of
<span class="math inline">\(x\)</span> is at least
<span class="math inline">\(\tfrac{\sqrt{r}}{4M}\ceil{m/r} \geq \tfrac{1}{8\sqrt{r}}\)</span></p>
<p>This completes the proof of <a href="" class="ref">orderdinfindrestatethm</a>.</p>
</div>
</div>
</div>
<div id="rational-approximation-of-real-numbers" class="section level2 hasAnchor" number="20.5">
<h2><span class="header-section-number">20.5</span> Rational approximation of real numbers<a href="quantum-computing-and-cryptography-ii.html#rational-approximation-of-real-numbers" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In many settings, including Shor鈥檚 algorithm, we are given a real number
in the form of a program that can compute its first <span class="math inline">\(t\)</span> bits in
<span class="math inline">\(poly(t)\)</span> time. We are interested in finding a close approximation to
this real number of the form <span class="math inline">\(a/b\)</span>, where there is a prescribed upper
bound on <span class="math inline">\(b\)</span>. Continued fractions is a tool in number theory that is
useful for this.</p>
<p>A <em>continued fraction</em> is a number of the following form:
<span class="math inline">\(a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \tfrac{1}{a_3 + \ldots}} }\)</span> for <span class="math inline">\(a_0\)</span> a non-negative integer and
<span class="math inline">\(a_1,a_2,\ldots\)</span> positive integers.</p>
<p>Given a real number <span class="math inline">\(\alpha&gt;0\)</span>, we can find its representation as an
<em>infinite</em> fraction as follows: split <span class="math inline">\(\alpha\)</span> into the integer part
<span class="math inline">\(\lfloor \alpha \rfloor\)</span> and fractional part <span class="math inline">\(\alpha -
\lfloor \alpha \rfloor\)</span>, find recursively the representation <span class="math inline">\(R\)</span> of
<span class="math inline">\(1/(\alpha - \lfloor \alpha \rfloor)\)</span>, and then write
<span class="math display">\[\alpha = \lfloor \alpha \rfloor + \frac{1}{R} \;.\]</span> If we continue this
process for <span class="math inline">\(n\)</span> steps, we get a rational number, denoted by
<span class="math inline">\([a_0,a_1,\ldots,a_n]\)</span>, which can be represented as <span class="math inline">\(\tfrac{p_n}{q_n}\)</span>
with <span class="math inline">\(p_n,q_n\)</span> coprime. The following facts can be proven using
induction:</p>
<ul>
<li><p><span class="math inline">\(p_0=a_0, q_0 =1\)</span> and for every <span class="math inline">\(n&gt;1\)</span>, <span class="math inline">\(p_n = a_np_{n-1} + p_{n-2}\)</span>, <span class="math inline">\(q_n = a_nq_{n-1} + q_{n-2}\)</span>.</p></li>
<li><p><span class="math inline">\(\tfrac{p_n}{q_n} - \tfrac{p_{n-1}}{q_{n-1}}  =        \tfrac{(-1)^{n-1}}{q_nq_{n-1}}\)</span></p></li>
</ul>
<p>Furthermore, it is known that
<span class="math inline">\(\Bigl|\tfrac{p_n}{q_n} - \alpha\Bigl| &lt; \tfrac{1}{q_nq_{n+1}}  (*)\)</span>
which implies
that <span class="math inline">\(\tfrac{p_n}{q_n}\)</span> is the <em>closest</em> rational number to <span class="math inline">\(\alpha\)</span>
with denominator at most <span class="math inline">\(q_n\)</span>. It also means that if <span class="math inline">\(\alpha\)</span> is
extremely close to a rational number, say,
<span class="math inline">\(\left|\alpha - \tfrac{a}{b} \right| &lt; \tfrac{1}{4b^4}\)</span> for some coprime <span class="math inline">\(a,b\)</span> then we can find <span class="math inline">\(a,b\)</span> by
iterating the continued fraction algorithm for <span class="math inline">\(polylog(b)\)</span> steps.
Indeed, let <span class="math inline">\(q_n\)</span> be the first denominator such that <span class="math inline">\(q_{n+1} \geq b\)</span>.
If <span class="math inline">\(q_{n+1} &gt; 2b^2\)</span> then <span class="math inline">\((*)\)</span> implies that
<span class="math inline">\(\bigl|\tfrac{p_n}{q_n}-\alpha\bigr| &lt; \tfrac{1}{2b^2}\)</span>. But this means
that <span class="math inline">\(\tfrac{p_n}{q_n} = \tfrac{a}{b}\)</span> since there is at most one
rational number of denominator at most <span class="math inline">\(b\)</span> that is so close to <span class="math inline">\(\alpha\)</span>.
On the other hand, if <span class="math inline">\(q_{n+1} \leq
2b^2\)</span> then since <span class="math inline">\(\tfrac{p_{n+1}}{q_{n+1}}\)</span> is closer to <span class="math inline">\(\alpha\)</span> than
<span class="math inline">\(\tfrac{a}{b}\)</span>,
<span class="math inline">\(\bigl|\tfrac{p_{n+1}}{q_{n+1}}-\alpha\bigr| &lt; \tfrac{1}{4b^4}\;,\)</span>
again
meaning that <span class="math inline">\(\tfrac{p_{n+1}}{q_{n+1}}=\tfrac{a}{b}\)</span>. It鈥檚 not hard to
verify that <span class="math inline">\(q_n \geq 2^{n/2}\)</span>, implying that <span class="math inline">\(p_n\)</span> and <span class="math inline">\(q_n\)</span> can be
computed in <span class="math inline">\(polylog(q_n)\)</span> time.</p>
<div id="quantum-cryptography" class="section level3 hasAnchor" number="20.5.1">
<h3><span class="header-section-number">20.5.1</span> Quantum cryptography<a href="quantum-computing-and-cryptography-ii.html#quantum-cryptography" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>There is another way in which quantum mechanics interacts with cryptography. These “spooky actions at a distance” have been suggested by Weisner and Bennet-Brassard as a way in which parties can create a secret shared key over an insecure channel. On one hand, this concept does not require as much control as general-purpose quantum computing, and so it has in fact been <a href="https://en.wikipedia.org/wiki/Quantum_key_distribution#Quantum_Key_Distribution_Networks">demonstrated physically</a>. On the other hand, unlike transmitting standard digital information, this “insecure channel” cannot be an arbitrary media such as wifi etc.. but rather one needs fiber optics, lasers, etc.. Unlike quantum computers, where we only need one of those to break RSA, to actually use key exchange at scale we need to setup these type of networks, and so it is unclear if this approach will ever dominate the solution of Alice sending to Bob a Brink’s truck with the shared secret key. People have proposed some other ways to use the interesting properties of quantum mechanics for cryptographic purposes including <a href="https://en.wikipedia.org/wiki/Quantum_money">quantum money</a> and <a href="http://www.scottaaronson.com/papers/noclone-ccc.pdf">quantum software protection</a>.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="quantum-computing-and-cryptography-i.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="software-obfuscation.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/19-quantum-part2.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
