<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>15 Fully homomorphic encryption: Introduction and bootstrapping | A Minimal Book Example</title>
  <meta name="description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.41 and GitBook 2.6.7" />

  <meta property="og:title" content="15 Fully homomorphic encryption: Introduction and bootstrapping | A Minimal Book Example" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="15 Fully homomorphic encryption: Introduction and bootstrapping | A Minimal Book Example" />
  
  <meta name="twitter:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="zero-knowledge-proofs.html"/>
<link rel="next" href="chapfhetwo.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">A Minimal Book Example</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="mathematical-background.html"><a href="mathematical-background.html"><i class="fa fa-check"></i><b>1</b> Mathematical Background</a>
<ul>
<li class="chapter" data-level="1.1" data-path="mathematical-background.html"><a href="mathematical-background.html#a-quick-overview-of-mathematical-prerequisites"><i class="fa fa-check"></i><b>1.1</b> A quick overview of mathematical prerequisites</a></li>
<li class="chapter" data-level="1.2" data-path="mathematical-background.html"><a href="mathematical-background.html#mathematical-proofs"><i class="fa fa-check"></i><b>1.2</b> Mathematical Proofs</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="mathematical-background.html"><a href="mathematical-background.html#example-the-existence-of-infinitely-many-primes."><i class="fa fa-check"></i><b>1.2.1</b> Example: The existence of infinitely many primes.</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="mathematical-background.html"><a href="mathematical-background.html#probability-and-sample-spaces"><i class="fa fa-check"></i><b>1.3</b> Probability and Sample spaces</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="mathematical-background.html"><a href="mathematical-background.html#random-variables"><i class="fa fa-check"></i><b>1.3.1</b> Random variables</a></li>
<li class="chapter" data-level="1.3.2" data-path="mathematical-background.html"><a href="mathematical-background.html#distributions-over-strings"><i class="fa fa-check"></i><b>1.3.2</b> Distributions over strings</a></li>
<li class="chapter" data-level="1.3.3" data-path="mathematical-background.html"><a href="mathematical-background.html#more-general-sample-spaces."><i class="fa fa-check"></i><b>1.3.3</b> More general sample spaces.</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="mathematical-background.html"><a href="mathematical-background.html#correlations-and-independence"><i class="fa fa-check"></i><b>1.4</b> Correlations and independence</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="mathematical-background.html"><a href="mathematical-background.html#independent-random-variables"><i class="fa fa-check"></i><b>1.4.1</b> Independent random variables</a></li>
<li class="chapter" data-level="1.4.2" data-path="mathematical-background.html"><a href="mathematical-background.html#collections-of-independent-random-variables."><i class="fa fa-check"></i><b>1.4.2</b> Collections of independent random variables.</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="mathematical-background.html"><a href="mathematical-background.html#concentration-and-tail-bounds"><i class="fa fa-check"></i><b>1.5</b> Concentration and tail bounds</a>
<ul>
<li class="chapter" data-level="1.5.1" data-path="mathematical-background.html"><a href="mathematical-background.html#chebyshevs-inequality"><i class="fa fa-check"></i><b>1.5.1</b> Chebyshev’s Inequality</a></li>
<li class="chapter" data-level="1.5.2" data-path="mathematical-background.html"><a href="mathematical-background.html#the-chernoff-bound"><i class="fa fa-check"></i><b>1.5.2</b> The Chernoff bound</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
<li class="chapter" data-level="1.7" data-path="mathematical-background.html"><a href="mathematical-background.html#exercises-1"><i class="fa fa-check"></i><b>1.7</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a>
<ul>
<li class="chapter" data-level="2.1" data-path="introduction.html"><a href="introduction.html#some-history"><i class="fa fa-check"></i><b>2.1</b> Some history</a></li>
<li class="chapter" data-level="2.2" data-path="introduction.html"><a href="introduction.html#defining-encryptions"><i class="fa fa-check"></i><b>2.2</b> Defining encryptions</a></li>
<li class="chapter" data-level="2.3" data-path="introduction.html"><a href="introduction.html#defining-security-of-encryption"><i class="fa fa-check"></i><b>2.3</b> Defining security of encryption</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="introduction.html"><a href="introduction.html#generating-randomness-in-actual-cryptographic-systems"><i class="fa fa-check"></i><b>2.3.1</b> Generating randomness in actual cryptographic systems</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="introduction.html"><a href="introduction.html#defining-the-secrecy-requirement."><i class="fa fa-check"></i><b>2.4</b> Defining the secrecy requirement.</a></li>
<li class="chapter" data-level="2.5" data-path="introduction.html"><a href="introduction.html#perfect-secrecy"><i class="fa fa-check"></i><b>2.5</b> Perfect Secrecy</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="introduction.html"><a href="introduction.html#achieving-perfect-secrecy"><i class="fa fa-check"></i><b>2.5.1</b> Achieving perfect secrecy</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="introduction.html"><a href="introduction.html#necessity-of-long-keys"><i class="fa fa-check"></i><b>2.6</b> Necessity of long keys</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="introduction.html"><a href="introduction.html#amplifying-success-probability"><i class="fa fa-check"></i><b>2.6.1</b> Amplifying success probability</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="introduction.html"><a href="introduction.html#bibliographical-notes"><i class="fa fa-check"></i><b>2.7</b> Bibliographical notes</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="computational-security.html"><a href="computational-security.html"><i class="fa fa-check"></i><b>3</b> Computational Security</a>
<ul>
<li class="chapter" data-level="3.0.1" data-path="computational-security.html"><a href="computational-security.html#proof-by-reduction"><i class="fa fa-check"></i><b>3.0.1</b> Proof by reduction</a></li>
<li class="chapter" data-level="3.1" data-path="computational-security.html"><a href="computational-security.html#the-asymptotic-approach"><i class="fa fa-check"></i><b>3.1</b> The asymptotic approach</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="computational-security.html"><a href="computational-security.html#countoperation"><i class="fa fa-check"></i><b>3.1.1</b> Counting number of operations.</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="computational-security.html"><a href="computational-security.html#our-first-conjecture"><i class="fa fa-check"></i><b>3.2</b> Our first conjecture</a></li>
<li class="chapter" data-level="3.3" data-path="computational-security.html"><a href="computational-security.html#why-care-about-the-cipher-conjecture"><i class="fa fa-check"></i><b>3.3</b> Why care about the cipher conjecture?</a></li>
<li class="chapter" data-level="3.4" data-path="computational-security.html"><a href="computational-security.html#prelude-computational-indistinguishability"><i class="fa fa-check"></i><b>3.4</b> Prelude: Computational Indistinguishability</a></li>
<li class="chapter" data-level="3.5" data-path="computational-security.html"><a href="computational-security.html#the-length-extension-theorem-or-stream-ciphers"><i class="fa fa-check"></i><b>3.5</b> The Length Extension Theorem or Stream Ciphers</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="computational-security.html"><a href="computational-security.html#appendix-the-computational-model"><i class="fa fa-check"></i><b>3.5.1</b> Appendix: The computational model</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="pseudorandomness.html"><a href="pseudorandomness.html"><i class="fa fa-check"></i><b>4</b> Pseudorandomness</a>
<ul>
<li class="chapter" data-level="4.0.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#unpredictability-an-alternative-approach-for-proving-the-length-extension-theorem"><i class="fa fa-check"></i><b>4.0.1</b> Unpredictability: an alternative approach for proving the length extension theorem</a></li>
<li class="chapter" data-level="4.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#stream-ciphers"><i class="fa fa-check"></i><b>4.1</b> Stream ciphers</a></li>
<li class="chapter" data-level="4.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#what-do-pseudorandom-generators-actually-look-like"><i class="fa fa-check"></i><b>4.2</b> What do pseudorandom generators actually look like?</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-0-the-counter-generator"><i class="fa fa-check"></i><b>4.2.1</b> Attempt 0: The counter generator</a></li>
<li class="chapter" data-level="4.2.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-1-the-linear-checksum-linear-feedback-shift-register-lfsr"><i class="fa fa-check"></i><b>4.2.2</b> Attempt 1: The linear checksum / linear feedback shift register (LFSR)</a></li>
<li class="chapter" data-level="4.2.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#from-insecurity-to-security"><i class="fa fa-check"></i><b>4.2.3</b> From insecurity to security</a></li>
<li class="chapter" data-level="4.2.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#attempt-2-linear-congruential-generators-with-dropped-bits"><i class="fa fa-check"></i><b>4.2.4</b> Attempt 2: Linear Congruential Generators with dropped bits</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#successful-examples"><i class="fa fa-check"></i><b>4.3</b> Successful examples</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-1-subset-sum-generator"><i class="fa fa-check"></i><b>4.3.1</b> Case Study 1: Subset Sum Generator</a></li>
<li class="chapter" data-level="4.3.2" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-2-rc4"><i class="fa fa-check"></i><b>4.3.2</b> Case Study 2: RC4</a></li>
<li class="chapter" data-level="4.3.3" data-path="pseudorandomness.html"><a href="pseudorandomness.html#case-study-3-blum-blum-and-shub"><i class="fa fa-check"></i><b>4.3.3</b> Case Study 3: Blum, Blum and Shub</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="pseudorandomness.html"><a href="pseudorandomness.html#non-constructive-existence-of-pseudorandom-generators"><i class="fa fa-check"></i><b>4.4</b> Non-constructive existence of pseudorandom generators</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html"><i class="fa fa-check"></i><b>5</b> Pseudorandom functions</a>
<ul>
<li class="chapter" data-level="5.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#one-time-passwords-e.g.-google-authenticator-rsa-id-etc."><i class="fa fa-check"></i><b>5.1</b> One time passwords (e.g. Google Authenticator, RSA ID, etc.)</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#how-do-pseudorandom-functions-help-in-the-login-problem"><i class="fa fa-check"></i><b>5.1.1</b> How do pseudorandom functions help in the login problem?</a></li>
<li class="chapter" data-level="5.1.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#modifying-input-and-output-lengths-of-prfs"><i class="fa fa-check"></i><b>5.1.2</b> Modifying input and output lengths of PRFs</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#message-authentication-codes"><i class="fa fa-check"></i><b>5.2</b> Message Authentication Codes</a></li>
<li class="chapter" data-level="5.3" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#macs-from-prfs"><i class="fa fa-check"></i><b>5.3</b> MACs from PRFs</a></li>
<li class="chapter" data-level="5.4" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#arbitrary-input-length-extension-for-macs-and-prfs"><i class="fa fa-check"></i><b>5.4</b> Arbitrary input length extension for MACs and PRFs</a></li>
<li class="chapter" data-level="5.5" data-path="pseudorandom-functions.html"><a href="pseudorandom-functions.html#aside-natural-proofs"><i class="fa fa-check"></i><b>5.5</b> Aside: natural proofs</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><i class="fa fa-check"></i><b>6</b> Pseudorandom functions from pseudorandom generators and CPA security</a>
<ul>
<li class="chapter" data-level="6.1" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#securely-encrypting-many-messages---chosen-plaintext-security"><i class="fa fa-check"></i><b>6.1</b> Securely encrypting many messages - chosen plaintext security</a></li>
<li class="chapter" data-level="6.2" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#pseudorandom-permutations-block-ciphers"><i class="fa fa-check"></i><b>6.2</b> Pseudorandom permutations / block ciphers</a></li>
<li class="chapter" data-level="6.3" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#encryption-modes"><i class="fa fa-check"></i><b>6.3</b> Encryption modes</a></li>
<li class="chapter" data-level="6.4" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#optional-aside-broadcast-encryption"><i class="fa fa-check"></i><b>6.4</b> Optional, Aside: Broadcast Encryption</a></li>
<li class="chapter" data-level="6.5" data-path="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html"><a href="pseudorandom-functions-from-pseudorandom-generators-and-cpa-security.html#reading-comprehension-exercises"><i class="fa fa-check"></i><b>6.5</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html"><i class="fa fa-check"></i><b>7</b> Chosen Ciphertext Security</a>
<ul>
<li class="chapter" data-level="7.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#short-recap"><i class="fa fa-check"></i><b>7.1</b> Short recap</a></li>
<li class="chapter" data-level="7.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#going-beyond-cpa"><i class="fa fa-check"></i><b>7.2</b> Going beyond CPA</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#example-the-wired-equivalence-privacy-wep"><i class="fa fa-check"></i><b>7.2.1</b> Example: The Wired Equivalence Privacy (WEP)</a></li>
<li class="chapter" data-level="7.2.2" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-security-1"><i class="fa fa-check"></i><b>7.2.2</b> Chosen ciphertext security</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#constructing-cca-secure-encryption"><i class="fa fa-check"></i><b>7.3</b> Constructing CCA secure encryption</a></li>
<li class="chapter" data-level="7.4" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#simplified-gcm-encryption"><i class="fa fa-check"></i><b>7.4</b> (Simplified) GCM encryption</a></li>
<li class="chapter" data-level="7.5" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#padding-chopping-and-their-pitfalls-the-buffer-overflow-of-cryptography"><i class="fa fa-check"></i><b>7.5</b> Padding, chopping, and their pitfalls: the “buffer overflow” of cryptography</a></li>
<li class="chapter" data-level="7.6" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#chosen-ciphertext-attack-as-implementing-metaphors"><i class="fa fa-check"></i><b>7.6</b> Chosen ciphertext attack as implementing metaphors</a></li>
<li class="chapter" data-level="7.7" data-path="chosen-ciphertext-security.html"><a href="chosen-ciphertext-security.html#reading-comprehension-exercises-1"><i class="fa fa-check"></i><b>7.7</b> Reading comprehension exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="hash-functions-random-oracles-and-bitcoin.html"><a href="hash-functions-random-oracles-and-bitcoin.html"><i class="fa fa-check"></i><b>8</b> Hash Functions, Random Oracles, and Bitcoin</a></li>
<li class="chapter" data-level="9" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><i class="fa fa-check"></i><b>9</b> Key derivation, protecting passwords, slow hashes, Merkle trees</a>
<ul>
<li class="chapter" data-level="9.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#keys-from-passwords"><i class="fa fa-check"></i><b>9.1</b> Keys from passwords</a></li>
<li class="chapter" data-level="9.2" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#merkle-trees-and-verifying-storage."><i class="fa fa-check"></i><b>9.2</b> Merkle trees and verifying storage.</a></li>
<li class="chapter" data-level="9.3" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#proofs-of-retrievability"><i class="fa fa-check"></i><b>9.3</b> Proofs of Retrievability</a></li>
<li class="chapter" data-level="9.4" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#entropy-extraction"><i class="fa fa-check"></i><b>9.4</b> Entropy extraction</a>
<ul>
<li class="chapter" data-level="9.4.1" data-path="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html"><a href="key-derivation-protecting-passwords-slow-hashes-merkle-trees.html#forward-and-backward-secrecy"><i class="fa fa-check"></i><b>9.4.1</b> Forward and backward secrecy</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="10" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html"><i class="fa fa-check"></i><b>10</b> Public key cryptography</a>
<ul>
<li class="chapter" data-level="10.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#private-key-crypto-recap"><i class="fa fa-check"></i><b>10.1</b> Private key crypto recap</a></li>
<li class="chapter" data-level="10.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#public-key-encryptions-definition"><i class="fa fa-check"></i><b>10.2</b> Public Key Encryptions: Definition</a>
<ul>
<li class="chapter" data-level="10.2.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-obfuscation-paradigm"><i class="fa fa-check"></i><b>10.2.1</b> The obfuscation paradigm</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#some-concrete-candidates"><i class="fa fa-check"></i><b>10.3</b> Some concrete candidates:</a>
<ul>
<li class="chapter" data-level="10.3.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#diffie-hellman-encryption-aka-el-gamal"><i class="fa fa-check"></i><b>10.3.1</b> Diffie-Hellman Encryption (aka El-Gamal)</a></li>
<li class="chapter" data-level="10.3.2" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#sampling-random-primes"><i class="fa fa-check"></i><b>10.3.2</b> Sampling random primes</a></li>
<li class="chapter" data-level="10.3.3" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#a-little-bit-of-group-theory."><i class="fa fa-check"></i><b>10.3.3</b> A little bit of group theory.</a></li>
<li class="chapter" data-level="10.3.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#digital-signatures"><i class="fa fa-check"></i><b>10.3.4</b> Digital Signatures</a></li>
<li class="chapter" data-level="10.3.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#the-digital-signature-algorithm-dsa"><i class="fa fa-check"></i><b>10.3.5</b> The Digital Signature Algorithm (DSA)</a></li>
</ul></li>
<li class="chapter" data-level="10.4" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#putting-everything-together---security-in-practice."><i class="fa fa-check"></i><b>10.4</b> Putting everything together - security in practice.</a></li>
<li class="chapter" data-level="10.5" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#appendix-an-alternative-proof-of-the-density-of-primes"><i class="fa fa-check"></i><b>10.5</b> Appendix: An alternative proof of the density of primes</a></li>
<li class="chapter" data-level="10.6" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#additional-group-theory-exercises-and-proofs"><i class="fa fa-check"></i><b>10.6</b> Additional Group Theory Exercises and Proofs</a>
<ul>
<li class="chapter" data-level="10.6.1" data-path="public-key-cryptography.html"><a href="public-key-cryptography.html#solved-exercises"><i class="fa fa-check"></i><b>10.6.1</b> Solved exercises:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="11" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html"><i class="fa fa-check"></i><b>11</b> Concrete candidates for public key crypto</a>
<ul>
<li class="chapter" data-level="11.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#some-number-theory."><i class="fa fa-check"></i><b>11.1</b> Some number theory.</a>
<ul>
<li class="chapter" data-level="11.1.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#primaliy-testing"><i class="fa fa-check"></i><b>11.1.1</b> Primaliy testing</a></li>
<li class="chapter" data-level="11.1.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#fields"><i class="fa fa-check"></i><b>11.1.2</b> Fields</a></li>
<li class="chapter" data-level="11.1.3" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#chinese-remainder-theorem"><i class="fa fa-check"></i><b>11.1.3</b> Chinese remainder theorem</a></li>
<li class="chapter" data-level="11.1.4" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#the-rsa-and-rabin-functions"><i class="fa fa-check"></i><b>11.1.4</b> The RSA and Rabin functions</a></li>
<li class="chapter" data-level="11.1.5" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#abstraction-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.5</b> Abstraction: trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.6" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#public-key-encryption-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.6</b> Public key encryption from trapdoor permutations</a></li>
<li class="chapter" data-level="11.1.7" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#digital-signatures-from-trapdoor-permutations"><i class="fa fa-check"></i><b>11.1.7</b> Digital signatures from trapdoor permutations</a></li>
</ul></li>
<li class="chapter" data-level="11.2" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#hardcore-bits-and-security-without-random-oracles"><i class="fa fa-check"></i><b>11.2</b> Hardcore bits and security without random oracles</a>
<ul>
<li class="chapter" data-level="11.2.1" data-path="concrete-candidates-for-public-key-crypto.html"><a href="concrete-candidates-for-public-key-crypto.html#extending-to-more-than-one-hardcore-bit"><i class="fa fa-check"></i><b>11.2.1</b> Extending to more than one hardcore bit</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="12" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html"><i class="fa fa-check"></i><b>12</b> Lattice based cryptography</a>
<ul>
<li class="chapter" data-level="12.0.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#quick-linear-algebra-recap"><i class="fa fa-check"></i><b>12.0.1</b> Quick linear algebra recap</a></li>
<li class="chapter" data-level="12.1" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#a-world-without-gaussian-elimination"><i class="fa fa-check"></i><b>12.1</b> A world without Gaussian elimination</a></li>
<li class="chapter" data-level="12.2" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#security-in-the-real-world."><i class="fa fa-check"></i><b>12.2</b> Security in the real world.</a></li>
<li class="chapter" data-level="12.3" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#search-to-decision"><i class="fa fa-check"></i><b>12.3</b> Search to decision</a></li>
<li class="chapter" data-level="12.4" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#lweencsec"><i class="fa fa-check"></i><b>12.4</b> An LWE based encryption scheme</a></li>
<li class="chapter" data-level="12.5" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#but-what-are-lattices"><i class="fa fa-check"></i><b>12.5</b> But what are lattices?</a></li>
<li class="chapter" data-level="12.6" data-path="lattice-based-cryptography.html"><a href="lattice-based-cryptography.html#ring-based-lattices"><i class="fa fa-check"></i><b>12.6</b> Ring based lattices</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html"><i class="fa fa-check"></i><b>13</b> Establishing secure connections over insecure channels</a>
<ul>
<li class="chapter" data-level="13.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cryptographys-obsession-with-adjectives."><i class="fa fa-check"></i><b>13.1</b> Cryptography’s obsession with adjectives.</a></li>
<li class="chapter" data-level="13.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#basic-key-exchange-protocol"><i class="fa fa-check"></i><b>13.2</b> Basic Key Exchange protocol</a></li>
<li class="chapter" data-level="13.3" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#authenticated-key-exchange"><i class="fa fa-check"></i><b>13.3</b> Authenticated key exchange</a>
<ul>
<li class="chapter" data-level="13.3.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#bleichenbachers-attack-on-rsa-pkcs-v1.5-and-ssl-v3.0"><i class="fa fa-check"></i><b>13.3.1</b> Bleichenbacher’s attack on RSA PKCS V1.5 and SSL V3.0</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#chosen-ciphertext-attack-security-for-public-key-cryptography"><i class="fa fa-check"></i><b>13.4</b> Chosen ciphertext attack security for public key cryptography</a></li>
<li class="chapter" data-level="13.5" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#cca-secure-public-key-encryption-in-the-random-oracle-model"><i class="fa fa-check"></i><b>13.5</b> CCA secure public key encryption in the Random Oracle Model</a>
<ul>
<li class="chapter" data-level="13.5.1" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#defining-secure-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.1</b> Defining secure authenticated key exchange</a></li>
<li class="chapter" data-level="13.5.2" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#the-compiler-approach-for-authenticated-key-exchange"><i class="fa fa-check"></i><b>13.5.2</b> The compiler approach for authenticated key exchange</a></li>
</ul></li>
<li class="chapter" data-level="13.6" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#password-authenticated-key-exchange."><i class="fa fa-check"></i><b>13.6</b> Password authenticated key exchange.</a></li>
<li class="chapter" data-level="13.7" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#client-to-client-key-exchange-for-secure-text-messaging---zrtp-otr-textsecure"><i class="fa fa-check"></i><b>13.7</b> Client to client key exchange for secure text messaging - ZRTP, OTR, TextSecure</a></li>
<li class="chapter" data-level="13.8" data-path="establishing-secure-connections-over-insecure-channels.html"><a href="establishing-secure-connections-over-insecure-channels.html#heartbleed-and-logjam-attacks"><i class="fa fa-check"></i><b>13.8</b> Heartbleed and logjam attacks</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html"><i class="fa fa-check"></i><b>14</b> Zero knowledge proofs</a>
<ul>
<li class="chapter" data-level="14.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#applications-for-zero-knowledge-proofs."><i class="fa fa-check"></i><b>14.1</b> Applications for zero knowledge proofs.</a>
<ul>
<li class="chapter" data-level="14.1.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#nuclear-disarmament"><i class="fa fa-check"></i><b>14.1.1</b> Nuclear disarmament</a></li>
<li class="chapter" data-level="14.1.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#voting"><i class="fa fa-check"></i><b>14.1.2</b> Voting</a></li>
<li class="chapter" data-level="14.1.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#more-applications"><i class="fa fa-check"></i><b>14.1.3</b> More applications</a></li>
</ul></li>
<li class="chapter" data-level="14.2" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-and-constructing-zero-knowledge-proofs"><i class="fa fa-check"></i><b>14.2</b> Defining and constructing zero knowledge proofs</a></li>
<li class="chapter" data-level="14.3" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#defining-zero-knowledge"><i class="fa fa-check"></i><b>14.3</b> Defining zero knowledge</a></li>
<li class="chapter" data-level="14.4" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#zero-knowledge-proof-for-hamiltonicity."><i class="fa fa-check"></i><b>14.4</b> Zero knowledge proof for Hamiltonicity.</a>
<ul>
<li class="chapter" data-level="14.4.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#why-is-this-interesting"><i class="fa fa-check"></i><b>14.4.1</b> Why is this interesting?</a></li>
</ul></li>
<li class="chapter" data-level="14.5" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#parallel-repetition-and-turning-zero-knowledge-proofs-to-signatures."><i class="fa fa-check"></i><b>14.5</b> Parallel repetition and turning zero knowledge proofs to signatures.</a>
<ul>
<li class="chapter" data-level="14.5.1" data-path="zero-knowledge-proofs.html"><a href="zero-knowledge-proofs.html#bonus-features-of-zero-knowledge"><i class="fa fa-check"></i><b>14.5.1</b> “Bonus features” of zero knowledge</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="15" data-path="chapfheone.html"><a href="chapfheone.html"><i class="fa fa-check"></i><b>15</b> Fully homomorphic encryption: Introduction and bootstrapping</a>
<ul>
<li class="chapter" data-level="15.1" data-path="chapfheone.html"><a href="chapfheone.html#defining-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>15.1</b> Defining fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.1.1" data-path="chapfheone.html"><a href="chapfheone.html#another-application-fully-homomorphic-encryption-for-verifying-computation"><i class="fa fa-check"></i><b>15.1.1</b> Another application: fully homomorphic encryption for verifying computation</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="chapfheone.html"><a href="chapfheone.html#example-an-xor-homomorphic-encryption"><i class="fa fa-check"></i><b>15.2</b> Example: An XOR homomorphic encryption</a>
<ul>
<li class="chapter" data-level="15.2.1" data-path="chapfheone.html"><a href="chapfheone.html#abstraction-a-trapdoor-pseudorandom-generator."><i class="fa fa-check"></i><b>15.2.1</b> Abstraction: A trapdoor pseudorandom generator.</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="chapfheone.html"><a href="chapfheone.html#from-linear-homomorphism-to-full-homomorphism"><i class="fa fa-check"></i><b>15.3</b> From linear homomorphism to full homomorphism</a></li>
<li class="chapter" data-level="15.4" data-path="chapfheone.html"><a href="chapfheone.html#bootstrapping-fully-homomorphic-escape-velocity"><i class="fa fa-check"></i><b>15.4</b> Bootstrapping: Fully Homomorphic “escape velocity”</a>
<ul>
<li class="chapter" data-level="15.4.1" data-path="chapfheone.html"><a href="chapfheone.html#radioactive-legos-analogy"><i class="fa fa-check"></i><b>15.4.1</b> Radioactive legos analogy</a></li>
<li class="chapter" data-level="15.4.2" data-path="chapfheone.html"><a href="chapfheone.html#proving-the-bootstrapping-theorem"><i class="fa fa-check"></i><b>15.4.2</b> Proving the bootstrapping theorem</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="chapfhetwo.html"><a href="chapfhetwo.html"><i class="fa fa-check"></i><b>16</b> Fully homomorphic encryption: Construction</a>
<ul>
<li class="chapter" data-level="16.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#prelude-from-vectors-to-matrices"><i class="fa fa-check"></i><b>16.1</b> Prelude: from vectors to matrices</a></li>
<li class="chapter" data-level="16.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#real-world-partially-homomorphic-encryption"><i class="fa fa-check"></i><b>16.2</b> Real world partially homomorphic encryption</a></li>
<li class="chapter" data-level="16.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#noise-management-via-encoding"><i class="fa fa-check"></i><b>16.3</b> Noise management via encoding</a></li>
<li class="chapter" data-level="16.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#putting-it-all-together"><i class="fa fa-check"></i><b>16.4</b> Putting it all together</a></li>
<li class="chapter" data-level="16.5" data-path="chapfhetwo.html"><a href="chapfhetwo.html#analysis-of-our-scheme"><i class="fa fa-check"></i><b>16.5</b> Analysis of our scheme</a>
<ul>
<li class="chapter" data-level="16.5.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#correctness"><i class="fa fa-check"></i><b>16.5.1</b> Correctness</a></li>
<li class="chapter" data-level="16.5.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#cpa-security"><i class="fa fa-check"></i><b>16.5.2</b> CPA Security</a></li>
<li class="chapter" data-level="16.5.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#homomorphism"><i class="fa fa-check"></i><b>16.5.3</b> Homomorphism</a></li>
<li class="chapter" data-level="16.5.4" data-path="chapfhetwo.html"><a href="chapfhetwo.html#shallow-decryption-circuit"><i class="fa fa-check"></i><b>16.5.4</b> Shallow decryption circuit</a></li>
</ul></li>
<li class="chapter" data-level="16.6" data-path="chapfhetwo.html"><a href="chapfhetwo.html#advanced-topics"><i class="fa fa-check"></i><b>16.6</b> Advanced topics:</a>
<ul>
<li class="chapter" data-level="16.6.1" data-path="chapfhetwo.html"><a href="chapfhetwo.html#fully-homomorphic-encryption-for-approximate-computation-over-the-real-numbers-ckks"><i class="fa fa-check"></i><b>16.6.1</b> Fully homomorphic encryption for approximate computation over the real numbers: CKKS</a></li>
<li class="chapter" data-level="16.6.2" data-path="chapfhetwo.html"><a href="chapfhetwo.html#bandwidth-efficient-fully-homomorphic-encryption-gh"><i class="fa fa-check"></i><b>16.6.2</b> Bandwidth efficient fully homomorphic encryption GH</a></li>
<li class="chapter" data-level="16.6.3" data-path="chapfhetwo.html"><a href="chapfhetwo.html#using-fully-homomorphic-encryption-to-achieve-private-information-retrieval."><i class="fa fa-check"></i><b>16.6.3</b> Using fully homomorphic encryption to achieve private information retrieval.</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="17" data-path="sfeonechap.html"><a href="sfeonechap.html"><i class="fa fa-check"></i><b>17</b> Multiparty secure computation I: Definition and Honest-But-Curious to Malicious complier</a>
<ul>
<li class="chapter" data-level="17.1" data-path="sfeonechap.html"><a href="sfeonechap.html#ideal-vs.-real-model-security."><i class="fa fa-check"></i><b>17.1</b> Ideal vs. Real Model Security.</a></li>
<li class="chapter" data-level="17.2" data-path="sfeonechap.html"><a href="sfeonechap.html#formally-defining-secure-multiparty-computation"><i class="fa fa-check"></i><b>17.2</b> Formally defining secure multiparty computation</a>
<ul>
<li class="chapter" data-level="17.2.1" data-path="sfeonechap.html"><a href="sfeonechap.html#first-attempt-a-slightly-too-ideal-definition"><i class="fa fa-check"></i><b>17.2.1</b> First attempt: a slightly “too ideal” definition</a></li>
<li class="chapter" data-level="17.2.2" data-path="sfeonechap.html"><a href="sfeonechap.html#allowing-for-aborts"><i class="fa fa-check"></i><b>17.2.2</b> Allowing for aborts</a></li>
<li class="chapter" data-level="17.2.3" data-path="sfeonechap.html"><a href="sfeonechap.html#some-comments"><i class="fa fa-check"></i><b>17.2.3</b> Some comments:</a></li>
</ul></li>
<li class="chapter" data-level="17.3" data-path="sfeonechap.html"><a href="sfeonechap.html#example-second-price-auction-using-bitcoin"><i class="fa fa-check"></i><b>17.3</b> Example: Second price auction using bitcoin</a>
<ul>
<li class="chapter" data-level="17.3.1" data-path="sfeonechap.html"><a href="sfeonechap.html#another-example-distributed-and-threshold-cryptography"><i class="fa fa-check"></i><b>17.3.1</b> Another example: distributed and threshold cryptography</a></li>
</ul></li>
<li class="chapter" data-level="17.4" data-path="sfeonechap.html"><a href="sfeonechap.html#proving-the-fundamental-theorem"><i class="fa fa-check"></i><b>17.4</b> Proving the fundamental theorem:</a></li>
<li class="chapter" data-level="17.5" data-path="sfeonechap.html"><a href="sfeonechap.html#hbctomalred"><i class="fa fa-check"></i><b>17.5</b> Malicious to honest but curious reduction</a>
<ul>
<li class="chapter" data-level="17.5.1" data-path="sfeonechap.html"><a href="sfeonechap.html#handling-probabilistic-strategies"><i class="fa fa-check"></i><b>17.5.1</b> Handling probabilistic strategies:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="sfetwochap.html"><a href="sfetwochap.html"><i class="fa fa-check"></i><b>18</b> Multiparty secure computation II: Construction using Fully Homomorphic Encryption</a>
<ul>
<li class="chapter" data-level="18.1" data-path="sfetwochap.html"><a href="sfetwochap.html#constructing-2-party-honest-but-curious-computation-from-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.1</b> Constructing 2 party honest but curious computation from fully homomorphic encryption</a></li>
<li class="chapter" data-level="18.2" data-path="sfetwochap.html"><a href="sfetwochap.html#achieving-circuit-privacy-in-a-fully-homomorphic-encryption"><i class="fa fa-check"></i><b>18.2</b> Achieving circuit privacy in a fully homomorphic encryption</a>
<ul>
<li class="chapter" data-level="18.2.1" data-path="sfetwochap.html"><a href="sfetwochap.html#bottom-line-a-two-party-secure-computation-protocol"><i class="fa fa-check"></i><b>18.2.1</b> Bottom line: A two party secure computation protocol</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="sfetwochap.html"><a href="sfetwochap.html#beyond-two-parties"><i class="fa fa-check"></i><b>18.3</b> Beyond two parties</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html"><i class="fa fa-check"></i><b>19</b> Quantum computing and cryptography I</a>
<ul>
<li class="chapter" data-level="19.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>19.1</b> The double slit experiment</a></li>
<li class="chapter" data-level="19.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-amplitudes"><i class="fa fa-check"></i><b>19.2</b> Quantum amplitudes</a>
<ul>
<li class="chapter" data-level="19.2.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-computing-and-computation---an-executive-summary."><i class="fa fa-check"></i><b>19.2.1</b> Quantum computing and computation - an executive summary.</a></li>
</ul></li>
<li class="chapter" data-level="19.3" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#quantum-101"><i class="fa fa-check"></i><b>19.3</b> Quantum 101</a>
<ul>
<li class="chapter" data-level="19.3.1" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#physically-realizing-quantum-computation"><i class="fa fa-check"></i><b>19.3.1</b> Physically realizing quantum computation</a></li>
<li class="chapter" data-level="19.3.2" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bra-ket-notation"><i class="fa fa-check"></i><b>19.3.2</b> Bra-ket notation</a></li>
</ul></li>
<li class="chapter" data-level="19.4" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#bells-inequality"><i class="fa fa-check"></i><b>19.4</b> Bell’s Inequality</a></li>
<li class="chapter" data-level="19.5" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#analysis-of-bells-inequality"><i class="fa fa-check"></i><b>19.5</b> Analysis of Bell’s Inequality</a></li>
<li class="chapter" data-level="19.6" data-path="quantum-computing-and-cryptography-i.html"><a href="quantum-computing-and-cryptography-i.html#grovers-algorithm"><i class="fa fa-check"></i><b>19.6</b> Grover’s Algorithm</a></li>
</ul></li>
<li class="chapter" data-level="20" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html"><i class="fa fa-check"></i><b>20</b> Quantum computing and cryptography II</a>
<ul>
<li class="chapter" data-level="20.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-order-finding-to-factoring-and-discrete-log"><i class="fa fa-check"></i><b>20.1</b> From order finding to factoring and discrete log</a></li>
<li class="chapter" data-level="20.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#finding-periods-of-a-function-simons-algorithm"><i class="fa fa-check"></i><b>20.2</b> Finding periods of a function: Simon’s Algorithm</a></li>
<li class="chapter" data-level="20.3" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#from-simon-to-shor"><i class="fa fa-check"></i><b>20.3</b> From Simon to Shor</a>
<ul>
<li class="chapter" data-level="20.3.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#the-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.1</b> The Fourier transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
<li class="chapter" data-level="20.3.2" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-fourier-transform-over-mathbbz_m"><i class="fa fa-check"></i><b>20.3.2</b> Quantum Fourier Transform over <span class="math inline">\(\mathbb{Z}_m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.4" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#shor鈥檚-order-finding-algorithm."><i class="fa fa-check"></i><b>20.4</b> Shor鈥檚 Order-Finding Algorithm.</a>
<ul>
<li class="chapter" data-level="20.4.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#analysis-the-case-that-rm"><i class="fa fa-check"></i><b>20.4.1</b> Analysis: the case that <span class="math inline">\(r|m\)</span></a></li>
</ul></li>
<li class="chapter" data-level="20.5" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#rational-approximation-of-real-numbers"><i class="fa fa-check"></i><b>20.5</b> Rational approximation of real numbers</a>
<ul>
<li class="chapter" data-level="20.5.1" data-path="quantum-computing-and-cryptography-ii.html"><a href="quantum-computing-and-cryptography-ii.html#quantum-cryptography"><i class="fa fa-check"></i><b>20.5.1</b> Quantum cryptography</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="21" data-path="software-obfuscation.html"><a href="software-obfuscation.html"><i class="fa fa-check"></i><b>21</b> Software Obfuscation</a>
<ul>
<li class="chapter" data-level="21.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#witness-encryption"><i class="fa fa-check"></i><b>21.1</b> Witness encryption</a></li>
<li class="chapter" data-level="21.2" data-path="software-obfuscation.html"><a href="software-obfuscation.html#deniable-encryption"><i class="fa fa-check"></i><b>21.2</b> Deniable encryption</a></li>
<li class="chapter" data-level="21.3" data-path="software-obfuscation.html"><a href="software-obfuscation.html#functional-encryption"><i class="fa fa-check"></i><b>21.3</b> Functional encryption</a></li>
<li class="chapter" data-level="21.4" data-path="software-obfuscation.html"><a href="software-obfuscation.html#the-software-patch-problem"><i class="fa fa-check"></i><b>21.4</b> The software patch problem</a></li>
<li class="chapter" data-level="21.5" data-path="software-obfuscation.html"><a href="software-obfuscation.html#software-obfuscation-1"><i class="fa fa-check"></i><b>21.5</b> Software obfuscation</a></li>
<li class="chapter" data-level="21.6" data-path="software-obfuscation.html"><a href="software-obfuscation.html#applications-of-obfuscation"><i class="fa fa-check"></i><b>21.6</b> Applications of obfuscation</a></li>
<li class="chapter" data-level="21.7" data-path="software-obfuscation.html"><a href="software-obfuscation.html#impossibility-of-obfuscation"><i class="fa fa-check"></i><b>21.7</b> Impossibility of obfuscation</a>
<ul>
<li class="chapter" data-level="21.7.1" data-path="software-obfuscation.html"><a href="software-obfuscation.html#proof-of-impossibility-of-vbb-obfuscation"><i class="fa fa-check"></i><b>21.7.1</b> Proof of impossibility of VBB obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="21.8" data-path="software-obfuscation.html"><a href="software-obfuscation.html#indistinguishability-obfuscation"><i class="fa fa-check"></i><b>21.8</b> Indistinguishability obfuscation</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html"><i class="fa fa-check"></i><b>22</b> More obfuscation, exotic encryptions</a>
<ul>
<li class="chapter" data-level="22.1" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#slower-weaker-less-securer"><i class="fa fa-check"></i><b>22.1</b> Slower, weaker, less securer</a></li>
<li class="chapter" data-level="22.2" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#how-to-get-ibe-from-pairing-based-assumptions."><i class="fa fa-check"></i><b>22.2</b> How to get IBE from pairing based assumptions.</a></li>
<li class="chapter" data-level="22.3" data-path="more-obfuscation-exotic-encryptions.html"><a href="more-obfuscation-exotic-encryptions.html#beyond-pairing-based-cryptography"><i class="fa fa-check"></i><b>22.3</b> Beyond pairing based cryptography</a></li>
</ul></li>
<li class="chapter" data-level="23" data-path="anonymous-communication.html"><a href="anonymous-communication.html"><i class="fa fa-check"></i><b>23</b> Anonymous communication</a>
<ul>
<li class="chapter" data-level="23.1" data-path="anonymous-communication.html"><a href="anonymous-communication.html#steganography"><i class="fa fa-check"></i><b>23.1</b> Steganography</a></li>
<li class="chapter" data-level="23.2" data-path="anonymous-communication.html"><a href="anonymous-communication.html#anonymous-routing"><i class="fa fa-check"></i><b>23.2</b> Anonymous routing</a></li>
<li class="chapter" data-level="23.3" data-path="anonymous-communication.html"><a href="anonymous-communication.html#tor"><i class="fa fa-check"></i><b>23.3</b> Tor</a></li>
<li class="chapter" data-level="23.4" data-path="anonymous-communication.html"><a href="anonymous-communication.html#telex"><i class="fa fa-check"></i><b>23.4</b> Telex</a></li>
<li class="chapter" data-level="23.5" data-path="anonymous-communication.html"><a href="anonymous-communication.html#riposte"><i class="fa fa-check"></i><b>23.5</b> Riposte</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html"><i class="fa fa-check"></i><b>24</b> Ethical, moral, and policy dimensions to cryptography</a>
<ul>
<li class="chapter" data-level="24.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#reading-prior-to-lecture"><i class="fa fa-check"></i><b>24.1</b> Reading prior to lecture:</a></li>
<li class="chapter" data-level="24.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#case-studies."><i class="fa fa-check"></i><b>24.2</b> Case studies.</a>
<ul>
<li class="chapter" data-level="24.2.1" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#the-snowden-revelations"><i class="fa fa-check"></i><b>24.2.1</b> The Snowden revelations</a></li>
<li class="chapter" data-level="24.2.2" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#fbi-vs-apple-case"><i class="fa fa-check"></i><b>24.2.2</b> FBI vs Apple case</a></li>
<li class="chapter" data-level="24.2.3" data-path="ethical-moral-and-policy-dimensions-to-cryptography.html"><a href="ethical-moral-and-policy-dimensions-to-cryptography.html#juniper-backdoor-case-and-the-opm-break-in"><i class="fa fa-check"></i><b>24.2.3</b> Juniper backdoor case and the OPM break-in</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="25" data-path="course-recap.html"><a href="course-recap.html"><i class="fa fa-check"></i><b>25</b> Course recap</a>
<ul>
<li class="chapter" data-level="25.1" data-path="course-recap.html"><a href="course-recap.html#some-things-we-did-not-cover"><i class="fa fa-check"></i><b>25.1</b> Some things we did not cover</a></li>
<li class="chapter" data-level="25.2" data-path="course-recap.html"><a href="course-recap.html#what-i-hope-you-learned"><i class="fa fa-check"></i><b>25.2</b> What I hope you learned</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">A Minimal Book Example</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="chapfheone" class="section level1 hasAnchor" number="15">
<h1><span class="header-section-number">15</span> Fully homomorphic encryption: Introduction and bootstrapping<a href="chapfheone.html#chapfheone" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>In today’s era of “cloud computing”, much of individuals’ and businesses’ data is stored and computed on by third parties such as Google, Microsoft, Apple, Amazon, Facebook, Dropbox and many others.
Classically, cryptography provided solutions to protecting <a href="https://www.schneier.com/blog/archives/2010/06/data_at_rest_vs.html">data in motion</a> from point A to point B.
But these are not always sufficient to protect <a href="https://en.wikipedia.org/wiki/Data_at_rest">data at rest</a> and particularly <a href="https://en.wikipedia.org/wiki/Data_in_use">data in use</a>.
For example, suppose that <em>Alice</em> has some data <span class="math inline">\(x \in \{0,1\}^n\)</span> (in modern applications <span class="math inline">\(x\)</span> would well be terabytes in length or larger) that she wishes to store with the cloud service <em>Bob</em>, but is afraid that Bob will be hacked, subpoenaed or simply does not completely trust Bob.</p>
<p>Encryption does not seem to immediately solve the problem.
Alice could store at Bob an <em>encrypted</em> version of the data and keep the secret key for herself.
But then she would be at a loss if she wanted to do anything more with the data other than retrieving particular blocks of it.
If she wanted to outsource computation to Bob as well, and compute <span class="math inline">\(f(x)\)</span> for some function <span class="math inline">\(f\)</span>, then she would need to share the secret key with Bob, thus defeating the purpose of encrypting the data in the first place.</p>
<p>For example, after the computing systems of Office of Personell Management (OPM) were <a href="https://www.lawfareblog.com/why-opm-hack-far-worse-you-imagine">discovered to be hacked</a> in June of 2015, revealing sensitive information, including fingerprints and all data gathered during security clearance checks of up to 18 million people, DHS assistant secretary for cybersecurity and communications Andy Ozment <a href="http://www.federaltimes.com/story/government/omr/opm-cyber-report/2015/06/19/opm-breach-encryption/28985237/">said</a> that encryption wouldn’t have helped preventing it since “if an adversary has the credentials of a user on the network, then they can access data even if it’s encrypted, just as the users on the network have to access data”.
So, can we encrypt data in a way that still allows some access and computing on it?</p>
<p>Already in 1978, <a href="http://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/RAD78.pdf">Rivest, Adleman and Dertouzos</a> considered this problem of a business that wishes to use a “commercial <a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a> service” to store some sensitive data.
They envisioned a potential solution for this task which they called a privacy homomorphism.
This notion later became known as <em>fully homomorphic encryption (FHE)</em> which is an encryption that allows a party (such as the cloud provider) that <em>does not know the secret key</em> to modify a ciphertext <span class="math inline">\(c\)</span> encrypting <span class="math inline">\(x\)</span> to a ciphertext <span class="math inline">\(c&#39;\)</span> encrypting <span class="math inline">\(f(x)\)</span> for every efficiently computable <span class="math inline">\(f()\)</span>.
In particular in our scenario above (see <a href="" class="ref">fhefig</a>), such a scheme will allow Bob, given an encryption of <span class="math inline">\(x\)</span>, to compute the encryption of <span class="math inline">\(f(x)\)</span> and send this ciphertext to Alice without ever getting the secret key and so without ever learning anything about <span class="math inline">\(x\)</span> (or <span class="math inline">\(f(x)\)</span> for that matter).</p>
<div class="float" id="fhefig">
<img src="../figure/fhedescription.png" alt="A fully homomorphic encryption can be used to store data on the cloud in encrypted form, but still have the cloud provider be able to evaluate functions on the data in encrypted form (without ever learning either the inputs or the outputs of the function they evaluate)." />
<div class="figcaption">A fully homomorphic encryption can be used to store data on the cloud in encrypted form, but still have the cloud provider be able to evaluate functions on the data in encrypted form (without ever learning either the inputs or the outputs of the function they evaluate).</div>
</div>
<p>Unlike the case of a trapdoor function, where it only took a year for Diffie and Hellman’s challenge to be answered by RSA, in the case of fully homomorphic encryption for more than 30 years cryptographers had no constructions achieving this goal.
In fact, some people suspected that there is something inherently incompatible between the security of an encryption scheme and the ability of a user to perform all these operations on ciphertexts.
Stanford cryptographer Dan Boneh used to joke to incoming graduate students that he will immediately sign the thesis of anyone who came up with a fully homomorphic encryption.
But he never expected that he will actually encounter such a thesis, until in 2009, Boneh’s student Craig Gentry released a <a href="https://crypto.stanford.edu/craig/">paper</a> doing just that.
Gentry’s paper shook the world of cryptography, and instigated a flurry of research results making his scheme more efficient, reducing the assumptions it relied on, extending and applying it, and much more.
In particular, Brakerski and Vaikuntanathan managed to obtain a fully homomorphic encryption scheme based only on the <em>Learning with Error (LWE)</em> assumption we have seen before.</p>
<p>Although there is a number of implementations for (partially and) fully homomorphic encryption (see <a href="https://github.com/jonaschn/awesome-he">this list</a>), there is still much work to be done in order to realize the full practical potential of FHE.
For a comparable level of security, the encryption and decryption operations of a fully homomorphic encryption scheme are several orders of magnitude slower than a conventional public key system, and (depending on its complexity) homomorphically evaluating a circuit can be significantly more taxing.
However, this is a fast evolving field, and already since 2009 significant optimizations have been discovered that reduced the computational and storage overhead by many orders of magnitudes.
As in public key encryption, one would imagine that for larger data one would use a “hybrid” approach of combining FHE with symmetric encryption, though one might need to come up with tailor-made symmetric encryption schemes that can be efficiently evaluated.<a href="#fn90" class="footnote-ref" id="fnref90"><sup>90</sup></a>
Homomorphically evaluations of <em>approximate computation</em>, which can be useful for machine learning, can be <a href="https://eprint.iacr.org/2016/421">done more efficiently</a>.</p>
<p>In this lecture and the next one we will focus on the fully homomorphic encryption schemes that are <em>easiest to describe</em>, rather than the ones that are most <em>efficient</em> (though the efficient schemes share many similarities with the ones we will talk about).
As is generally the case for lattice based encryption, the current most efficient schemes are based on <em>ideal</em> lattices and on assumptions such as ring LWE or the security of the NTRU cryptosystem.<a href="#fn91" class="footnote-ref" id="fnref91"><sup>91</sup></a></p>
<div class="remark" title="Lesson from verifying computation">
<p><span id="verifyinglessonrem" class="remark"><em>Remark</em>. </span>To take the distance between theory and practice in perspective, it might be useful to consider the case of <em>verifying computation</em>.
In the early 1990’s researchers (motivated initially by zero knowledge proofs) came up with the notion of <a href="http://madhu.seas.harvard.edu/papers/2009/pcpcacm.pdf">probabilistically checkable proofs (PCP’s)</a> which could yield in principle extremely succinct ways to check correctness of computation.</p>
<p>Probabilistically checkable proofs can be thought of as “souped up” versions of NP completeness reductions and like these reductions, have been mostly used for <em>negative</em> results, especially since the initial proofs were extremely complicated and also included enormous hidden constants.
However, with time people have slowly understood these better and made them more efficient (e.g., see <a href="http://m.cacm.acm.org/magazines/2015/2/182636-verifying-computations-without-reexecuting-them/fulltext">this survey</a>) and it has now reached the point where these results, are <a href="http://cacm.acm.org/magazines/2016/2/197429-pinocchio/abstract">practical</a> (see also <a href="https://eprint.iacr.org/2016/646">this</a>) and in fact these ideas underlieat least <a href="http://z.cash">two</a> <a href="https://starkware.co/">startups</a>.
Overall, constructions for verifying computation have improved by at least 20 orders of magnitude over the last two decades. (We will talk about some of these constructions later in this course.)
If progress on fully homomorphic encryption follows a similar trajectory, then we can expect the road to practical utility to be very long, but there is hope that it’s not a “bridge to nowhere”.</p>
</div>
<blockquote>
<h1 id="hardwarefhe" class="remark" title="Poor man&#39;s FHE via hardware"></h1>
<p>Since large scale fully homomorphic encryption is still impractical, people have been trying to achieve at least weaker security goals using certain assumptions.
In particular Intel chips have so called <a href="https://goo.gl/HW4pPU">“Secure enclaves”</a> which one can think of as a somewhat tamper-protected region of the processor that is supposed to be out of reach for the outside world.
The idea is that a cloud provider client would treat this enclave as a trusted party that it can communicate with through the cloud provider.
The client can store their data on the cloud encrypted with some key <span class="math inline">\(k\)</span>, and then set up a secure channel with the enclave using an authenticated key exchange protocol, and send <span class="math inline">\(k\)</span> over.
Then, when the client sends over a function <span class="math inline">\(f\)</span> to the cloud provider, the latter party can simulate FHE by asking the enclave to compute the encryption of <span class="math inline">\(f(x)\)</span> given the encryption of <span class="math inline">\(x\)</span>.
In this solution ultimately the private key does reside on the cloud provider’s computers, and the client has to trust the security of the enclave.
In practice, this could provide reasonable security against remote hackers, but (unlike FHE) probably not against sophisticated attackers (e.g., governments) that have physical access to the server.</p>
</blockquote>
<div id="defining-fully-homomorphic-encryption" class="section level2 hasAnchor" number="15.1">
<h2><span class="header-section-number">15.1</span> Defining fully homomorphic encryption<a href="chapfheone.html#defining-fully-homomorphic-encryption" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We start by defining <em>partially homomorphic</em> encryption.
We focus on encryption for single bits. This is without loss of generality for CPA security (CCA security is anyway ruled out for homomorphic encryption- can you see why?), though there are more efficient constructions that encrypt several bits at a time.</p>
<div class="definition" title="Partially Homomorphic Encryption">
<p><span id="def:partialhomdef" class="definition"><strong>Definition 15.1  </strong></span>Let <span class="math inline">\(\mathcal{F} = \cup \mathcal{F}_\ell\)</span> be a class of functions where every <span class="math inline">\(f\in\mathcal{F}_\ell\)</span> maps <span class="math inline">\(\{0,1\}^\ell\)</span> to <span class="math inline">\(\{0,1\}\)</span>.<br />
An <em><span class="math inline">\(\mathcal{F}\)</span>-homomorphic public key encryption scheme</em> is a CPA secure public key encryption scheme <span class="math inline">\((G,E,D)\)</span> such that there exists a polynomial-time algorithm <span class="math inline">\(EVAL:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> such that for every <span class="math inline">\((e,d)=G(1^n)\)</span>, <span class="math inline">\(\ell=poly(n)\)</span>, <span class="math inline">\(x_1,\ldots,x_\ell \in \{0,1\}\)</span>, and <span class="math inline">\(f\in \mathcal{F}_\ell\)</span> of description size <span class="math inline">\(|f|\)</span> at most <span class="math inline">\(poly(\ell)\)</span> it holds that:</p>
<ul>
<li><p><span class="math inline">\(c=EVAL_e(f,E_e(x_1),\ldots,E_e(x_\ell))\)</span> has length at most <span class="math inline">\(n\)</span>.</p></li>
<li><p><span class="math inline">\(D_d(c)=f(x_1,\ldots,x_\ell)\)</span>.</p></li>
</ul>
</div>
<blockquote>
<h1 id="section-75" class="pause"></h1>
<p>Please stop and verify you understand the definition.
In particular you should understand why some bound on the length of the output of <span class="math inline">\(EVAL\)</span> is needed to rule out trivial constructions that are the analogous of the cloud provider sending over to Alice the entire encrypted database every time she wants to evaluate a function of it.
By artificially increasing the randomness for the key generation algorithm, this is equivalent to requiring that <span class="math inline">\(|c| \leq p(n)\)</span> for some fixed polynomial <span class="math inline">\(p(\cdot)\)</span> that does not grow with <span class="math inline">\(\ell\)</span> or <span class="math inline">\(|f|\)</span>.
You should also understand the distinction between ciphertexts that are the output of the encryption algorithm on the plaintext <span class="math inline">\(b\)</span>, and ciphertexts that decrypt to <span class="math inline">\(b\)</span>, see <a href="" class="ref">evalciphertextfig</a>.</p>
</blockquote>
<div class="float" id="evalciphertextfig">
<img src="../figure/evalciphertexts.png" alt="In a valid encryption scheme E, the set of ciphertexts c such that D_d(c)=b is a superset of the set of ciphertexts c such that c=E_e(b;r) for some r \in \{0,1\}^{t} where t is the number of random bits used by the encryption algorithm. Our definition of partially homomorphic encryption scheme requires that for every f:\{0,1\}^\ell \rightarrow \{0,1\} in our family and x\in \{0,1\}^\ell, if c_i \in E_e(x_i;\{0,1\}^t) for i=1...\ell then EVAL(f,c_1,\ldots,c_\ell) is in the superset \{ c \;|\; D_d(c)=f(x) \} of E_e(f(x);\{0,1\}^t). For example if we apply EVAL to the OR function and ciphertexts c,c&#39; that were obtained as encryptions of 1 and 0 respectively, then the output is a ciphertext c&#39;&#39; that would be decrypted to OR(1,0)=1, even if c&#39;&#39; is not in the smaller set of possible outputs of the encryption algorithm on 1. This distinction between the smaller and larger set is the reason why we cannot automatically apply the EVAL function to ciphertexts that are obtained from the outputs of previous EVAL operations." />
<div class="figcaption">In a valid encryption scheme <span class="math inline">\(E\)</span>, the set of ciphertexts <span class="math inline">\(c\)</span> such that <span class="math inline">\(D_d(c)=b\)</span> is a superset of the set of ciphertexts <span class="math inline">\(c\)</span> such that <span class="math inline">\(c=E_e(b;r)\)</span> for some <span class="math inline">\(r \in \{0,1\}^{t}\)</span> where <span class="math inline">\(t\)</span> is the number of random bits used by the encryption algorithm. Our definition of partially homomorphic encryption scheme requires that for every <span class="math inline">\(f:\{0,1\}^\ell \rightarrow \{0,1\}\)</span> in our family and <span class="math inline">\(x\in \{0,1\}^\ell\)</span>, if <span class="math inline">\(c_i \in E_e(x_i;\{0,1\}^t)\)</span> for <span class="math inline">\(i=1...\ell\)</span> then <span class="math inline">\(EVAL(f,c_1,\ldots,c_\ell)\)</span> is in the superset <span class="math inline">\(\{ c \;|\; D_d(c)=f(x) \}\)</span> of <span class="math inline">\(E_e(f(x);\{0,1\}^t)\)</span>. For example if we apply <span class="math inline">\(EVAL\)</span> to the <span class="math inline">\(OR\)</span> function and ciphertexts <span class="math inline">\(c,c&#39;\)</span> that were obtained as encryptions of <span class="math inline">\(1\)</span> and <span class="math inline">\(0\)</span> respectively, then the output is a ciphertext <span class="math inline">\(c&#39;&#39;\)</span> that would be decrypted to <span class="math inline">\(OR(1,0)=1\)</span>, even if <span class="math inline">\(c&#39;&#39;\)</span> is not in the smaller set of possible outputs of the encryption algorithm on <span class="math inline">\(1\)</span>. This distinction between the smaller and larger set is the reason why we cannot automatically apply the <span class="math inline">\(EVAL\)</span> function to ciphertexts that are obtained from the outputs of previous <span class="math inline">\(EVAL\)</span> operations.</div>
</div>
<p>A <em>fully homomomorphic encryption</em> is simply a partially homomorphic encryption scheme for the family <span class="math inline">\(\mathcal{F}\)</span> of <em>all</em> functions, where the description of a function is as a circuit (say composed of <a href="https://en.wikipedia.org/wiki/NAND_gate">NAND</a> gates, which are known to be a universal basis).</p>
<div id="another-application-fully-homomorphic-encryption-for-verifying-computation" class="section level3 hasAnchor" number="15.1.1">
<h3><span class="header-section-number">15.1.1</span> Another application: fully homomorphic encryption for verifying computation<a href="chapfheone.html#another-application-fully-homomorphic-encryption-for-verifying-computation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The canonical application of fully homomorphic encryption is for a client to store encrypted data <span class="math inline">\(E(x)\)</span> on a server, send a function <span class="math inline">\(f\)</span> to the server, and get back the encryption <span class="math inline">\(E(f(x))\)</span> of <span class="math inline">\(f(x)\)</span>.
This ensures that the server does not learn any information about <span class="math inline">\(x\)</span>, but does not ensure that it actually computes the correct function!</p>
<p>Here is a cute protocol to achieve the latter goal (due to <a href="https://eprint.iacr.org/2010/241">Chung Kalai and Vadhan</a>).
Curiously the protocol involves “doubly encrypting” the input, and homomorphically evaluating the <span class="math inline">\(EVAL\)</span> function itself.</p>
<ul>
<li><p><strong>Assumptions:</strong> We assume that all functions <span class="math inline">\(f\)</span> that the client will be interested in can be described by a string of length <span class="math inline">\(n\)</span>.</p></li>
<li><p><strong>Preprocessing:</strong> The client generates a pair of keys <span class="math inline">\((e,d)\)</span>. In the initial stage the client computes the encrypted database <span class="math inline">\(\overline{c}=E_e(x)\)</span> and sends <span class="math inline">\(\overline{c},e\)</span> to the server. It also computes <span class="math inline">\(c^* = E_e(f^*)\)</span> for some function <span class="math inline">\(f^*\)</span> as well as <span class="math inline">\(c^{**}=EVAL_{e}(eval,c^*\|\overline{c})\)</span> for that <span class="math inline">\(f^*\)</span> and keeps <span class="math inline">\(c^*,c^{**}\)</span> for herself, where <span class="math inline">\(eval(f,x)=f(x)\)</span> is the circuit evaluation function.</p></li>
<li><p><strong>Client query:</strong> To ask for an evaluation of <span class="math inline">\(f\)</span>, the client generates a new random FHE keypair <span class="math inline">\((e&#39;,d&#39;)\)</span>, chooses <span class="math inline">\(b \leftarrow_R \{0,1\}\)</span> and lets <span class="math inline">\(c_b = E_{e&#39;}(E_e(f))\)</span> and <span class="math inline">\(c_{1-b}=E_{e&#39;}(c^*)\)</span>. It sends the triple <span class="math inline">\(e&#39;,c_0,c_1\)</span> to the server.</p></li>
<li><p><strong>Server response:</strong> Given the queries <span class="math inline">\(c_0,c_1\)</span>, the server defines the function <span class="math inline">\(g:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> where <span class="math inline">\(g(c)=EVAL_e(eval,c\|\overline{c})\)</span> (for the fixed <span class="math inline">\(\overline{c}\)</span> received) and computes <span class="math inline">\(c&#39;_0,c&#39;_1\)</span> where <span class="math inline">\(c&#39;_b = EVAL_{e&#39;}(g,c_b)\)</span>. (Please pause here and make sure you understand what this step is doing! Note that we use here crucially the fact that <span class="math inline">\(EVAL\)</span> itself is a polynomial time computation.)</p></li>
<li><p><strong>Client check:</strong> Client checks whether <span class="math inline">\(D_{d&#39;}(c&#39;_{1-b})=c^{**}\)</span> and if so accepts <span class="math inline">\(D_d(D_{d&#39;}(c&#39;_b))\)</span> as the answer.</p></li>
</ul>
<p>We claim that if the server cheats then the client will detect this with probability <span class="math inline">\(1/2 - negl(n)\)</span>.
Working this out is a great exercise.
The probability of detection can be amplified to <span class="math inline">\(1-negl(n)\)</span> using appropriate repetition, see the paper for details.</p>
</div>
</div>
<div id="example-an-xor-homomorphic-encryption" class="section level2 hasAnchor" number="15.2">
<h2><span class="header-section-number">15.2</span> Example: An XOR homomorphic encryption<a href="chapfheone.html#example-an-xor-homomorphic-encryption" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>It turns out that Regev’s LWE-based encryption LWEENC we saw before is homomorphic with respect to the class of linear (mod 2) functions.
Let us recall the LWE assumption and the encryption scheme based on it.</p>
<div class="definition" title="DLWE (simplified  variant)">
<p><span id="def:LWEdef" class="definition"><strong>Definition 15.2  </strong></span>Let <span class="math inline">\(q=q(n)\)</span> be some function mapping the natural numbers to primes. The <em><span class="math inline">\(q(n)\)</span>-decision learning with error (<span class="math inline">\(q(n)\)</span>-dLWE) conjecture</em> is the following:
for every <span class="math inline">\(m=poly(n)\)</span> there is a distribution <span class="math inline">\(LWE_q\)</span> over pairs <span class="math inline">\((A,s)\)</span> such that:</p>
<ul>
<li><p><span class="math inline">\(A\)</span> is an <span class="math inline">\(m\times n\)</span> matrix over <span class="math inline">\(\mathbb{Z}_q\)</span> and <span class="math inline">\(s\in\mathbb{Z}_q^n\)</span> satisfies <span class="math inline">\(s_1=\lfloor \tfrac{q}{2} \rfloor\)</span> and <span class="math inline">\(|(As)_i| \leq \sqrt{q}\)</span> for every <span class="math inline">\(i\in \{1,\ldots, m\}\)</span>.</p></li>
<li><p>The distribution <span class="math inline">\(A\)</span> where <span class="math inline">\((A,s)\)</span> is sampled from <span class="math inline">\(LWE_q\)</span> is computationally indistinguishable from the uniform distribution of <span class="math inline">\(m\times n\)</span> matrices over <span class="math inline">\(\mathbb{Z}_q\)</span>.</p></li>
</ul>
</div>
<p>The <em>dLWE conjecture</em> is that <span class="math inline">\(q(n)\)</span>-dLWE holds for every <span class="math inline">\(q(n)\)</span> that is at most <span class="math inline">\(poly(n)\)</span>.
This is not exactly the same phrasing we used before, but as we sketch below, it is essentially equivalent to it.
One can also make the stronger conjecture that <span class="math inline">\(q(n)\)</span>-dLWE holds even for <span class="math inline">\(q(n)\)</span> that is <em>super polynomial</em> in <span class="math inline">\(n\)</span> (e.g., <span class="math inline">\(q(n)\)</span> magnitude roughly <span class="math inline">\(2^n\)</span> - note that such a number can still be described in <span class="math inline">\(n\)</span> bits and we can still efficiently perform operations such as addition and multiplication modulo <span class="math inline">\(q\)</span>).
This stronger conjecture also seems well supported by evidence and we will use it in future lectures.</p>
<blockquote>
<h1 id="section-76" class="pause"></h1>
<p>It is a good idea for you to pause here and try to show the equivalence on your own.</p>
</blockquote>
<p><strong>Equivalence between LWE and DLWE:</strong>
The reason the two conjectures are equivalent are the following.
Before we phrased the conjecture as recovering <span class="math inline">\(s\)</span> from a pair <span class="math inline">\((A&#39;,y)\)</span> where <span class="math inline">\(y=A&#39;s&#39;+e\)</span> and <span class="math inline">\(|e_i|\leq \delta q\)</span> for every <span class="math inline">\(i\)</span>.
We then showed a <em>search to decision</em> reduction (<a href="" class="ref">LWEsearchtodecthm</a>) demonstrating that this is equivalent to the task of distinguishing between this case and the case that <span class="math inline">\(y\)</span> is a random vector.
If we now let <span class="math inline">\(\alpha = \lfloor \tfrac{q}{2} \rfloor\)</span> and <span class="math inline">\(\beta = \alpha^{-1} \pmod q\)</span>, and consider the matrix <span class="math inline">\(A=(-\beta y|A&#39;)\)</span> and the column vector <span class="math inline">\(s=\binom{\alpha}{s&#39;}\)</span> we see that <span class="math inline">\(As = e\)</span>.
Note that if <span class="math inline">\(y\)</span> is a random vector in <span class="math inline">\(\mathbb{Z}_q^m\)</span> then so is <span class="math inline">\(-\beta y\)</span> and so the current form of the conjecture follows from the previous one.
(To reduce the number of free parameters, we fixed <span class="math inline">\(\delta\)</span> to equal <span class="math inline">\(1/\sqrt{q}\)</span>; in this form the conjecture becomes stronger as <span class="math inline">\(q\)</span> grows.)</p>
<p><strong>A linearly-homomorphic encryption scheme:</strong> The following variant of the LWE-ENC described in <a href="" class="ref">lweencsec</a> turns out to be linearly homomorphic:</p>
<div class="quote">
<p><strong>LWE-ENC’ encryption:</strong></p>
<ul>
<li><p><em>Key generation:</em> Choose <span class="math inline">\((A,s)\)</span> from <span class="math inline">\(LWE_q\)</span> where <span class="math inline">\(m\)</span> satisfies <span class="math inline">\(q^{1/4} \gg m \log q \gg n\)</span>.</p></li>
<li><p>To <em>encrypt</em> <span class="math inline">\(b\in\{0,1\}\)</span>, choose <span class="math inline">\(w\in\{0,1\}^m\)</span> and output <span class="math inline">\(w^\top A + (b,0,\ldots,0)\)</span>.</p></li>
<li><p>To <em>decrypt</em> <span class="math inline">\(c\in\mathbb{Z}_q^n\)</span>, output <span class="math inline">\(0\)</span> iff <span class="math inline">\(|\langle c,s \rangle| \leq q/10\)</span>, where for <span class="math inline">\(x\in\mathbb{Z}_q\)</span> we defined <span class="math inline">\(|x| = \min \{ x , q-x \}\)</span>. (Recall that the first coordinate of <span class="math inline">\(s\)</span> is <span class="math inline">\(\lfloor q/2 \rfloor\)</span>.)</p></li>
</ul>
</div>
<p>The decryption algorithm recovers the original plaintext since <span class="math inline">\(\langle c,s \rangle= w^\top A s + s_1 b\)</span> and <span class="math inline">\(|w^\top A s| \leq m\sqrt{q} \ll q\)</span>.
It turns out that this scheme is homomorphic with respect to the class of <em>linear functions</em> modulo <span class="math inline">\(2\)</span>. Specifically we make the following claim:</p>
<blockquote>
<h1 id="parityhomlem" class="lemma"></h1>
<p>For every <span class="math inline">\(\ell \ll q^{1/4}\)</span>, there is an algorithm <span class="math inline">\(EVAL_\ell\)</span> that on input <span class="math inline">\(c_1,\ldots,c_\ell\)</span> which are LWEENC-encryptions of the bits <span class="math inline">\(b_1,\ldots,b_\ell \in \{0,1\}\)</span>, outputs a ciphertext <span class="math inline">\(c\)</span> whose decryption is <span class="math inline">\(b_1 \oplus \cdots \oplus b_\ell\)</span>.</p>
</blockquote>
<blockquote>
<h1 id="section-77" class="pause"></h1>
<p>This claim is not hard to prove, but working it out for yourself can be a good way to get more familiarity with LWE-ENC’ and the kind of manipulations we’ll be making time and again in the constructions of many lattice based cryptographic primitives.
Recall that a ciphertext <span class="math inline">\(c\)</span> of LWE-ENC’ is a vector in <span class="math inline">\(\mathbb{Z}_q^n\)</span>. Try to show that <span class="math inline">\(c = c_1 + \cdots +c_\ell\)</span> (where addition is done as vectors in <span class="math inline">\(\mathbb{Z}_q\)</span>) will be the encryption of <span class="math inline">\(b_1 \oplus \cdots \oplus b_\ell\)</span>.
Note that if <span class="math inline">\(q\)</span> is <em>super polynomial</em> in <span class="math inline">\(n\)</span> then <span class="math inline">\(\ell\)</span> can be an arbitrarily large polynomial in <span class="math inline">\(n\)</span>.</p>
</blockquote>
<div class="proof" data-ref="parityhomlem">
<p><span id="unlabeled-div-41" class="proof"><em>Proof</em>. </span>The proof is quite simple. <span class="math inline">\(EVAL\)</span> will simply add the ciphertexts as vectors in <span class="math inline">\(\mathbb{Z}_q\)</span>.
If <span class="math inline">\(c = \sum c_i\)</span> then
<span class="math display">\[\langle c,s \rangle = \sum b_i \lfloor \tfrac{q}{2} \rfloor  +  \xi \mod q\]</span>
where <span class="math inline">\(\xi \in \mathbb{Z}_q\)</span> is a “noise term” such that <span class="math inline">\(|\xi| \leq \ell m \sqrt{q} \ll q\)</span>.</p>
<p>Since <span class="math inline">\(|\lfloor \tfrac{q}{2} \rfloor-  \tfrac{q}{2}|&lt;1\)</span>, adding at most <span class="math inline">\(\ell\)</span> terms of this difference adds at most <span class="math inline">\(\ell\)</span>, and so we can also write
<span class="math display">\[\langle c,s \rangle = \lfloor  \sum b_i \tfrac{q}{2}  \rfloor  +  \xi&#39; \mod q\]</span>
for <span class="math inline">\(|\xi&#39;| \leq \ell m \sqrt{q} + \ell \ll q\)</span>.</p>
<p>If <span class="math inline">\(\sum b_i\)</span> is even then <span class="math inline">\(\sum b_i \tfrac{q}{2}\)</span> is an integer multiple of <span class="math inline">\(q\)</span> and hence in this case <span class="math inline">\(|\langle c,s \rangle| \ll q\)</span>.
If <span class="math inline">\(\sum b_i\)</span> is odd <span class="math inline">\(\lfloor \sum b_i \tfrac{q}{2} \rfloor = \lfloor q/2 \rfloor \mod q\)</span> and so in this case <span class="math inline">\(|\langle c,s \rangle| = q/2 \pm o(q) &gt; q/10\)</span>.</p>
</div>
<p>Several other encryption schemes are also homomorphic with respect to linear functions. Even before Gentry’s construction there were constructions of encryption schemes that are homomorphic with respect to somewhat larger classes (e.g., quadratic functions by Boneh, Goh and Nissim) but not significantly so.</p>
<div id="abstraction-a-trapdoor-pseudorandom-generator." class="section level3 hasAnchor" number="15.2.1">
<h3><span class="header-section-number">15.2.1</span> Abstraction: A trapdoor pseudorandom generator.<a href="chapfheone.html#abstraction-a-trapdoor-pseudorandom-generator." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>It is instructive to consider the following abstraction (which we’ll use in the next lecture) of the above encryption scheme as a <em>trapdoor generator</em> (see <a href="" class="ref">TDPgenfig</a>).
On input <span class="math inline">\(1^n\)</span> the key generation algorithm outputs a vector <span class="math inline">\(s\in\mathbb{Z}_q^m\)</span> with <span class="math inline">\(s_1 = \lfloor \tfrac{q}{2} \rfloor\)</span> and a probabilistic algorithm <span class="math inline">\(G_s\)</span> such that the following holds:</p>
<ul>
<li><p>Any polynomial number of samples from the distribution <span class="math inline">\(G_s(1^n)\)</span> is computationally indistinguishable from independent samples from the uniform distribution over <span class="math inline">\(\mathbb{Z}_q^n\)</span>.</p></li>
<li><p>If <span class="math inline">\(c\)</span> is output by <span class="math inline">\(G_s(1^n)\)</span> then <span class="math inline">\(|\langle c,s \rangle| \leq n\sqrt{q}\)</span>.</p></li>
</ul>
<p>The generator <span class="math inline">\(G_s\)</span> picks <span class="math inline">\(w \leftarrow_R \{0,1\}^m\)</span> to <span class="math inline">\(w^\top A\)</span>. Its output will look pseudorandom but will satisfy the condition <span class="math inline">\(|\langle G_s(1^n),s \rangle| \leq n\sqrt{q}\)</span> with probability <span class="math inline">\(1\)</span> over the choice of <span class="math inline">\(w\)</span>.
Thus <span class="math inline">\(s\)</span> can be thought of a “trapdoor” for the generator that allows us to distinguish between a random vector <span class="math inline">\(c\in \mathbb{Z}_q^n\)</span> (that with high probability would satisfy <span class="math inline">\(|\langle c,s \rangle| \gg n\sqrt{q}\)</span>, assuming <span class="math inline">\(q \gg n^2\)</span>) and an output of the generator.</p>
<p>We use <span class="math inline">\(G_s\)</span> to encrypt a bit <span class="math inline">\(b\)</span> by letting <span class="math inline">\(c \leftarrow_R G_s(1^n)\)</span> and outputting <span class="math inline">\(c + (b,0,\ldots,0)^\top\)</span>.
While our particular implementation mapped <span class="math inline">\(G_s(w)= w^\top A\)</span>, we can ignore these implementation details in the forgoing.</p>
<div class="float" id="TDPgenfig">
<img src="../figure/trapdoorprg.png" alt="In a trapdoor generator, we have two ways to generate randomized algorithms. That is, we have some algorithms GEN and GEN&#39; such that GEN outputs a pair (G_s,s) and GEN&#39; outputs G&#39; with G_s,G&#39; being themselves algorithms (e.g., randomized circuits). The conditions we require are that (1) the descriptions of the circuits G_s and G&#39; (considering them as distributions over strings) are computationally indistinguishable and (2) the distribution G&#39;(1^n) is statistically indistinguishable from the uniform distribution , (3) there is an efficient algorithm that given the secret “trapdoor” s can distinguish the output of G_s from the uniform distribution. In particular (1),(2), and (3) together imply that it is not feasible to extract s from the description of G_s." />
<div class="figcaption">In a <em>trapdoor generator</em>, we have two ways to generate randomized algorithms. That is, we have some algorithms <span class="math inline">\(GEN\)</span> and <span class="math inline">\(GEN&#39;\)</span> such that <span class="math inline">\(GEN\)</span> outputs a pair <span class="math inline">\((G_s,s)\)</span> and <span class="math inline">\(GEN&#39;\)</span> outputs <span class="math inline">\(G&#39;\)</span> with <span class="math inline">\(G_s,G&#39;\)</span> being themselves algorithms (e.g., randomized circuits). The conditions we require are that <strong>(1)</strong> the descriptions of the circuits <span class="math inline">\(G_s\)</span> and <span class="math inline">\(G&#39;\)</span> (considering them as distributions over strings) are computationally indistinguishable and <strong>(2)</strong> the distribution <span class="math inline">\(G&#39;(1^n)\)</span> is <em>statistically indistinguishable</em> from the uniform distribution , <strong>(3)</strong> there is an efficient algorithm that given the secret “trapdoor” <span class="math inline">\(s\)</span> can distinguish the output of <span class="math inline">\(G_s\)</span> from the uniform distribution. In particular <strong>(1)</strong>,<strong>(2)</strong>, and <strong>(3)</strong> together imply that it is <em>not</em> feasible to extract <span class="math inline">\(s\)</span> from the description of <span class="math inline">\(G_s\)</span>.</div>
</div>
<p>Our LWE-based trapdoor generator satisfies the following stronger property: we can generate an alternative generator <span class="math inline">\(G&#39;\)</span> such that the description of <span class="math inline">\(G&#39;\)</span> is indistinguishable from the description of <span class="math inline">\(G_s\)</span> but such that <span class="math inline">\(G&#39;\)</span> actually does produce (up to exponentially small statistical error) the uniform distribution over <span class="math inline">\(\mathbb{Z}_q^n\)</span>. We can do so by sampling <span class="math inline">\(A\)</span> completely at random instead of from the <span class="math inline">\(LWE_q\)</span> distribution.
We can define trapdoor generators formally as follows</p>
<div class="definition" title="Trapdoor generators">
<p><span id="def:tdpgendef" class="definition"><strong>Definition 15.3  </strong></span>A <em>trapdoor generator</em> is a pair of randomized algorithms <span class="math inline">\(GEN,GEN&#39;\)</span> that satisfy the following:</p>
<ul>
<li><p>On input <span class="math inline">\(1^n\)</span>, <span class="math inline">\(GEN\)</span> outputs a pair <span class="math inline">\((G_s,s)\)</span> where <span class="math inline">\(G_s\)</span> is a string describing a <em>randomized</em> circuit. The circuit <span class="math inline">\(G_s\)</span> takes <span class="math inline">\(1^n\)</span> as input and outputs a (randomly chosen) string of length <span class="math inline">\(t\)</span> where <span class="math inline">\(t=t(n)\)</span> is some polynomial.</p></li>
<li><p>On input <span class="math inline">\(1^n\)</span>, <span class="math inline">\(GEN&#39;\)</span> outputs <span class="math inline">\(G&#39;\)</span> where <span class="math inline">\(G&#39;\)</span> is a string describing a randomized circuit with the same inputs and outputs.</p></li>
<li><p>The distributions <span class="math inline">\(GEN(1^n)_1\)</span> (i.e., the first output of <span class="math inline">\(GEN(1^n)\)</span>) and <span class="math inline">\(GEN&#39;(1^n)_1\)</span> are computationally indistinguishable. (These are both distributions over <em>circuits</em>.)</p></li>
<li><p>With probability <span class="math inline">\(1-negl(n)\)</span> over the choice of <span class="math inline">\(G&#39;\)</span> output by <span class="math inline">\(GEN&#39;\)</span>, the distribution <span class="math inline">\(G&#39;(1^n)\)</span> is <em>statistically indistinguishable</em> (i.e., within <span class="math inline">\(negl(n)\)</span> total variation distance) from <span class="math inline">\(U_t\)</span> (i.e., the uniform distribution over <span class="math inline">\(\{0,1\}^t\)</span>).</p></li>
<li><p>There is an efficient algorithm <span class="math inline">\(T\)</span> such that for every pair <span class="math inline">\((G_s,s)\)</span> output by <span class="math inline">\(GEN\)</span>, <span class="math inline">\(\Pr[ T(s,G_s(1^n))=1] \geq 1- negl(n)\)</span> (where this probability is over the internal randomness used by <span class="math inline">\(G_s\)</span> on the input <span class="math inline">\(1^n\)</span>) but <span class="math inline">\(\Pr[ T(s,U_t)=1] \leq 1/3\)</span>.<a href="#fn92" class="footnote-ref" id="fnref92"><sup>92</sup></a></p></li>
</ul>
</div>
<blockquote>
<h1 id="section-78" class="pause"></h1>
<p>This is not an easy definition to parse, but looking at <a href="" class="ref">TDPgenfig</a> can help.
Make sure you understand why <span class="math inline">\(LWEENC\)</span> gives rise to a trapdoor generator satisfying all the conditions of <a href="" class="ref">tdpgendef</a>.</p>
</blockquote>
<div class="remark" title="Trapdoor generators in real life">
<p><span id="trapdoorgenreal" class="remark"><em>Remark</em>. </span>In the above we use the notion of a “trapdoor” in the pseudorandom generator as a mathematical abstraction, but generators with actual trapdoors have arisen in practice. In 2007 the National Institute of Standards (NIST) released standards for pseudorandom generators. Pseudorandom generators are the quintessential private key primitive, typically built out of hash functions, block ciphers, and such and so it was surprising that NIST included in the list a pseudorandom generator based on public key tools - the <a href="https://en.wikipedia.org/wiki/Dual_EC_DRBG">Dual EC DRBG</a> generator based on elliptic curve cryptography. This was already strange but became even more worrying when Microsoft researchers Dan Shumow and Niels Ferguson <a href="http://rump2007.cr.yp.to/15-shumow.pdf">showed</a> that this generator <em>could</em> have a trapdoor in the sense that it contained some hardwired constants that if generated in a particular way, there would be some information that (just like in <span class="math inline">\(G_s\)</span> above) allows to distinguish the generator from random (see here for a <a href="https://www.schneier.com/blog/archives/2007/11/the_strange_sto.html">2007 blog post</a> on this issue). We learned more about this when leaks from the Snowden document <a href="http://www.reuters.com/article/us-usa-security-rsa-idUSBRE9BJ1C220131220">showed</a> that the NSA secretly paid 10 million dollars to RSA to make this generator the default option in their Bsafe software.</p>
<p>You’d think that this generator is long dead but it turns out to be the “gift that keeps on giving”.
In December of 2015, Juniper systems <a href="http://www.wired.com/2015/12/juniper-networks-hidden-backdoors-show-the-risk-of-government-backdoors/">announced</a> that they have discovered a malicious code in their system, dating back to at least 2012 (possibly <a href="https://goo.gl/X6pAXV">2008</a>), that would allow an attacker to surreptitiously decrypt all VPN traffic through their firewalls.
The issue is that Juniper has been using the Dual EC DRBG and someone has managed to replace the constant they were using with another one, one that they presumably knew the trapdoor for (see <a href="https://rpw.sh/blog/2015/12/21/the-backdoored-backdoor/">here</a> and <a href="http://blog.cryptographyengineering.com/2015/12/on-juniper-backdoor.html">here</a> for more; of course unless you know to check for this, it’s very hard by looking at the code to see that one arbitrary looking constant has been replaced by another).
Apparently, even though this is very surprising to many people in law enforcement and government, inserting back doors into cryptographic primitives might end up making them less secure. Some more details have emereged in this case in 2021, see <a href="https://finance.yahoo.com/news/juniper-breach-mystery-starts-clear-130016591.html">this story</a> and <a href="https://twitter.com/matthew_d_green/status/1433451378391883782?s=20">this Tweet thread</a>.</p>
</div>
</div>
</div>
<div id="from-linear-homomorphism-to-full-homomorphism" class="section level2 hasAnchor" number="15.3">
<h2><span class="header-section-number">15.3</span> From linear homomorphism to full homomorphism<a href="chapfheone.html#from-linear-homomorphism-to-full-homomorphism" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Gentry’s breakthrough had two components:</p>
<ul>
<li><p>First, he gave a scheme that is homomorphic with respect to arithmetic circuits (involving not just addition but also multiplications) of <em>logarithmic depth</em>.</p></li>
<li><p>Second, he showed the amazing “bootstrapping theorem” that if a scheme is homomorphic enough to evaluate its own decryption circuit, then it can be turned into a <em>fully homomorphic</em> encryption that can evaluate <em>any</em> function.</p></li>
</ul>
<p>Combining these two insights led to his fully homomorphic encryption.<a href="#fn93" class="footnote-ref" id="fnref93"><sup>93</sup></a></p>
<p>In this lecture we will focus on the second component - the bootstrapping theorem.
We will show a “partially homomorphic encryption” (based on a later work of Gentry, Sahai and Waters) that can fit that theorem in the next lecture.</p>
</div>
<div id="bootstrapping-fully-homomorphic-escape-velocity" class="section level2 hasAnchor" number="15.4">
<h2><span class="header-section-number">15.4</span> Bootstrapping: Fully Homomorphic “escape velocity”<a href="chapfheone.html#bootstrapping-fully-homomorphic-escape-velocity" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div class="float" id="bootstrapfig">
<img src="../figure/fheescape.png" alt="The “Bootstrapping Theorem” shows that once a partially homomorphic encryption scheme is homomorphic with respect to a rich enough family of functions, and specifically a family that contains its own decryption algorithm, then it can be converted to a fully homomorphic encryption scheme that can be used to evaluate any function." />
<div class="figcaption">The “Bootstrapping Theorem” shows that once a partially homomorphic encryption scheme is homomorphic with respect to a rich enough family of functions, and specifically a family that contains its own decryption algorithm, then it can be converted to a fully homomorphic encryption scheme that can be used to evaluate <em>any</em> function.</div>
</div>
<p>The bootstrapping theorem is quite surprising.
A priori you might expect that given that a homomorphic encryption for linear functions was not trivial to do, a homomorphic encryption for quadratics would be harder, cubics even harder and so on and so forth.
But it turns out that there is some special degree <span class="math inline">\(t^*\)</span> such that if we obtain homomorphic encryption for degree <span class="math inline">\(t^*\)</span> polynomials then we can obtain <em>fully</em> homomorphic encryption that works for <em>all</em> functions.
(Specifically, if the decryption algorithm <span class="math inline">\(c \mapsto D_d(c)\)</span> is a degree <span class="math inline">\(t\)</span> polynomial, then homomorphically evaluating polynomials of degree <span class="math inline">\(t^*=2t\)</span> will be sufficient.)
That is, it turns out that once an encryption scheme is strong enough to <em>homomorphically evaluate its own decryption algorithm</em> then we can use it to obtain a fully homomorphic encryption by “pulling itself up by its own bootstraps”.
One analogy is that at this point the encryption reaches “escape velocity” and we can continue onwards evaluating gates in perpetuity.</p>
<p>We now show the bootstrapping theorem:</p>
<blockquote>
<h1 id="bootstrapthm" class="theorem" title="Bootstrapping Theorem, Gentry 2009"></h1>
<p>Suppose that <span class="math inline">\((G,E,D)\)</span> is a CPA circular<a href="#fn94" class="footnote-ref" id="fnref94"><sup>94</sup></a> secure partially homomorphic encryption scheme for the family <span class="math inline">\(\mathcal{F}\)</span> and suppose that for every pair of ciphertexts <span class="math inline">\(c,c&#39;\)</span> the map <span class="math inline">\(d \mapsto D_d(c) \;NAND\; D_d(c&#39;)\)</span> is in <span class="math inline">\(\mathcal{F}\)</span>. Then <span class="math inline">\((G,E,D)\)</span> can be turned a fully homomorphic encryption scheme.</p>
</blockquote>
<div id="radioactive-legos-analogy" class="section level3 hasAnchor" number="15.4.1">
<h3><span class="header-section-number">15.4.1</span> Radioactive legos analogy<a href="chapfheone.html#radioactive-legos-analogy" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Here is one analogy for bootstrapping, inspired by Gentry’s <a href="https://crypto.stanford.edu/craig/easy-fhe.pdf">survey</a>.
Suppose that you need to construct some complicated object from a highly toxic material (see <a href="" class="ref">ziplocbagfig</a>).
For example you want to build a castle out of radio-active legos.</p>
<p>You are given a supply of sealed bags that are flexible enough so you can manipulate the object from outside the bag.
However, each bag can only hold for <span class="math inline">\(10\)</span> seconds of such manipulations before it leaks.
The idea is that if you can open one bag inside another within <span class="math inline">\(9\)</span> seconds then you can use the extra second to perform one step. By repeating this, you perform the manipulations for arbitrary length.</p>
<p>Specifically, suppose that you have completed <span class="math inline">\(i\)</span> steps out of the total of <span class="math inline">\(T\)</span>, and now have the partially constructed castle inside a sealed bag <span class="math inline">\(B_i\)</span>.
You now put the bag <span class="math inline">\(B_i\)</span> <em>inside</em> a fresh bag <span class="math inline">\(B_{i+1}\)</span>. You now spend <span class="math inline">\(9\)</span> seconds on opening the bag <span class="math inline">\(B_i\)</span> inside the bag <span class="math inline">\(B_{i+1}\)</span>, and an extra second on performing the <span class="math inline">\(i+1\)</span> step in the construction.
At this point we have completed <span class="math inline">\(i+1\)</span> steps and have the object in the bag <span class="math inline">\(B_{i+1}\)</span>, we can now continue by putting in the bag <span class="math inline">\(B_{i+2}\)</span> and so on and so forth.</p>
<div class="float" id="ziplocbagfig">
<img src="../figure/fheziplocbag.png" alt="To build a castle from radioactive Lego bricks, which can be kept safe in a special ziploc bag for 10 seconds, we can: 1) Place the bricks in a bag, and place the bag inside an outer bag. 2) Manipulate the inner bag through the outer bag to remove the bricks from it in 9 seconds, and spend 1 second putting one brick in place. Now, just before the outer bag “leaks” we put it inside a fresh new bag and repeat the process." />
<div class="figcaption">To build a castle from radioactive Lego bricks, which can be kept safe in a special ziploc bag for 10 seconds, we can: 1) Place the bricks in a bag, and place the bag inside an outer bag. 2) Manipulate the inner bag through the outer bag to remove the bricks from it in 9 seconds, and spend 1 second putting one brick in place. Now, just before the outer bag “leaks” we put it inside a fresh new bag and repeat the process.</div>
</div>
</div>
<div id="proving-the-bootstrapping-theorem" class="section level3 hasAnchor" number="15.4.2">
<h3><span class="header-section-number">15.4.2</span> Proving the bootstrapping theorem<a href="chapfheone.html#proving-the-bootstrapping-theorem" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>We now turn to the formal proof of <a href="" class="ref">bootstrapthm</a></p>
<div class="proof" data-ref="bootstrapthm">
<p><span id="unlabeled-div-42" class="proof"><em>Proof</em>. </span>The idea behind the proof is simple but ingenious.
Recall that the NAND gate <span class="math inline">\(b,b&#39; \mapsto \neg(b \wedge b&#39;)\)</span> is a universal gate that allows us to compute any function <span class="math inline">\(f:\{0,1\}^n\rightarrow\{0,1\}\)</span> that can be efficiently computed.
Thus, to obtain a fully homomorphic encryption it suffices to obtain a function <span class="math inline">\(NANDEVAL\)</span> such that
<span class="math inline">\(D_d(NANDEVAL(c,c&#39;))=D_d(c) \;NAND\; D_d(c&#39;)\)</span>.
(Note that this is stronger than the typical notion of homomorphic evaluation since we require that <span class="math inline">\(NANDEVAL\)</span> outputs an encryption of <span class="math inline">\(b \;NAND\; b&#39;\)</span> when given <em>any</em> pair of ciphertexts that decrypt to <span class="math inline">\(b\)</span> and <span class="math inline">\(b&#39;\)</span> respectively, regardless whether these ciphertexts were produced by the encryption algorithm or by some other method, including the <span class="math inline">\(NANDEVAL\)</span> procedure itself.)</p>
<p>Thus to prove the theorem, we need to modify <span class="math inline">\((G,E,D)\)</span> into an encryption scheme supporting the <span class="math inline">\(NANDEVAL\)</span> operation.
Our new scheme will use the same encryption algorithms <span class="math inline">\(E\)</span> and <span class="math inline">\(D\)</span> but the following modification <span class="math inline">\(G&#39;\)</span> of the key generation algorithm: after running <span class="math inline">\((d,e)=G(1^n)\)</span>, we will append to the public key an encryption <span class="math inline">\(c^* = E_e(d)\)</span> of the secret key.
We have now defined the key generation, encryption and decryption.
CPA security follows from the security of the original scheme, where by circular security we refer exactly to the condition that the scheme is secure even if the adversary gets a single encryption of the public key.<a href="#fn95" class="footnote-ref" id="fnref95"><sup>95</sup></a>
This latter condition is not known to be implied by standard CPA security but as far as we know is satisfied by all natural public key encryptions, including the LWE-based ones we will plug into this theorem later on.</p>
<p>So, now all that is left is to define the <span class="math inline">\(NANDEVAL\)</span> operation. On input two ciphertexts <span class="math inline">\(c\)</span> and <span class="math inline">\(c&#39;\)</span>, we will construct the function <span class="math inline">\(f_{c,c&#39;}:\{0,1\}^n\rightarrow\{0,1\}\)</span> (where <span class="math inline">\(n\)</span> is the length of the secret key) such that <span class="math inline">\(f_{c,c&#39;}(d)=D_d(c) \;NAND\; D_d(c&#39;)\)</span>.
It would be useful to pause at this point and make sure you understand what are the inputs to <span class="math inline">\(f_{c,c&#39;}\)</span>, what are “hardwired constants” and what is its output.
The ciphertexts <span class="math inline">\(c\)</span> and <span class="math inline">\(c&#39;\)</span> are simply treated as fixed strings and are <em>not</em> part of the input to <span class="math inline">\(f_{c,c&#39;}\)</span>.
Rather <span class="math inline">\(f_{c,c&#39;}\)</span> is a function (depending on the strings <span class="math inline">\(c,c&#39;\)</span>) that maps the secret key into a bit.
When running <span class="math inline">\(NANDEVAL\)</span> we of course do not know the secret key <span class="math inline">\(d\)</span>, but we can still design a circuit that computes this function <span class="math inline">\(f_{c,c&#39;}\)</span>.
Now <span class="math inline">\(NANDEVAL(c,c&#39;)\)</span> will simply be defined as <span class="math inline">\(EVAL(f_{c,c&#39;},c^*)\)</span>.
Since <span class="math inline">\(c^* = E_e(d)\)</span>, we get that
<span class="math display">\[D_d(NANDEVAL(c,c&#39;))= D_d(EVAL(f_{c,c&#39;},c^*))=f_{c,c&#39;}(d) =D_d(c) \;NAND\; D_d(c&#39;) \;.\]</span>
Thus indeed we map <em>any</em> pair of ciphertexts <span class="math inline">\(c,c&#39;\)</span> that decrypt to <span class="math inline">\(b,b&#39;\)</span> into a ciphertext <span class="math inline">\(c&#39;&#39;\)</span> that decrypts to <span class="math inline">\(b \;NAND\; b&#39;\)</span>.
This is all that we needed to prove.</p>
</div>
<blockquote>
<h1 id="section-79" class="pause"></h1>
<p>Don’t let the short proof fool you. This theorem is quite deep and subtle, and requires some reading and re-reading to truly “get” it.</p>
</blockquote>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="90">
<li id="fn90"><p>In <a href="https://eprint.iacr.org/2012/099.pdf">2015</a> the state of art on homomorphically evaluating AES was about 6 seconds of computation per block using about 4GB memory total for 180 blocks. See also <a href="https://link.springer.com/article/10.1007/s10623-015-0095-1">this paper</a>. In contrast, modern processors can evaluate <a href="https://www.bearssl.org/speed.html">10s-100s millions</a> of AES blocks per second.<a href="chapfheone.html#fnref90" class="footnote-back">↩︎</a></p></li>
<li id="fn91"><p>As we mentioned before, as a general rule of thumb, the difference between the ideal schemes and the one that we describe is that in the ideal setting one deals with <em>structured</em> matrices that have a compact representation as a single vector and also enable fast FFT-like matrix-vector multiplication. This saves a factor of about <span class="math inline">\(n\)</span> in the storage and computation requirements (where <span class="math inline">\(n\)</span> is the dimension of the subspace/lattice). However, there can be some subtle security implications for ideal lattices as well, see e.g., <a href="https://eprint.iacr.org/2016/127">here</a>, <a href="https://eprint.iacr.org/2015/313">here</a>, <a href="https://eprint.iacr.org/2016/139">here</a>, and <a href="https://eprint.iacr.org/2015/676">here</a>.<a href="chapfheone.html#fnref91" class="footnote-back">↩︎</a></p></li>
<li id="fn92"><p>The choice of <span class="math inline">\(1/3\)</span> is arbitrary, and can be amplified as needed.<a href="chapfheone.html#fnref92" class="footnote-back">↩︎</a></p></li>
<li id="fn93"><p>The story is a bit more complex than that. Frustratingly, the decryption circuit of Gentry’s basic scheme was just a little bit too deep for the bootstrapping theorem to apply. A lesser man, such as yours truly, would at this point surmise that fully homomprphic encryption was just not meant to be, and perhaps take up knitting or playing bridge as an alternative hobby. However, Craig persevered and managed to come up with a way to “squash” the decryption circuit so it can fit the bootstrapping parameters. Follow up works, and in particular the paper of Brakerski and Vaikuntanathan, managed to get schemes with much better relation between the homomorphism depth and decryption circuit, and hence avoid the need for squashing and also improve the security assumptions.<a href="chapfheone.html#fnref93" class="footnote-back">↩︎</a></p></li>
<li id="fn94"><p>You can ignore the condition of circular security in a first read - we will discuss it later.<a href="chapfheone.html#fnref94" class="footnote-back">↩︎</a></p></li>
<li id="fn95"><p>Without this assumption we can still obtain a form of FHE known as a <em>leveled</em> FHE where the size of the public key grows with the <a href="https://en.wikipedia.org/wiki/Circuit_complexity">depth</a> of the circuit to be evaluated. We can do this by having <span class="math inline">\(\ell\)</span> public keys where <span class="math inline">\(\ell\)</span> is the depth we want to evaluate, and encrypt the private key of the <span class="math inline">\(i^{th}\)</span> key with the <span class="math inline">\(i+1^{st}\)</span> public key. However, since circular security seems quite likely to hold, we ignore this extra complication in the rest of the discussion.<a href="chapfheone.html#fnref95" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="zero-knowledge-proofs.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="chapfhetwo.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/14-FHE.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
